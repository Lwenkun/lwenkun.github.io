---
layout:     post
title:      "探究 Java 虚拟机栈"
subtitle:   "explore JVM stack"
date:       2017-03-06
author:     "lwenkun"
header-img: "img/post-bg-java-vm-stack.jpg"
tags:
    - java
    - JVM
    - virtual stack
---


# 探究 Java 虚拟机栈 #
## 前言 ##
java 虚拟机的内存模型分为两部分：一部分是线程共享的，包括 java 堆和方法区；另一部分是线程私有的，包括虚拟机栈和本地方法栈，以及程序计数器这一小部分内存。今天我就 Java 虚拟机栈做一些比较浅的探究。

熟悉 java 的同学应该都知道了，JVM 是基于栈的。但是这个“栈” 具体指的是什么？难道就是虚拟机栈？想要回答这个问题我们先要从虚拟机栈的结构谈起。

## 虚拟机栈 ##
### 何为虚拟机栈 ###
虚拟机栈的栈元素是栈帧，当有一个方法被调用时，代表这个方法的栈帧入栈；当这个方法返回时，其栈帧出栈。因此，虚拟机栈中栈帧的入栈顺序就是方法调用顺序。什么是栈帧呢？栈帧可以理解为一个方法的运行空间。它主要由两部分构成，一部分是局部变量表，方法中定义的局部变量以及方法的参数就存放在这张表中；另一部分是操作数栈，用来存放操作数。我们知道，java 程序编译之后就变成了一条条字节码指令，其形式类似汇编，但和汇编有不同之处：汇编指令的操作数存放在数据段和寄存器中，可通过存储器或寄存器寻址找到需要的操作数；而 java 字节码指令的操作数存放在操作数栈中，当执行某条带 n 个操作数的指令时，就从栈顶取 n 个操作数，然后把指令的计算结果（如果有的话）入栈。因此，当我们说 JVM 执行引擎是基于栈的时候，其中的“栈”指的就是操作数栈。举个简单的例子对比下汇编指令和 java 字节码指令的执行过程，比如计算 `1 + 2`，在汇编指令是这样的：

```armasm
mov ax, 1 ;把 1 放入寄存器 ax
add ax, 2 ;用 ax 的内容和 2 相加后存入 ax
```

而 JVM 的字节码指令是这样的：

```armasm
iconst_1 //把整数 1 压入操作数栈
iconst_2 //把整数 2 压入操作数栈
iadd //栈顶的两个数相加后出栈，结果入栈
```

由于操作数栈是内存空间，所以字节码指令不必担心不同机器上寄存器以及机器指令的差别，从而做到了平台无关。

注意，局部变量表中的变量不可直接使用，如需使用必须通过相关指令将其加载至操作数栈中作为操作数使用。比如有一个方法 `void foo()`，其中的代码为：`int a = 1 + 2; int b = a + 3;`，编译为机器指令就是这样的：

```armasm
iconst_1 //把整数 1 压入操作数栈
iconst_2 //把整数 2 压入操作数栈
iadd //栈顶的两个数出栈后相加，结果入栈
istore_1 //把栈顶的内容放入局部变量表中索引为 1 的 slot 中，也就是 a 对应的空间中
iload_1 // 把局部变量表索引为 1 的 slot 中存放的变量值（3）加载至操作数栈
iconst_3 // 把整数 3 压入操作数栈
iadd //栈顶的两个数出栈后相加，结果入栈
istore_2 // 把栈顶的内容放入局部变量表中索引为 2 的 slot 中，也就是 b 对应的空间中
```

需要说明的是，局部变量表以及操作数栈的容量的最大值在编译时就已经确定了，运行时不会改变。并且局部变量表的空间是可以复用的，例如，当指令的位置超出了局部变量表中某个变量 a 的作用域时，如果有新的局部变量 b 要被定义，b 就会覆盖 a 在局部变量表的空间。

盗用别人的图以让大家对虚拟机栈有个直观的认识（其中小字体 Stack 指的的是虚拟机栈，Frame 是栈帧，Local variables 是局部变量表，Operand Stack 是操作数栈）：

![虚拟机栈](/img/in-post/post_java_vm_stack/vm_stack.png)

## 由虚拟机栈引出的问题 ##

看完上面的代码大家可能会有几点疑惑：什么是 slot？那些指令是什么意思？为什么 `a` 对应的 slot 的索引值不是从零开始的，它明明是第一个定义的变量啊？

对于这些问题我们一个个来解决。

### 什么是 slot ###

首先什么是 slot？slot 是局部变量表中的空间单位，虚拟机规范中有规定，对于 32 位之内的数据，用一个 slot 来存放，如 `int`，`short`，`float` 等；对于 64 位的数据用连续的两个 slot 来存放，如 `long`，`double` 等。引用类型的变量 JVM 并没有规定其长度，它可能是 32 位，也有可能是 64 位的，所以既有可能占一个 slot，也有可能占两个 slot。

### JVM 字节码指令 ###
第二个问题，那些指令是什么意思？

#### 指令格式 ####
首先我们要理解 java 指令的格式，java 的指令以字节为单位，也就是一个字节代表一条指令。比如 `iconst_1` 就是一条指令，它占一个字节，那么自然 java 指令的的条数不会超过 256 条。实际上 java 指令目前定义了 200 多条。指令虽然是一个字节，但是它也可以带自己的参数，比如 JVM 中有这样一条指令 `putstatic`，它的意思是给特定的的静态字段赋值。但是给那个字段赋值呢？仅仅通过这条指令并不能说明，那么只有通过参数来指定了。它后面跟了个参数，这个参数占用两个个字节，存放的是指向常量池中该静态字段的 `Constant_FieldRef_info` 这个符号引用，这个符号引用中包含了该字段的基本信息，包括所属类、简单名称以及描述符，这样一来，就知道是给哪个类的那个字段赋值了。

指令除了可以带参数外，还可以指定操作数。指令的参数和操作数很容易混淆。这里说明一下，指令的参数用来补充说明该指令，它紧跟指令字节码之后，在编译时就已经确定；而操作数是指令要使用的内容，它在操作数栈中，运行时才能确定。还拿 `putstatic` 这条指令来说，它的操作数就是栈顶的那个数。

其中 `iconst_<i>` 的意思是把整数 i 放入操作数栈中，i 的范围是（m1, 0, 2, 3, 4, 5)，其中 m1 代表的是 -1。注意，这里的 i 并不是指令参数，`iconst_1`、`iconst_2`、`iconst_3` 都是单独的字节码指令，i 可以看作是指令的“隐藏参数”。如果整数的范围超过这个范围呢？难道还有 `iconst_6`、`iconst_7`...`iconst_12345`？当然不是，如果这样，那用一个字节表示字节码指令根本不够用。此时就需要 `bipush` 这条指令了，这条指令有一个参数，这个参数用一个字节表示，用来表示要放入栈顶的那个整数，该整数放入栈顶时会扩展符号位变为 32 位的整型。但是一个字节也表示不了所有的整数，如果整数值超过一个字节所能表示的范围，就只能通过 `ldc` 这条指令了，这条指令也带有两个字节的参数，但是这个参数是指向常量池的 `Constant_Integer_info` 这个常量的索引，通过常量池中的常量来表示一个整型再大的整数也不怕了。

#### 阅读指令文档 ####
在这里不可能将所有的指令都讲解一番，因此授之以鱼不如授之以渔，在这里我教大家如何阅读 oracle 官网关于字节码指令的文档吧。文档的地址是：[https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html)

我们拿 `astore` 指令来说：
关于它的文档描述如下：

![astore 指令](/img/in-post/post_java_vm_stack/java_instruction_astore.png)

说明和翻译：

- 第一行的粗体字是指令的名称；
- Operation 是指令的功能：把引用存入本地变量中；
- Format 是指令的格式，它的第一个字节是指令，名称为 `astore`，第二个字节是指令的参数，名称为 index；Forms 指的是指令的十进制（十六进制）码，`astore` 的十进制（十六进制）码是 `130（0x82)`；
- Operation Stack是指令执行前后的操作数栈的状态，第一行代表的是指令执行前操作数的状态，第二行是指令执行后操作数栈的状态，箭头是栈顶方向，`astore` 执行前栈顶是对象引用 objectRef，执行后 objectRef 被弹出并存入局部变量表中；
- Description 是对这条指令的描述，这里说的是 index 是无符号字节，这个 index 必须指向当前栈帧的局部变量表的某个位置。操作数栈的栈顶的那个引用值必须是 returnAddress（方法返回地址）或者是 reference （对象引用）。这个引用会被弹出，其值会被存入局部变量表中索引为 index 的 slot 中；
- Notes 是注意事项，实现 java 中的 `finally` 子句时，`astore` 指令使用的操作数类型是一个 returnAddress，与 `astore` 对应的 `aload` 指令（将局部变量表的的引用值压栈）不能将类型为 returnAddress，而只能是 reference 类型，`aload` 和 `astore` 这种不对称的设计是有意而为之的。`astore` 指令可以和 `wide` 指令配合使用以用无符号双字节类型的索引来获取局部变量表中的变量。

### 局部变量表的第一个变量 ###
了解了指令的知识，现在看看第三个问题：为什么 `a` 在局部变量表的索引不是从零开始的。其实 JVM  中的方法是所有对象共享的，这和 C++ 类似。方法在执行的时候并不知道执行这个方法的对象是那个，那怎么办？很简单，就把这个对象也作为参数传入方法中，写 java 代码时我们并不需要显示的这么做，这一步是编译器把源码翻译成字节码时做的。因此，只要是实例方法都会传入这个隐藏参数，并且位于变量表索引为 0 的 slot 中，而类方法不同，因为它和具体对象无关。这样就解决了第三个问题，对于实例方法来说，局部变量表的第一个位置存放的是接受该方法调用的对象的引用。

## 感谢阅读 ##
关于虚拟机栈就讲这么多了，java 虚拟机是一个完整的知识体系，仅仅了解虚拟机栈是不够的，这里没有细讲的关于虚拟机的其它知识，如内存模型、运行时常量池、类加载模型等，还需读者自己学习掌握。这篇文章权起激发大家的学习 JVM 兴趣的作用，同时也作为个人的学习记录和知识总结，之后可能还会写些 JVM 其它方面的总结性文章和大家分享。由于个人水平和理解有限，如果有不对的地方还请大家不吝赐教，感谢阅读！

<b> 参考书籍 :</b>《深入理解 java 虚拟机》周志明 著  
<b> JVM 学习网站 :</b> [The Java® Virtual Machine Specification](https://docs.oracle.com/javase/specs/jvms/se8/html/index.html)（Java 虚拟机规范官网文档）
