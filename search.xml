<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Volley 学习总结</title>
    <url>/2016/04/16/2016-04-16-android-opensource-volley/</url>
    <content><![CDATA[<h1 id="Volley-学习总结"><a href="#Volley-学习总结" class="headerlink" title="Volley 学习总结"></a>Volley 学习总结</h1><p>Volley 是谷歌提供的 android 网络通信框架。在安卓中，谷歌提供了两种网络通信有关的类 <code>HttpClient</code> 和 <code>HttpUrlConnection</code>，但是如果不适当封装，很容写很多重复的代码。谷歌也意识到了这个问题，所以提供了 Volley 来解决这个问题。</p>
<span id="more"></span>

<h2 id="StringRequest的用法"><a href="#StringRequest的用法" class="headerlink" title="StringRequest的用法"></a>StringRequest的用法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">RequestQueue mQueue = Volley.newRequestQueue(context);</span><br><span class="line">StringRequest stringReuqest = <span class="keyword">new</span> StirngRequest(<span class="string">&quot;http://www.baidu.com&quot;</span>, <span class="keyword">new</span> Response.Listener&lt;String&gt;() &#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(String response)</span> </span>&#123;</span><br><span class="line">      Log.d(<span class="string">&quot;Tag&quot;</span>, response);</span><br><span class="line">   &#125;, <span class="keyword">new</span> Response.ErrorListener&lt;String&gt;()&#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onErrorResponse</span><span class="params">(String response)</span> </span>&#123;</span><br><span class="line">            Log.d(<span class="string">&quot;Tag&quot;</span>, response);</span><br><span class="line">         &#125;);</span><br><span class="line">mQueue.add(stringRequest);</span><br></pre></td></tr></table></figure>

<p>当然，Volley 需要用到网络，故应记得添加网络请求权限。</p>
<p>运行之后，在 logcat 中我们就可以看到一长串的 html 代码了。这就是百度返回给我们的结果。</p>
<p>默认的是发送 <code>get</code> 请求，但是我们如果要发送其他的请求，我们就要用到<code>StringRequest</code>类的构造方法的重载，如我们要发送 <code>post</code> 请求：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StringRequest stringRequest = <span class="keyword">new</span> StringRequest(Method.POST, url, listener, errorListener);</span><br></pre></td></tr></table></figure>
<p><code>post</code> 请求我们知道参数不能直接写在 url 中，那我们应该怎样发送参数呢？Easy! 看下面的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StringRequest stringRequest = <span class="keyword">new</span> StringRequest(Method.POST, url,  listener, errorListener) &#123;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">protected</span> Map&lt;String, String&gt;; getParams() <span class="keyword">throws</span> AuthFailureError &#123;  </span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;;();  </span><br><span class="line">        map.put(<span class="string">&quot;params1&quot;</span>, <span class="string">&quot;value1&quot;</span>);  </span><br><span class="line">        map.put(<span class="string">&quot;params2&quot;</span>, <span class="string">&quot;value2&quot;</span>);  </span><br><span class="line">        <span class="keyword">return</span> map;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们重写了 <code>StringRequest</code> 的方法中 <code>getParams</code> 方法，在这里我们构造参数表。</p>
<h2 id="JsonObjectRequest-amp-JsonArrayRequest的用法"><a href="#JsonObjectRequest-amp-JsonArrayRequest的用法" class="headerlink" title="JsonObjectRequest&amp;JsonArrayRequest的用法"></a>JsonObjectRequest&amp;JsonArrayRequest的用法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">JsonObjectRequest jsonObjectRequest = <span class="keyword">new</span></span><br><span class="line">JsonObjectRequest(<span class="string">&quot;http://m.weather.com.cn/data/101010100.html&quot;</span>, <span class="keyword">null</span>, <span class="keyword">new</span> Response.Listener&lt;JsonObject&gt;() &#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(JsonObject response)</span> </span>&#123;</span><br><span class="line">      Log.d(<span class="string">&quot;tag&quot;</span>, response.toString());</span><br><span class="line">   &#125;, <span class="keyword">new</span> Response.ErrorListener(JsonObject response) &#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onErrorResponse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            log.d(<span class="string">&quot;tag&quot;</span>, response.toString();</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;);</span><br></pre></td></tr></table></figure>
<p>然后将这个加入请求队列中:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mRequest.add(jsonObjectRequest);</span><br></pre></td></tr></table></figure>
<p><code>JsonArrrayRequest</code> 的用法类似。</p>
<h2 id="ImageRequest的用法"><a href="#ImageRequest的用法" class="headerlink" title="ImageRequest的用法"></a>ImageRequest的用法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ImageRequest imageRequest = <span class="keyword">new</span> ImageRequest(<span class="string">&quot;http://developer.android.com/images/home/aw_dac.png&quot;</span>, <span class="keyword">new</span> Response.Listener&lt;Bitmap&gt;() &#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Bitmap bitmap)</span> </span>&#123;</span><br><span class="line">      imageView.setImageBitmap(bitmap);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;, <span class="number">0</span>, <span class="number">0</span>, <span class="keyword">new</span> Response.ErrorListener() &#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onErrorResponse</span><span class="params">(VolleyError error)</span> </span>&#123;</span><br><span class="line">      imageView.setImageResource(R.drawable.default_image);  </span><br><span class="line">   &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>未完待续。。。</p>
]]></content>
      <tags>
        <tag>Android</tag>
        <tag>开源库</tag>
      </tags>
  </entry>
  <entry>
    <title>ViewPager 的使用</title>
    <url>/2016/04/16/2016-04-16-android-viewpager-usage/</url>
    <content><![CDATA[<h1 id="ViewPager"><a href="#ViewPager" class="headerlink" title="ViewPager"></a>ViewPager</h1><p>什么是 ViewPager？图告诉你一切：</p>
<table border="0px">
<tbody>
<tr>
<td><a href="/img/in-post/post_android_viewpager_usage/android_viewpager_usage_1.png" rel="attachment wp-att-123"><img class="alignnone wp-image-123" src="/img/in-post/post_android_viewpager_usage/android_viewpager_usage_1.png" alt="ViewPager" width="112" height="198" /></a></td>
<td><a href="/img/in-post/post_android_viewpager_usage/android_viewpager_usage_2.png" rel="attachment wp-att-127"><img class="alignnone wp-image-127" src="/img/in-post/post_android_viewpager_usage/android_viewpager_usage_2.png" alt="Screenshot_2016-04-04-17-00-18" width="114" height="203" /></a></td>
<td><a href="/img/in-post/post_android_viewpager_usage/android_viewpager_usage_3.png" rel="attachment wp-att-126"><img class="alignnone wp-image-126" src="/img/in-post/post_android_viewpager_usage/android_viewpager_usage_3.png" alt="Screenshot_2016-04-04-17-00-28" width="113" height="200" /></a></td>
<td><a href="/img/in-post/post_android_viewpager_usage/android_viewpager_usage_4.png" rel="attachment wp-att-128"><img class="alignnone wp-image-128" src="/img/in-post/post_android_viewpager_usage/android_viewpager_usage_4.png" alt="Screenshot_2016-04-04-16-59-21" width="112" height="199" /></a></td>
</tr>
</tbody>
</table>

<p>如图，白色矩形区域就是我们的 <code>ViewPager</code>，正如我们所熟悉的，<code>ViewPager</code> 通常会配合 <code>tab</code> 使用，什么是 <code>tab</code>？就是“网易新闻，网易体育，网易财经，网易女人”（page title) 这四个标题所在的那个区域，每个 page title 代表着一个 <code>tab</code> 。这个区域再上面一点就是 <code>ToolBar</code> 了。 <code>tab</code> 的实现方法有很多种，但现在最受欢迎并且最美观的就是谷歌MD提供的 <code>TabLayout</code> 了。现在我们主要讲下 <code>TabLayout</code> + <code>ViewPager</code> 的实现和使用吧。</p>
<span id="more"></span>

<h2 id="ViewPager-的使用"><a href="#ViewPager-的使用" class="headerlink" title="ViewPager 的使用"></a>ViewPager 的使用</h2><p><strong>布局文件</strong>：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">android.support.design.widget.TabLayout</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/tabs&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:tabIndicatorColor</span>=<span class="string">&quot;#ffffff&quot;</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">app:tabSelectedTextColor</span>=<span class="string">&quot;#ffffff&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:tabTextColor</span>=<span class="string">&quot;#aaffffff&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:tabBackground</span>=<span class="string">&quot;@drawable/tab_ripple&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">android.support.v4.view.ViewPager</span></span></span><br><span class="line"><span class="tag">      <span class="attr">android:id</span>=<span class="string">&quot;@+id/viewpager&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>这就是 <code>TabLayout</code> + <code>ViewPager</code> 的布局文件 <code>TabLayout</code> 在上，<code>ViewPager</code> 在下。</p>
<p><strong>java代码</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ViewPager pager = <span class="keyword">null</span>;</span><br><span class="line">TabLayout tabs = <span class="keyword">null</span>;</span><br><span class="line">ArrayList&lt;View&gt; viewContainer = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">ArrayList&lt;String&gt; titleContainer = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_main);</span><br><span class="line">    initView();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initView</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="comment">//其他布局初始化代码省略</span></span><br><span class="line">    pager = (ViewPager) findViewById(R.id.viewpager);</span><br><span class="line">    tabs = (TabLayout) findViewById(R.id.tabs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在代码中找到这两个控件之后，我们就要给他们添加数据了。总不能两个控件都是空内容吧。对于 <code>TabLayout</code> 来说，我们要给它添加的数据当然就是page title了；而对于 <code>ViewPager</code> 来说， <code>ViewPager</code> 是一个 <code>ViewGroup</code> 类，我们需要给他添加的数据就是添加四个子 <code>View</code>，这四个子<code>View</code>对应的就是我们的四个页面。怎么添加呢？继续看。</p>
<p>对于 <code>TabLayout</code>，我们可以将数据源放在一个 <code>ArrayList</code> 中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;String&gt; titleContainer = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">titleContainer.add(<span class="string">&quot;网易新闻&quot;</span>);</span><br><span class="line">titleContainer.add(<span class="string">&quot;网易体育&quot;</span>);</span><br><span class="line">titleContainer.add(<span class="string">&quot;网易财经&quot;</span>);</span><br><span class="line">titleContainer.add(<span class="string">&quot;网易女人&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>对于 <code>ViewPager</code>，我们同样将数据源放入一个 <code>ArrayList</code> 中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;View&gt; viewContainer = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">TextView view1,view2,view3,view4;</span><br><span class="line">(view1 = <span class="keyword">new</span> TextView(<span class="keyword">this</span>)).setText(<span class="string">&quot;页面一&quot;</span>);</span><br><span class="line">(view2 = <span class="keyword">new</span> TextView(<span class="keyword">this</span>)).setText(<span class="string">&quot;页面二&quot;</span>);</span><br><span class="line">(view3 = <span class="keyword">new</span> TextView(<span class="keyword">this</span>)).setText(<span class="string">&quot;页面三&quot;</span>);</span><br><span class="line">(view4 = <span class="keyword">new</span> TextView(<span class="keyword">this</span>)).setText(<span class="string">&quot;页面四&quot;</span>);</span><br><span class="line"></span><br><span class="line">viewContainer.add(view1);</span><br><span class="line">viewCOntainer.add(view2);</span><br><span class="line">viewContainer.add(view3);</span><br><span class="line">viewContainer.add(view4);</span><br></pre></td></tr></table></figure>

<p>这里我们给这个 <code>ViewPager</code> 添加的四个子 <code>View</code> 是四个 <code>TextView</code>;</p>
<p>好了数据源都准备好了，那么我们应该怎样将数据送到相应的控件中呢？对于 <code>TabLayout</code>，方法有两种，我们先讲一种比较容易理解的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(String title : titleContainer) &#123;</span><br><span class="line">   tabs.add(tabs.newTab().setText(title));  <span class="comment">//setText()的返回值是new出来的tab</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们得将 <code>viewContainer</code> 中的那四个 <code>view</code> 添加进 <code>ViewPager</code> 中，当然，不是我们手动的 <code>addView</code> 去添加，而是像那些包含 <code>itemView</code> 的 <code>AdapterView</code> 那样去设置 <code>Adapter</code>。适配器模式有很多好处，首先能够将视图展示和数据绑定分离，其次能够很好的管理子 <code>View</code>，如动态的添加移除，还可以设置动画，并且能够实现视图回收和重用，如果手动添加这些是很难做到的。</p>
<p>安卓提供了一个 <code>PagerAdapter</code> 来给 <code>ViewPager</code> 设置适配器，我们的子 <code>View</code> 就是通过这个适配器添加进 <code>ViewPager</code> 的：</p>
<p>新建一个 <code>PagerAdapter</code> 通常要重写和实现的方法有：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取页面的数量</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断某个子view是否和object关联，不理解这个方法没关系，官方推荐直接返回 view == object </span></span><br><span class="line"><span class="comment">//就可以了 </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isViewFromObject</span><span class="params">(View view, Object object)</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">//添加一个页面并返回关联这个页面的object,对应上面的我们只需这样做： </span></span><br><span class="line"><span class="comment">//return viewContainer.get(position),即把子View返回 </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">instantiateItem</span><span class="params">(ViewGroup container, <span class="keyword">int</span> position)</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁一个页面 </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroyItem</span><span class="params">(ViewGroup container, <span class="keyword">int</span> position, Object object)</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">//获取当前页面的page title，这个方法可以不重写，因为我们之前手动添加tab并且设置了 </span></span><br><span class="line"><span class="comment">//page title</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CharSequence <span class="title">getPageTitle</span><span class="params">(<span class="keyword">int</span> position）;</span></span></span><br></pre></td></tr></table></figure>

<p>一个典型的 <code>PagerAdapter</code> 可以这样写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">pager.setAdapter( <span class="keyword">new</span> PagerAdapter() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span>  viewContainer.size();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isViewFromObject</span><span class="params">(View view, Object object)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span>  view == object;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">instantiateItem</span><span class="params">(ViewGroup container, <span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">                View view;</span><br><span class="line">                container.addView(view = viewContainer.get(position));</span><br><span class="line">                <span class="keyword">return</span> view;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroyItem</span><span class="params">(ViewGroup container, <span class="keyword">int</span> position,  Object</span></span></span><br><span class="line"><span class="params"><span class="function">            object)</span> </span>&#123;                                         </span><br><span class="line">                container.removeView(viewContainer.get(position));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//可以不重写</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> CharSequence <span class="title">getPageTitle</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> titleContainer.get(position);</span><br><span class="line">            &#125;</span><br><span class="line">       &#125;);</span><br></pre></td></tr></table></figure>

<p>如果我们想要监听 <code>ViewPager</code> 页面滑动的事件，我们可以添加监听器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">pager.addOnPageChangeListener(<span class="keyword">new</span> ViewPager.OnPageChangeListener() &#123;</span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPageScrolled</span><span class="params">(<span class="keyword">int</span> position, <span class="keyword">float</span> positionOffset, <span class="keyword">int</span> positionOffsetPixels)</span> </span>&#123;</span><br><span class="line">             Log.d(<span class="string">&quot;onPageSrolled：&quot;</span>, <span class="string">&quot;我监听页面滚动事件&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPageSelected</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">              Log.d(<span class="string">&quot;onPageSelected: &quot;</span>, <span class="string">&quot;我监听页面选择事件&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPageScrollStateChanged</span><span class="params">(<span class="keyword">int</span> state)</span> </span>&#123;</span><br><span class="line">             Log.d(<span class="string">&quot;onPageSrollStateChanged: &quot;</span>, <span class="string">&quot;我监听页面滚动状态改变的事件&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>

<p>现在你肯定会问怎么将 <code>ViewPager</code> 和 <code>TabLayout</code> 关联起来呢？代码中两者之间没有任何关联，但我们通常看到的是指示条会跟着 <code>ViewPager</code> 页面的切换滚动到相应的 page title 下，而且当前页面对应的 page title 会更“亮”。对，这也就是我当时碰到的一个坑， 少写了这一步：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">pager.addOnPageChangeListener(<span class="keyword">new</span>   TabLayout.TabLayoutOnPagerChangeListener(tabs));</span><br></pre></td></tr></table></figure>

<p>有了这一步，<code>tabs</code> 就能够监听 <code>ViewPager</code> 切换的事件了，从而能够做出相应改变。</p>
<p>前面讲了，给 <code>TabLayout</code> 设置 page title 的方法有两种，其中一种是手动添加 ，那么现在就讲另一种方法：</p>
<p>这种方法是把 <code>TabLayout</code> 设置 page title 的的任务交给 <code>PagerAdapter</code> 来做，最后将 <code>TabLayout</code> 和 <code>ViewPager</code> 绑定，这样 <code>TabLayout</code> 就和 <code>PagerAdapter</code> 产生某种关联，从而 <code>TabLayout</code> 能够获取标题信息。具体的做法是这样的：</p>
<p>首先重写 <code>PagerAdapter</code> 中的 <code>getPageTitle()</code> 方法，因为我们没有手动添加 page title，而是交给 <code>PagerAdapter</code> 来处理，所以我们必须重写这个方法来获取 page title：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CharSequence <span class="title">getPageTitle</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> titleContainer.get(position);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之后，我们就要将 <code>TabLayout</code> 和 <code>ViewPager</code> 绑定：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">tabs.setupWithViewPager(pager);</span><br></pre></td></tr></table></figure>


<p>这样也能达到我们预期的效果了，而且我们连这一步：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">pager.addOnPageChangeListener(<span class="keyword">new</span>   TabLayout.TabLayoutOnPagerChangeListener(tabs));</span><br></pre></td></tr></table></figure>

<p>也不用写了，但是有一点要记住这个方法一定要是在 <code>ViewPager </code> 设置 <code>PagerAdapter</code> 之后调用，否则程序运行时会崩溃。</p>
<h2 id="可能出现的问题"><a href="#可能出现的问题" class="headerlink" title="可能出现的问题"></a>可能出现的问题</h2><p>如果你的手机是安卓5.0以上，你的页面可能会出现下图这种情况：</p>
<p><a href="/img/in-post/post_android_viewpager_usage/android_viewpager_usage_5.png" rel="attachment wp-att-123"><img class="alignnone wp-image-123" src="/img/in-post/post_android_viewpager_usage/android_viewpager_usage_5.png" alt="ViewPager" width="112" height="198" /></a></p>
<p>在 <code>ToolBar</code> 和 <code>TabLayout</code> 之间出现了一条阴影，这是因为 <code>Toolbar</code> 在安卓5.0以上默认 <code>elevation</code> 是不为零的，而 <code>TabLayout</code> 的高度为零，所以在 <code>TabLayout</code> 上造成了阴影，解决办法是将 <code>TabLayout</code> 放进 <code>AppBarLayout</code> 这个容器里，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;android.support.design.widget.AppBarLayout</span><br><span class="line">        android:layout_width=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">        android:layout_height=<span class="string">&quot;wrap_content&quot;</span></span><br><span class="line">        android:theme=<span class="string">&quot;@style/AppTheme.AppBarOverlay&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">        &lt;android.support.v7.widget.Toolbar</span><br><span class="line">            android:id=<span class="string">&quot;@+id/toolbar&quot;</span></span><br><span class="line">            android:layout_width=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">            android:layout_height=<span class="string">&quot;?attr/actionBarSize&quot;</span></span><br><span class="line">            android:background=<span class="string">&quot;?attr/colorPrimary&quot;</span></span><br><span class="line">            app:popupTheme=<span class="string">&quot;@style/AppTheme.PopupOverlay&quot;</span> /&gt;</span><br><span class="line"></span><br><span class="line">        &lt;android.support.design.widget.TabLayout</span><br><span class="line">            android:id=<span class="string">&quot;@+id/tabs&quot;</span></span><br><span class="line">            android:layout_width=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">            android:layout_height=<span class="string">&quot;wrap_content&quot;</span></span><br><span class="line">            app:tabIndicatorColor=<span class="string">&quot;#ffffff&quot;</span></span><br><span class="line">            app:tabSelectedTextColor=<span class="string">&quot;#ffffff&quot;</span></span><br><span class="line">            app:tabTextColor=<span class="string">&quot;#aaffffff&quot;</span></span><br><span class="line">            app:tabBackground=<span class="string">&quot;@drawable/tab_ripple&quot;</span>/&gt;</span><br><span class="line"></span><br><span class="line">&lt;/android.support.design.widget.AppBarLayout&gt;</span><br></pre></td></tr></table></figure>

<p>这样就不会出现那条难看的阴影了。</p>
]]></content>
      <tags>
        <tag>Android</tag>
        <tag>View</tag>
      </tags>
  </entry>
  <entry>
    <title>安卓事件传递机制的理解</title>
    <url>/2016/04/28/2016-04-28-android-event-dispatch/</url>
    <content><![CDATA[<h1 id="安卓事件传递机制的理解"><a href="#安卓事件传递机制的理解" class="headerlink" title="安卓事件传递机制的理解"></a>安卓事件传递机制的理解</h1><h2 id="事件产生的源头以及预处理"><a href="#事件产生的源头以及预处理" class="headerlink" title="事件产生的源头以及预处理"></a>事件产生的源头以及预处理</h2><p>当我们的手指点击（滑动）屏幕时，我们的手指就可能触发了一系列的事件，这些事件队列的排列顺序可以这样表示：{ <code>ACTION_DOWN</code>, <code>ACTION_MOVE</code>, <code>ACTION_MOVE</code>, <code>ACTION_MOVE</code>, … , <code>ACTION_UP</code> }，这样表示最开始我们触发的事件是<code>ACTION_DOWN</code>，然后是一至多个<code>ACTION_MOVE</code>事件（其实点击时也会触发<code>ACTION_MOVE</code>事件，因为屏幕很灵敏），当手指离开屏幕的瞬间，触发了一个 <code>ACTION_UP</code> 事件。</p>
<p>事件既然产生了，那怎么传递呢？</p>
<span id="more"></span>

<p>先别急，事件产生了，但还没获取呢。首先，消息获取模块会将事件通过pipe管道传递到客户端，然后 <code>InputQueue</code> 中的 <code>next()</code> 函数内部调用 <code>nativePollOnce()</code> 函数，该函数仅仅是一个 <code>DISPATCH_POINTER</code> 的异步消息，消息处理函数是 <code>deliverPointerEvent()</code> 函数。执行完该函数后，调用 <code>finishInputEvent()</code> 向消息获取模块发送一个回执，以使其进行下一个消息派送，真正完成绘制的代码是 native C++ 写的。</p>
<p>在 <code>deliverPointerEvent()</code> 中，会进行一些转换，包括物理像素到逻辑像素的转换和屏幕坐标到视图坐标的转换，这都是为消息的派发做好准备。</p>
<h2 id="事件的传递"><a href="#事件的传递" class="headerlink" title="事件的传递"></a>事件的传递</h2><p>执行了转换后，我们的事件即event便开始了漫长的旅途。</p>
<p>如果用一句话来概括event的漫长路途的话便是：</p>
<p><strong><code>deliverPointerEvent()</code> 通过执行 <code>mView.dispatchTouchEvent()</code> 将消息派发给根视图（这个根视图具体是谁我们等下在后面会提到），之后mView便会将事件派发到整个 <code>View</code> 树。</strong></p>
<p>太抽象笼统了是吧？那我们便来细细分析，你可以泡上一杯茶或咖啡，跟随 event 看看他在漫长旅途中发生的了那些有趣的事。</p>
<h3 id="事件在进入View树之前的传递"><a href="#事件在进入View树之前的传递" class="headerlink" title="事件在进入View树之前的传递"></a>事件在进入View树之前的传递</h3><p>前面说了 event 的第一站便是 <code>mView.dispatchTouchEvent()</code>，该函数是在<code>ViewRoot</code>（注意 <code>ViewRoot</code> 不是 <code>View</code> 类，而是继承 <code>Handle</code> 类，用于对整个视图数的控制）中调用的，<code>mView</code> 有两种类型，对于应用窗口来说，<code>mView</code> 是一个 <code>PhoneWindow</code> 的 <code>DecorView</code> 类型，对于非应用窗口而言，<code>mView</code> 是一般的 <code>ViewGroup</code> 类型。</p>
<p>在 <code>DecorView</code> 中，会判断是否存在 <code>Callback</code> 对象，这个 <code>Callback</code> 对象是谁呢？哈哈，竟然是 <code>Activity</code>，其实不奇怪，我们看源码就可以知道 <code>Activity</code> 实现了 <code>Window.Callback</code> 这个回调接口。如果不存在 <code>Callback</code> 对象的话，那么就直接调用 <code>DecorView</code> 父类 <code>ViewGroup</code> 中的 <code>dispatchTouchEvent()</code> 方法。</p>
<p>我们首先看如果存在 <code>Callback</code> 对象即 <code>Activity</code> 时，event是在 <code>Activity</code> 中经历了什么。</p>
<p>在 <code>Activity</code> 中，event 被传入了它的 <code>dispatchTouchEvent()</code> 方法：<br>如果 event 的消息类型是 <code>ACTION_DOWN</code>，那么就调用 <code>onUserInteraction()</code>，这个方法是个空方法，什么也不干，只是让应用程序一个处理消息的机会，应用如果想在消息传递的最初始阶段想做些什么的话，就可以在这个函数中实现；<br>然后这个方法中又会调用 <code>Activity</code> 关联的 <code>Window</code> 类对象的 <code>superDispatchTouchEvent()</code> 方法；<br>如果 <code>Window</code> 类没有消耗该消息，那么 <code>Activity</code> 就会调用自己的 <code>onTouchEvent()</code> 方法，该方法也默认什么都不做，留给应用程序实现。</p>
<p><code>Window</code> 类中在event身上又发生了什么呢，我们往下看：</p>
<p><code>Window</code> 类的 <code>superDispatchEvent()</code> 方法中，会调用 <code>mDecor</code> 的 <code>superDispatchTouchEvent()</code> 方法，这个方法又会调用 <code>super.dispatchTouchEvent()</code>，即调用自己父类的 <code>dispatchTouchEvent()</code> 方法。看到这里我们猛然回头发现这是到了 <code>DecorView</code> 中如果不存在 <code>Callback</code> 对象时要走的另一条支路。</p>
<p>为什么要这样做呢？很明显，这是让 event 在视图树中旅行之前给 <code>Activity</code> 一个处理它的机会。很明显，这一阶段虽然 event 已经进入 <code>View</code> 树的根视图中了，但是主要还是在 <code>Activity</code> 中被处理，所以还是把这阶段归结为在 <code>Activity</code> 中的传递</p>
<p>之后开始才是 event 真正在视图树中的旅途了，它进入了视图树这个庞大的王国之中，各种有趣的事即将发生。</p>
<h3 id="事件在View树中的传递"><a href="#事件在View树中的传递" class="headerlink" title="事件在View树中的传递"></a>事件在View树中的传递</h3><p>我们知道 <code>DecorView</code> 是一个 <code>ViewGroup</code>，所以我们从 <code>ViewGroup</code> 分析。</p>
<p>event 进入 <code>ViewGroup</code> 后，<code>ViewGroup</code> 便通过 <code>dispatchTouchEvent()</code> 方法将它派送，它先会被派送到 <code>onInterceptTouchEvent()</code> 中（决定是否将其拦截），这个方法的意思是拦截，在 <code>ViewGroup</code> 中，它的默认实现是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onInterceptTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">   retrun <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是不拦截意思。</p>
<p>关于这个方法官方文档有段很长的话（本来想翻译的，但是想想怕翻译得不好坏了原本的意思），大家还是自己翻译看看</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * Implement this method to intercept all touch screen motion events.  This </span></span><br><span class="line"><span class="comment"> * allows you to watch events as they are dispatched to your children, and </span></span><br><span class="line"><span class="comment"> * take ownership of the current gesture at any point. </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Using this function takes some care, as it has a fairly complicated </span></span><br><span class="line"><span class="comment"> * interaction with &#123;<span class="doctag">@link</span> View#onTouchEvent(MotionEvent) </span></span><br><span class="line"><span class="comment"> * View.onTouchEvent(MotionEvent)&#125;, and using it requires implementing </span></span><br><span class="line"><span class="comment"> * that method as well as this one in the correct way.  Events will be </span></span><br><span class="line"><span class="comment"> * received in the following order: </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * &lt;ol&gt; </span></span><br><span class="line"><span class="comment"> * &lt;li&gt; You will receive the down event here. </span></span><br><span class="line"><span class="comment"> * &lt;li&gt; The down event will be handled either by a child of this view </span></span><br><span class="line"><span class="comment"> * group, or given to your own onTouchEvent() method to handle; this means </span></span><br><span class="line"><span class="comment"> * you should implement onTouchEvent() to return true, so you will </span></span><br><span class="line"><span class="comment"> * continue to see the rest of the gesture (instead of looking for </span></span><br><span class="line"><span class="comment"> * a parent view to handle it).  Also, by returning true from </span></span><br><span class="line"><span class="comment"> * onTouchEvent(), you will not receive any following </span></span><br><span class="line"><span class="comment"> * events in onInterceptTouchEvent() and all touch processing must </span></span><br><span class="line"><span class="comment"> * happen in onTouchEvent() like normal. </span></span><br><span class="line"><span class="comment"> * &lt;li&gt; For as long as you return false from this function, each following </span></span><br><span class="line"><span class="comment"> * event (up to and including the final up) will be delivered first here </span></span><br><span class="line"><span class="comment"> * and then to the target&#x27;s onTouchEvent(). </span></span><br><span class="line"><span class="comment"> * &lt;li&gt; If you return true from here, you will not receive any </span></span><br><span class="line"><span class="comment"> * following events: the target view will receive the same event but </span></span><br><span class="line"><span class="comment"> * with the action &#123;<span class="doctag">@link</span> MotionEvent#ACTION_CANCEL&#125;, and all further </span></span><br><span class="line"><span class="comment"> * events will be delivered to your onTouchEvent() method and no longer </span></span><br><span class="line"><span class="comment"> * appear here. </span></span><br><span class="line"><span class="comment"> * &lt;/ol&gt; </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> ev The motion event being dispatched down the hierarchy. </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> Return true to steal motion events from the children and have </span></span><br><span class="line"><span class="comment"> * them dispatched to this ViewGroup through onTouchEvent(). </span></span><br><span class="line"><span class="comment"> * The current target will receive an ACTION_CANCEL event, and no further </span></span><br><span class="line"><span class="comment"> * messages will be delivered here. </span></span><br><span class="line"><span class="comment"> */</span>  </span><br></pre></td></tr></table></figure>

<p>而 <code>ViewGroup</code> 中的 <code>dispatchTouchEvent()</code> 的源码是这样的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> action = ev.getAction();  </span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> xf = ev.getX();  </span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> yf = ev.getY();  </span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> scrolledXFloat = xf + mScrollX;  </span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> scrolledYFloat = yf + mScrollY;  </span><br><span class="line">    <span class="keyword">final</span> Rect frame = mTempRect;  </span><br><span class="line">    <span class="keyword">boolean</span> disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">if</span> (action == MotionEvent.ACTION_DOWN) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (mMotionTarget != <span class="keyword">null</span>) &#123;  </span><br><span class="line">            mMotionTarget = <span class="keyword">null</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span> (disallowIntercept || !onInterceptTouchEvent(ev)) &#123;  </span><br><span class="line">            ev.setAction(MotionEvent.ACTION_DOWN);  </span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> scrolledXInt = (<span class="keyword">int</span>) scrolledXFloat;  </span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> scrolledYInt = (<span class="keyword">int</span>) scrolledYFloat;  </span><br><span class="line">            <span class="keyword">final</span> View[] children = mChildren;  </span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> count = mChildrenCount;  </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = count - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;  </span><br><span class="line">                <span class="keyword">final</span> View child = children[i];  </span><br><span class="line">                <span class="keyword">if</span> ((child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE  </span><br><span class="line">                        || child.getAnimation() != <span class="keyword">null</span>) &#123;  </span><br><span class="line">                    child.getHitRect(frame);  </span><br><span class="line">                    <span class="keyword">if</span> (frame.contains(scrolledXInt, scrolledYInt)) &#123;  </span><br><span class="line">                        <span class="keyword">final</span> <span class="keyword">float</span> xc = scrolledXFloat - child.mLeft;  </span><br><span class="line">                        <span class="keyword">final</span> <span class="keyword">float</span> yc = scrolledYFloat - child.mTop;  </span><br><span class="line">                        ev.setLocation(xc, yc);  </span><br><span class="line">                        child.mPrivateFlags &amp;= ~CANCEL_NEXT_UP_EVENT;  </span><br><span class="line">                        <span class="keyword">if</span> (child.dispatchTouchEvent(ev))  &#123;  </span><br><span class="line">                            mMotionTarget = child;  </span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">true</span>;  </span><br><span class="line">                        &#125;  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">boolean</span> isUpOrCancel = (action == MotionEvent.ACTION_UP) ||  </span><br><span class="line">            (action == MotionEvent.ACTION_CANCEL);  </span><br><span class="line">    <span class="keyword">if</span> (isUpOrCancel) &#123;  </span><br><span class="line">        mGroupFlags &amp;= ~FLAG_DISALLOW_INTERCEPT;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">final</span> View target = mMotionTarget;  </span><br><span class="line">    <span class="keyword">if</span> (target == <span class="keyword">null</span>) &#123;  </span><br><span class="line">        ev.setLocation(xf, yf);  </span><br><span class="line">        <span class="keyword">if</span> ((mPrivateFlags &amp; CANCEL_NEXT_UP_EVENT) != <span class="number">0</span>) &#123;  </span><br><span class="line">            ev.setAction(MotionEvent.ACTION_CANCEL);  </span><br><span class="line">            mPrivateFlags &amp;= ~CANCEL_NEXT_UP_EVENT;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.dispatchTouchEvent(ev);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span> (!disallowIntercept &amp;&amp; onInterceptTouchEvent(ev)) &#123;  </span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">float</span> xc = scrolledXFloat - (<span class="keyword">float</span>) target.mLeft;  </span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">float</span> yc = scrolledYFloat - (<span class="keyword">float</span>) target.mTop;  </span><br><span class="line">        mPrivateFlags &amp;= ~CANCEL_NEXT_UP_EVENT;  </span><br><span class="line">        ev.setAction(MotionEvent.ACTION_CANCEL);  </span><br><span class="line">        ev.setLocation(xc, yc);  </span><br><span class="line">        <span class="keyword">if</span> (!target.dispatchTouchEvent(ev)) &#123;  </span><br><span class="line">        &#125;  </span><br><span class="line">        mMotionTarget = <span class="keyword">null</span>;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span> (isUpOrCancel) &#123;  </span><br><span class="line">        mMotionTarget = <span class="keyword">null</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> xc = scrolledXFloat - (<span class="keyword">float</span>) target.mLeft;  </span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> yc = scrolledYFloat - (<span class="keyword">float</span>) target.mTop;  </span><br><span class="line">    ev.setLocation(xc, yc);  </span><br><span class="line">    <span class="keyword">if</span> ((target.mPrivateFlags &amp; CANCEL_NEXT_UP_EVENT) != <span class="number">0</span>) &#123;  </span><br><span class="line">        ev.setAction(MotionEvent.ACTION_CANCEL);  </span><br><span class="line">        target.mPrivateFlags &amp;= ~CANCEL_NEXT_UP_EVENT;  </span><br><span class="line">        mMotionTarget = <span class="keyword">null</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> target.dispatchTouchEvent(ev);  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>结合官方文档和源码我解释一下：</p>
<p><strong>1.</strong> 如果 <code>disallowIntercept</code> 为 <code>false</code> （默认是 <code>false</code>，子视图通过 <code>requestDisallowInterceptTouchEvent(true)</code> 可不允许父视图拦截消息），并且 <code>onInterceptTouchEvent()</code> 返回 <code>true</code>，那么 <code>ViewGroup</code> 就会拦截事件，事件不会给子视图处理，而是交由自己父类的 <code>dispatchTouchEvent()</code> 来处理，即 <code>View</code> 的 <code>diapatchTouchEvent()</code> 来处理，这也就相当与ViewGroup将事件交给了自己来处理。<code>View</code> 的 <code>dispatchTouchEvent()</code> 长什么样呢？我们看看源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (mOnTouchListener != <span class="keyword">null</span> &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp;  </span><br><span class="line">            mOnTouchListener.onTouch(<span class="keyword">this</span>, event)) &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> onTouchEvent(event);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>安卓5.0之后该方法的实现略带复杂，但是基本思想还是一样的，我们不妨就拿这个简单的来分析。在这个方法中会判断这个 <code>View</code> 的 <code>OnTouchListener</code> 回调接口是否存在，<code>View</code> 是不是 <code>ENABLE</code> 状态，是的话就会继续执行到第三个条件，第三个条件其实执行了 <code>OnTouchListener</code> 的 <code>onTouch()</code> 方法，这个方法是我们调用 <code>view.setOnTouchListener()</code> 时实现的。如果这个方法返回了 true， 那么 <code>dispatchEvent()</code> 方法也返回 <code>true</code>，<code>dispatchEvent()</code> 方法执行完毕；如果回调接口不存在，或者这个 <code>View</code> 是 <code>DISABLE</code> 状态，或者 <code>onTouch()</code> 返回 <code>false</code>（即 <code>onTouch()</code> 未消耗该 event）时， 便会执行 <code>onTouchEvent()</code> 方法。如果 <code>onTouchEvent()</code> 返回 <code>false</code> （即这个方法也未消耗 event)时，<code>dispatchTouchEvent()</code> 返回 <code>false</code>，从而表明 <code>View</code> 未消耗这个事件；反之 <code>onTouchEvent()</code> 返回 <code>true</code> 即消耗了这个事件时，<code>dispatchTouchEvent()</code> 也返回 <code>true</code>，表明 <code>View</code> 消耗了该事件。</p>
<p>从上面的分析，我们可以看出，一个 event 在 <code>View</code> 中，首先会被 <code>dispatchTouchEvent()</code> 派发给 <code>onTouch()</code> 处理（前提是注册了 <code>onTouch()</code> 事件），如果 <code>onTouch()</code> 返回 <code>true</code>（消耗了该 event），event 在 <code>View</code> 中的旅程就结束了，<code>dispatchTouchEvent()</code>返回 <code>true</code>；如果没消耗就会继续派发给  <code>onTouchEvent()</code> 来处理，<code>dispatchTouchEvent()</code> 会将 <code>onTouchEvent()</code> 的返回值作为自己的返回值。</p>
<p>接下来我们自然想知道，event 在 <code>onTouchEvent()</code> 方法中会发生什么呢，我们看看源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> viewFlags = mViewFlags;  </span><br><span class="line">    <span class="keyword">if</span> ((viewFlags &amp; ENABLED_MASK) == DISABLED) &#123;  </span><br><span class="line">        <span class="comment">// A disabled view that is clickable still consumes the touch  </span></span><br><span class="line">        <span class="comment">// events, it just doesn&#x27;t respond to them.  </span></span><br><span class="line">        <span class="keyword">return</span> (((viewFlags &amp; CLICKABLE) == CLICKABLE ||  </span><br><span class="line">                (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE));  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span> (mTouchDelegate != <span class="keyword">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (mTouchDelegate.onTouchEvent(event)) &#123;  </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span> (((viewFlags &amp; CLICKABLE) == CLICKABLE ||  </span><br><span class="line">            (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)) &#123;  </span><br><span class="line">        <span class="keyword">switch</span> (event.getAction()) &#123;  </span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_UP:  </span><br><span class="line">                <span class="keyword">boolean</span> prepressed = (mPrivateFlags &amp; PREPRESSED) != <span class="number">0</span>;  </span><br><span class="line">                <span class="keyword">if</span> ((mPrivateFlags &amp; PRESSED) != <span class="number">0</span> || prepressed) &#123;  </span><br><span class="line">                    <span class="comment">// take focus if we don&#x27;t have it already and we should in  </span></span><br><span class="line">                    <span class="comment">// touch mode.  </span></span><br><span class="line">                    <span class="keyword">boolean</span> focusTaken = <span class="keyword">false</span>;  </span><br><span class="line">                    <span class="keyword">if</span> (isFocusable() &amp;&amp; isFocusableInTouchMode() &amp;&amp; !isFocused()) &#123;  </span><br><span class="line">                        focusTaken = requestFocus();  </span><br><span class="line">                    &#125;  </span><br><span class="line">                    <span class="keyword">if</span> (!mHasPerformedLongPress) &#123;  </span><br><span class="line">                        <span class="comment">// This is a tap, so remove the longpress check  </span></span><br><span class="line">                        removeLongPressCallback();  </span><br><span class="line">                        <span class="comment">// Only perform take click actions if we were in the pressed state  </span></span><br><span class="line">                        <span class="keyword">if</span> (!focusTaken) &#123;  </span><br><span class="line">                            <span class="comment">// Use a Runnable and post this rather than calling  </span></span><br><span class="line">                            <span class="comment">// performClick directly. This lets other visual  </span></span><br><span class="line">                            <span class="comment">// state of the view update before click actions start.  </span></span><br><span class="line">                            <span class="keyword">if</span> (mPerformClick == <span class="keyword">null</span>) &#123;  </span><br><span class="line">                                mPerformClick = <span class="keyword">new</span> PerformClick();  </span><br><span class="line">                            &#125;  </span><br><span class="line">                            <span class="keyword">if</span> (!post(mPerformClick)) &#123;  </span><br><span class="line">                                performClick();  </span><br><span class="line">                            &#125;  </span><br><span class="line">                        &#125;  </span><br><span class="line">                    &#125;  </span><br><span class="line">                    <span class="keyword">if</span> (mUnsetPressedState == <span class="keyword">null</span>) &#123;  </span><br><span class="line">                        mUnsetPressedState = <span class="keyword">new</span> UnsetPressedState();  </span><br><span class="line">                    &#125;  </span><br><span class="line">                    <span class="keyword">if</span> (prepressed) &#123;  </span><br><span class="line">                        mPrivateFlags |= PRESSED;  </span><br><span class="line">                        refreshDrawableState();  </span><br><span class="line">                        postDelayed(mUnsetPressedState,  </span><br><span class="line">                                ViewConfiguration.getPressedStateDuration());  </span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!post(mUnsetPressedState)) &#123;  </span><br><span class="line">                        <span class="comment">// If the post failed, unpress right now  </span></span><br><span class="line">                        mUnsetPressedState.run();  </span><br><span class="line">                    &#125;  </span><br><span class="line">                    removeTapCallback();  </span><br><span class="line">                &#125;  </span><br><span class="line">                <span class="keyword">break</span>;  </span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_DOWN:  </span><br><span class="line">                <span class="keyword">if</span> (mPendingCheckForTap == <span class="keyword">null</span>) &#123;  </span><br><span class="line">                    mPendingCheckForTap = <span class="keyword">new</span> CheckForTap();  </span><br><span class="line">                &#125;  </span><br><span class="line">                mPrivateFlags |= PREPRESSED;  </span><br><span class="line">                mHasPerformedLongPress = <span class="keyword">false</span>;  </span><br><span class="line">                postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout());  </span><br><span class="line">                <span class="keyword">break</span>;  </span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_CANCEL:  </span><br><span class="line">                mPrivateFlags &amp;= ~PRESSED;  </span><br><span class="line">                refreshDrawableState();  </span><br><span class="line">                removeTapCallback();  </span><br><span class="line">                <span class="keyword">break</span>;  </span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_MOVE:  </span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> x = (<span class="keyword">int</span>) event.getX();  </span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> y = (<span class="keyword">int</span>) event.getY();  </span><br><span class="line">                <span class="comment">// Be lenient about moving outside of buttons  </span></span><br><span class="line">                <span class="keyword">int</span> slop = mTouchSlop;  </span><br><span class="line">                <span class="keyword">if</span> ((x &lt; <span class="number">0</span> - slop) || (x &gt;= getWidth() + slop) ||  </span><br><span class="line">                        (y &lt; <span class="number">0</span> - slop) || (y &gt;= getHeight() + slop)) &#123;  </span><br><span class="line">                    <span class="comment">// Outside button  </span></span><br><span class="line">                    removeTapCallback();  </span><br><span class="line">                    <span class="keyword">if</span> ((mPrivateFlags &amp; PRESSED) != <span class="number">0</span>) &#123;  </span><br><span class="line">                        <span class="comment">// Remove any future long press/tap checks  </span></span><br><span class="line">                        removeLongPressCallback();  </span><br><span class="line">                        <span class="comment">// Need to switch from pressed to not pressed  </span></span><br><span class="line">                        mPrivateFlags &amp;= ~PRESSED;  </span><br><span class="line">                        refreshDrawableState();  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">                <span class="keyword">break</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>在 <code>onTouchEvent()</code> 方法中我们看到，如果这个 <code>View</code> 是可点击的，那么对于 <code>ACTOIN_UP</code> 事件，我们就发送一个异步消息来处理点击事件，如果异步消息没有发送成功，那么就会立即执行点击事件，在源码中也就是 <code>performClick()</code> 方法，<code>performClick()</code> 方法是怎样的呢，如果你看了源码就知道则个方法里执行的是我们 <code>View</code> 注册点击事件，即 <code>OnClickListener的onClick()</code> 方法。当然 <code>ACTOIN_UP</code> 有还有可能会触发长按事件 <code>onLongClick()</code>，这里就不详细介绍了。</p>
<p><strong>2.</strong> 如果 <code>disallowIntercept</code> 为 <code>false</code> 并且 <code>ViewGroup</code> 没有拦截 event（即返回 <code>false</code> ），或者 <code>disallowIntercept</code> 为 <code>true</code>，那么事件就会传给 <code>ViewGroup</code> 中被点击的那个子视图（这里包括前面所讲的子/父视图都包括 <code>View</code> 和 <code>ViewGroup</code>），这样就回到了事件在 <code>View</code> 或者 <code>ViewGroup</code> 的传递过程了，我们就可以按照前面的分析用递归思想理解后续的过程。</p>
<p>需要注意的是，在 <code>ViewGroup</code> 的 <code>dispatchTouchEvent()</code> 方法中，我们能够知道，如果当事件  <code>ACTION_DOWN</code> 没有找到目标子视图（可能原因是没有点击到任何子视图或者虽然有子视图被点击但是该子视图没有消耗该事件，即子视图的 <code>dispatchTouchEvent()</code> 方法返回 <code>false</code>）时，<code>ViewGroup</code> 会将事件交给自己处理，并且之后的 <code>ACTION_MOVE</code> 和 <code>ACTION_UP</code> 事件都不会交给任何子视图处理，也是全交给自己处理，也即前面讲的交给 <code>super.dispatchTouchEvent()</code> 来处理。</p>
<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p><strong>1. 一个视图是否消耗该事件，表现在 <code>dispatchTouchEvent()</code> 的返回值上，如返回 <code>true</code> 表示消耗 <code>false</code> 表示未消耗；而一个消息处理方法（指的是 <code>ouTouch()</code> 和 <code>onEventTouch()</code>，不包括  <code>onInterceptTouchEvent()</code>)是否消耗该事件表现在该方法的返回值上，例如 <code>onTouch()</code> 方法返回 <code>true</code> 表示消耗 <code>false</code> 表示未消耗。</strong></p>
<p><strong>2. 如果某个视图的某个消息处理方法消耗该事件，会使得该视图的 <code>dispatchTouchEvent()</code> 方法返回 <code>true</code>，即该视图消耗了该事件；如果某个视图的所有消息处理方法都返回 <code>false</code>，那么这个视图的 <code>dispatchTouchEvent()</code> 方法返回 <code>false</code>，即该视图没有消耗该事件。</strong></p>
<p>到了这里安卓事件的传递就应该结束了，但我在这之中省略了对 <code>ViewGroup</code> 是如何找到被点击的子视图的的分析，这个我会在之后分享。以上便是我对安卓 <code>View</code> 的事件传递机制的理解，有什么疏漏或者错误的地方欢迎大家指出。</p>
<p>参考文章：<br/><br><a href="http://blog.csdn.net/guolin_blog/article/details/9097463" title="郭霖的博客">http://blog.csdn.net/guolin_blog/article/details/9097463</a>、<a href="http://blog.csdn.net/guolin_blog/article/details/9153761" title="郭霖的博客">http://blog.csdn.net/guolin_blog/article/details/9153761</a></p>
<p>参考书籍：《Android 内核剖析》柯元旦 著</p>
]]></content>
      <tags>
        <tag>Android</tag>
        <tag>View</tag>
      </tags>
  </entry>
  <entry>
    <title>浅析 hashcode() 和 equals()</title>
    <url>/2016/05/03/2016-05-03-java-hashcode-and-equals/</url>
    <content><![CDATA[<h1 id="浅析-hashcode-和-equals"><a href="#浅析-hashcode-和-equals" class="headerlink" title="浅析 hashcode() 和 equals()"></a>浅析 hashcode() 和 equals()</h1><p>在 Java 中，<code>equals()</code> 的默认实现的是判断两个引用变量是否指向同一内存空间，即这两个引用变量是否是对同一实例的引用。而 <code>hashcode()</code> 默认实现与 <code>native</code> 方法相关，我的猜测是和这两个引用所指对象的内存地址有关，事实上的确是这样。为什么我的猜测会是正确的呢？我们来分析原因。</p>
<span id="more"></span>

<p>Java 文档对子类重写这两个方法的要求是：</p>
<ol>
<li>要么两个方法都重写，要么都不重写；</li>
<li>如果两个对象的通过 <code>equals</code> 方法比较返回 <code>true</code>，那么这两个方法的 <code>hashcode</code> 必须相等；  </li>
<li>如果这两个对象的 <code>hashcode</code> 相等，这两个对象不一定 <code>equals</code> 比较后返回 <code>true</code>。</li>
</ol>
<p>看看 <code>String</code> 的 <code>hashcode()</code> 方法和 <code>equals()</code> 方法：</p>
<ul>
<li>hashcode() :</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> hash = hashCode;</span><br><span class="line">        <span class="keyword">if</span> (hash == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">                hash = <span class="number">31</span> * hash + charAt(i);</span><br><span class="line">            &#125;</span><br><span class="line">            hashCode = hash;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>equals()：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object other)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (other == <span class="keyword">this</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (other <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">            String s = (String)other;</span><br><span class="line">            <span class="keyword">int</span> count = <span class="keyword">this</span>.count;</span><br><span class="line">            <span class="keyword">if</span> (s.count != count) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (hashCode() != s.hashCode()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (charAt(i) != s.charAt(i)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于 <code>String</code>， 我们可以看到：</p>
<ul>
<li><code>equals()</code> 方法的 “关键变量”（比较的依据）是字符串中的每个字符。但是为了程序效率，这个方法一开始并不会逐个比较两个字符串的字符，而是先比较它们长度是否相等，再看它们的 <code>hashcode()</code> 是否相等（按照规范，如果两个对象相等，它们的 <code>hashcode()</code> 一定相等），最后才出 “杀手锏”，逐个地比较它们的字符。</li>
<li><code>hashcode()</code> 方法返回的是对每个字符的 ascii 码进行加权求和。</li>
</ul>
<p>从文档的规范和 <code>String</code> 中两个方法的实现我们可以暂时可以推导出这样的结论：<code>hashcode()</code> 方法的返回值一定是通过对 <code>equals()</code> 中的关键变量进行某种函数变换得到的（简单点说就是和关键变量有关），只有这样才能保证 <strong>equals() 返回 ture</strong> =&gt; <strong>关键变量相等</strong> =&gt; <strong>hashcode() 返回值相等</strong>。</p>
<p>对于我们自定义的类，如果要重写这两个方法，应该首先重写 <code>equals()</code>。因为根据第二点要求，<code>hashcode()</code> 方法的实现应该是建立在 <code>equals()</code> 方法之上的：在重写 <code>equals()</code> 方法之后，我们再去保证对于 <code>euqals()</code> 比较返回 <code>true</code> 的两个对象，如何让它们的 <code>hashcode()</code> 返回值相等。</p>
<p>例如，定义一个 <code>People</code> 类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String hometown;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果有这样的定义：对于 <code>People</code> 的两个对象 <code>a</code> 和 <code>b</code>，如果它们的 <code>name</code> 相等我们就认为这两个对象相等。那么 <code>People</code> 的 <code>equals()</code> 方法就应该是这样实现的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object other)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (！other <span class="keyword">instanceof</span> People)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(hashcode() != other.hashcode())</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> name == <span class="keyword">null</span> ? other.name == <span class="keyword">null</span> : name.equals(other.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>equals()</code> 的 “关键变量” 是 <code>name</code>，所以 <code>hashcode()</code> 的返回值必须是通过对 <code>name</code> 的某种函数变换得到的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashcode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 在 String 中，hashcode() 返回值就是通过对字符串的函数变换得到的，</span></span><br><span class="line">     <span class="comment">// 因此这里直接返回 name 的 hashcode 也能保证 People 的 hashcode() 返回值是</span></span><br><span class="line">     <span class="comment">// 通过对 name 的函数变换得到的</span></span><br><span class="line">     <span class="keyword">return</span> name.hashcode();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>按照上面的实现，我们可以保证，如果 <code>a.equals(b) == true</code>，一定有 <code>a.hashcode() == b.hashcode()</code>。</p>
<p>如果我们按照下面这样实现 <code>hashcode()</code> 会怎样呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashcode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> hometown.hashcode();</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>在上面的实现中，<code>hashcode()</code> 的返回值并不和 “关键变量” 有关，我们看看这会导致什么问题：假如有两个人 <code>name</code> 相等，<code>hometown</code> 不相等，那么它们通过 <code>equals()</code> 比较会返回 <code>true</code>，但是由于 <code>hometown</code> 的不相等会直接导致它们 <code>hometown.hashcode()</code> 的返回值不相等，进而导致它们自己的 <code>hashcode()</code> 返回值不相等，这显然违背了 java 的规范。</p>
<p>现在考虑判断两个人相等另一种定义：如果两个 <code>People</code> 对象的 <code>name</code> 和 <code>hometown</code> 都相同，那么它们相等。</p>
<p>那么对于 <code>equals()</code> 方法来说，中规中矩的实现是这样的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object other)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (! other <span class="keyword">instanceof</span> People)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> (name == <span class="keyword">null</span> ? </span><br><span class="line">               other.name == <span class="keyword">null</span> : name.equals(other.name))</span><br><span class="line">        &amp;&amp; (hometown == <span class="keyword">null</span> ?</span><br><span class="line">               other.hometown == <span class="keyword">null</span> : hometown.equals(other.hometown));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而对于 <code>hashcode()</code> 方法来说，就可以这样实现（不是最好的做法，但是符合 java 规范）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashcode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> name.hashcode() + hometown.hashcode();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面的实现也是可以的（同样不建议这样做）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashcode</span><span class="params">()</span>  </span>&#123;</span><br><span class="line">   <span class="comment">// 返回值只与其中的一个关键变量有关，</span></span><br><span class="line">   <span class="comment">// 虽然这样容易导致 hashcode 的聚集，但是理论上也符合 java 的规范</span></span><br><span class="line">   <span class="keyword">return</span> name.hashcode() ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者（推荐的做法）:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashcode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">17</span>; <span class="comment">// 任意的起始值</span></span><br><span class="line">    k = k * <span class="number">31</span> + name.hashcode();</span><br><span class="line">    k = k * <span class="number">31</span> + hometown.hashcode();</span><br><span class="line">    <span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是这样就绝对是错误的（与无关变量 <code>age</code> 有关）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashcode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> homtown.hashcode() + age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于上面这种实现，虽然保证了和关键变量 <code>hometown</code> 有关，但是却引入 <code>age</code> 这个非关键变量（无关变量），我们看看这样做有什么问题：有两个 <code>People</code> 对象，它们的 <code>name</code> 和 <code>hometown</code> 相同，但 <code>age</code> 不相等，那么它们通过 <code>equals()</code> 比较会返回 <code>true</code>， 但它们 <code>hashcode()</code> 的返回值却不相等，因为 <code>age</code> 的不相等导致 <code>hometown.hashcode() + age</code> 不相等，进而导致了这两个对象 <code>hashcode()</code> 的返回值不相等。</p>
<p>因此对于开头的结论，我们还需要进行完善：<code>hashcode()</code> 方法的返回值一定是通过对 <code>equals()</code> 中的关键变量进行某种函数变换得到的（简单点说就是和关键变量有关），并且不能和非关键变量（无关变量，即 <code>equals()</code> 方法中用不到的变量）有关。</p>
<p>现在回到开头的问题：为什么 <code>hashcode()</code> 方法的默认实现与地址相关？因为在 <code>equals()</code> 的默认实现中，关键变量是两个引用变量所指向的内存地址，因此 <code>hashcode()</code> 方法返回值必须和对象的内存地址有关。</p>
<h2 id="感谢阅读"><a href="#感谢阅读" class="headerlink" title="感谢阅读"></a>感谢阅读</h2><p>由于只是说明 <code>hashcode()</code> 和 <code>equals()</code> 的内在联系，因此文章中有的例子并是 <code>hashcode()</code> 和 <code>equals()</code> 的最佳实现（但还是满足 java 规范，对于最佳实现可以参考 《Effective Java》 这本书）。另外如果有什么不对的话，还望大家不吝赐教。</p>
<p>参考书籍：《Effective Java》</p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>RxJava 原理探究</title>
    <url>/2016/09/03/2016-09-04-rxjava/</url>
    <content><![CDATA[<h1 id="RxJava-原理探究"><a href="#RxJava-原理探究" class="headerlink" title="RxJava 原理探究"></a>RxJava 原理探究</h1><p>关于 RxJava 的文章网上有很多，这里只是个人的学习总结，阅读前需要对 RxJava 有一定的了解，并不能作为学习资料，如果想要入门这里有更好的选择：<a href="https://gank.io/post/560e15be2dca930e00da1083">给 Android 开发者的 RxJava 详解</a>（虽然版本有点久，很多 API 都已过时，但原理差不多，不影响理解）。</p>
<span id="more"></span>

<p>如果只是想了解 API 的使用，可以看看 <a href="https://mcxiaoke.gitbooks.io/rxdocs/content/">ReactiveX/RxJava文档中文版</a>。</p>
<h2 id="什么是-RxJava"><a href="#什么是-RxJava" class="headerlink" title="什么是 RxJava"></a>什么是 RxJava</h2><blockquote>
<p>RxJava is a Java VM implementation of ReactiveX (Reactive Extensions): a library for composing asynchronous and event-based programs by using observable sequences.</p>
</blockquote>
<p>翻译一下就是：RxJava 是响应式扩展库在 Java 虚拟机上的实现，它使用观察者模式为异步和基于事件程序的编写提供便利。</p>
<h2 id="为什么是-RxJava"><a href="#为什么是-RxJava" class="headerlink" title="为什么是 RxJava"></a>为什么是 RxJava</h2><p>关于 RxJava 的优点网上总结了很多，总的说来就是使得代码整洁、逻辑清晰。它能将本来一段逻辑复杂、外观参差错落的代码，变成一条逻辑清晰的长链，使得可阅读性和可维护性大大提高。</p>
<p>以下例子改编自《给 Android 开发者的 RxJava 详解》：</p>
<blockquote>
<p>界面上有一个自定义的视图 imageCollectorView ，它的作用是显示多张图片，并能使用 addImage(Bitmap) 方法来任意增加显示的图片。现在需要程序将一个给出的目录数组 File[] folders 中每个目录下的 png 图片都加载出来并显示在 imageCollectorView 中。需要注意的是，由于读取图片的这一过程较为耗时，需要放在后台执行，而图片的显示则必须在 UI 线程执行。常用的实现方式有多种，我这里贴出其中一种：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.run();</span><br><span class="line">        <span class="keyword">for</span> (File folder : folders) &#123;</span><br><span class="line">            File[] files = folder.listFiles();</span><br><span class="line">            <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">                <span class="keyword">if</span> (file.getName().endsWith(<span class="string">&quot;.png&quot;</span>)) &#123;</span><br><span class="line">                    <span class="keyword">final</span> Bitmap bitmap = getBitmapFromFile(file);</span><br><span class="line">                    getActivity().runOnUiThread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                            imageCollectorView.addImage(bitmap);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;.start();</span><br></pre></td></tr></table></figure>
<blockquote>
<p>而如果使用 RxJava ，实现方式是这样的：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Observable.from(folders)</span><br><span class="line">    .flatMap(<span class="keyword">new</span> Function&lt;File, Observable&lt;File&gt;&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Observable&lt;File&gt; <span class="title">apply</span><span class="params">(File file)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Observable.from(file.listFiles());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .filter(<span class="keyword">new</span> Function&lt;File, Boolean&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Boolean <span class="title">apply</span><span class="params">(File file)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> file.getName().endsWith(<span class="string">&quot;.png&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .map(<span class="keyword">new</span> Function&lt;File, Bitmap&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Bitmap <span class="title">apply</span><span class="params">(File file)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getBitmapFromFile(file);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .subscribeOn(Schedulers.io())</span><br><span class="line">    .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">    .subscribe(<span class="keyword">new</span> Consumer&lt;Bitmap&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Bitmap bitmap)</span> </span>&#123;</span><br><span class="line">            imageCollectorView.addImage(bitmap);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<p>简单解释下这段代码：观察者发出数据源，然后对数据源进行三次数据类型变换，之后指定被观察者和观察者所在线程，最后对观察者进行订阅。</p>
<p>如果对 java 8 引入的 <a href="https://www.ibm.com/developerworks/cn/java/j-lo-java8streamapi/">Stream</a> 熟悉的话，就会发现这与对 <code>Stream</code> 的操作很像，从<br><code>flatMap()</code> 到 <code>observeOn()</code> 的操作相当于对流的 Intermediate 操作，而最后的 <code>subscribe()</code> 相当是对流的 Terminal 操作。而且前面的操作也都是惰性化(lazy)的，最后的订阅才会触发前面一系列的变换操作（其实 <code>subscribeOn()</code> 和 <code>observeOn()</code> 这两个方法也是基于变换的）。怎么理解呢，就相当于 RxJava 库将这些操作先 “缓存” 起来了，直到最后的订阅观察者才将那些操作执行，怎么 “缓存” 是库做的事，逻辑上我们可以把那些操作看作是从上到下按顺序执行的。</p>
<p>可见，RxJava 虽然增加了程序代码，但是可阅读性和可扩展性大大增强。</p>
<p>了解过 RxJava 的人都会觉得 RxJava 很神奇，几行代码便完成了数据流的转换和线程的切换。那么它的内部原理是怎样的呢，通过阅读源码和网上的资料，我对 RxJava 的实现原理有了大概的了解，接下来就和大家分享一下。</p>
<h2 id="对-RxJava-实现原理的粗浅理解"><a href="#对-RxJava-实现原理的粗浅理解" class="headerlink" title="对 RxJava 实现原理的粗浅理解"></a>对 RxJava 实现原理的粗浅理解</h2><h3 id="约定"><a href="#约定" class="headerlink" title="约定"></a>约定</h3><p>由于 RxJava 同时应用了观察者模式（别名：发布-订阅模式）和生产者-消费者模式，所以其 API 的名称有点混乱。为了避免读者理解困难，这里约定如下：</p>
<ul>
<li><code>Observable</code> 及其子类称为 <strong>被观察者</strong>；</li>
<li><code>Comsumer</code>（消费者） 和 <code>Observer</code>（观察者） 及其子类统称为 <strong>观察者</strong>（两者在 RxJava 含义相似）；</li>
<li>由于 RxJava 订阅的动作（subscribe）定义在 <code>Observale</code> 中，给我们的感觉是 <strong>被观察者</strong> 订阅 <strong>观察者</strong>，因此为了叙述方便和避免含义混乱，<strong>被观察者</strong> 订阅 <strong>观察者</strong> 和 <strong>观察者</strong> 订阅 <strong>观被察者</strong> 是同样的意思；</li>
<li>本文基于 RxJava 2.0.7 版。</li>
</ul>
<h3 id="变换"><a href="#变换" class="headerlink" title="变换"></a>变换</h3><p>变换是 RxJava 的亮点和理解上的难点，变换的作用是将一种数据类型转换成另一种数据类型。当被观察者发出的原始数据类型并不是观察者想要的数据类型时，我们就可以用变换来实现源数据类型和目的数据类型的转换。RxJava 中有很多种变换，如 map 变换、flatMap 变换、filter 变换等。其中 map 变换比较基础也较易理解，因此我们先从 map 变换讲起。</p>
<h4 id="map-变换"><a href="#map-变换" class="headerlink" title="map 变换"></a>map 变换</h4><p> map 变换能够将一种类型的数据源转换成另一种类型的数据源，比如要将 <code>int</code> 类型的图片资源 id 转换成 <code>Bitmap</code> 类型的对象并将其设置给一个  <code>ImageView</code> ，我们可以这样做：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Observble.just(R.id.img_example) <span class="comment">// 1</span></span><br><span class="line">         .map(<span class="keyword">new</span> Function&lt;Integer, Bitmap&gt;() &#123; <span class="comment">// 2</span></span><br><span class="line">              <span class="meta">@Override</span></span><br><span class="line">              <span class="function"><span class="keyword">public</span> Bitmap <span class="title">apply</span><span class="params">(Integer resourceId)</span> </span>&#123;</span><br><span class="line">                 <span class="keyword">return</span> BitmapFactory.decodeResource(resourceId);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;)</span><br><span class="line">          .subscribe(<span class="keyword">new</span> Consumer&lt;String&gt;() &#123; <span class="comment">// 4</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(<span class="meta">@NonNull</span> Bitmap b)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                imageView.setImageBitmap(b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>

<p>上面的例子里将上游的 <code>int</code> 数据类型转换成了 <code>Bitmap</code> 类型的数据，供下游的观察者接收。这个过程涉及了一次 map 变换，我们将透过这个例子分析 map 变换的原理。</p>
<p>首先从变换方法 <code>public Bitmap apply(Integer resourceId)</code> 看起，这个方法的参数类型是 <code>Integer</code>，返回值类型是 <code>Bitmap</code> ，因此我们很容易猜想到它就是实现变换的核心方法。这个方法被包装后就传入了 <code>map()</code> 中，<code>map()</code> 的源码是这样的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> &lt;R&gt; <span class="function">Observable&lt;R&gt; <span class="title">map</span><span class="params">(Function&lt;? <span class="keyword">super</span> T, ? extends R&gt; mapper)</span> </span>&#123;</span><br><span class="line">     ObjectHelper.requireNonNull(mapper, <span class="string">&quot;mapper is null&quot;</span>);</span><br><span class="line">     <span class="keyword">return</span> RxJavaPlugins.onAssembly(<span class="keyword">new</span> ObservableMap&lt;T, R&gt;(<span class="keyword">this</span>, mapper)); <span class="comment">// 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法中第一行验证 <code>mapper</code> 是否为空；第二行中的 <code>RxJavaPlugin.onAssenbly()</code> 是一个钩子方法，据说是用来调试 RxJava 库用的，你可以把它理解为什么都没做，因此 <code>map()</code> 方法可以简化为：<code>return new ObservableMap&lt;T, R&gt;(this, mapper);</code>，它返回的是一个 <code>Observable</code> 子类 <code>ObservableMap</code> 的一个实例。现在我重点看看 <code>ObservableMap</code> 这个类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ObservableMap</span>&lt;<span class="title">T</span>, <span class="title">U</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractObservableWithUpstream</span>&lt;<span class="title">T</span>, <span class="title">U</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//用来做数据变换的函数式对象，就是 map() 的参数，且称其为变换器</span></span><br><span class="line">    <span class="keyword">final</span> Function&lt;? <span class="keyword">super</span> T, ? extends U&gt; function;</span><br><span class="line">    <span class="comment">//source 是实际 Observalbe 对象，也就是 map 变换之前的那个 Observable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ObservableMap</span><span class="params">(ObservableSource&lt;T&gt; source, Function&lt;? <span class="keyword">super</span> T, ? extends U&gt; function)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(source);</span><br><span class="line">        <span class="keyword">this</span>.function = function;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//调用 Observable 的 subscribe() 方法发起订阅时，subscribe() 最终会调用此方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribeActual</span><span class="params">(Observer&lt;? <span class="keyword">super</span> U&gt; t)</span> </span>&#123;  <span class="comment">// 5</span></span><br><span class="line">        <span class="comment">//新建一个 MapObserver 观察者，用来订阅实际 Observable 对象 source</span></span><br><span class="line">        source.subscribe(<span class="keyword">new</span> MapObserver&lt;T, U&gt;(t, function)); <span class="comment">// 6</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//此类的构造方法传入的参数是变换器 mapper 和真实观察者 actual</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MapObserver</span>&lt;<span class="title">T</span>, <span class="title">U</span>&gt; <span class="keyword">extends</span> <span class="title">BasicFuseableObserver</span>&lt;<span class="title">T</span>, <span class="title">U</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Function&lt;? <span class="keyword">super</span> T, ? extends U&gt; mapper;</span><br><span class="line"></span><br><span class="line">        MapObserver(Observer&lt;? <span class="keyword">super</span> U&gt; actual, Function&lt;? <span class="keyword">super</span> T, ? extends U&gt; mapper) &#123;</span><br><span class="line">            <span class="keyword">super</span>(actual);</span><br><span class="line">            <span class="keyword">this</span>.mapper = mapper;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(T t)</span> </span>&#123; <span class="comment">// 7</span></span><br><span class="line">            ......</span><br><span class="line">            U v;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//通过转换器把从原 Observable 对象发出的数据转化成真实观察者要求的数据</span></span><br><span class="line">                v = ObjectHelper.requireNonNull(mapper.apply(t), <span class="string">&quot;The mapper function returned a null value.&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                <span class="comment">//如果出错，最终会调用 actual 的 onError() 方法</span></span><br><span class="line">                fail(ex); <span class="comment">// 8.1</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将转换后的数据传给真实观察者</span></span><br><span class="line">            actual.onNext(v); <span class="comment">// 8.2</span></span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为代码不多，我全部贴上来，便于大家理解。在上面的过程中，有这几类角色：1）实际被观察者；2）新创建的被观察者；3）实际观察者；4）新创建的观察者；5）转换器 mapper。它们的关系比较复杂，我们按照代码的执行顺序来将思路理一遍：</p>
<ul>
<li><code>Observable</code> 通过 <code>just()</code> 这个静态工厂方法创建了一个 <code>Observable</code> 对象，此对象即“实际被观察者”；</li>
<li><code>map()</code> 方法接受一个转换器对象，在内部新建了一个被观察者后将其返回，也就是 “新创建的被观察者”；</li>
<li>用 map 变换后返回的那个 “新创建的被观察者” 订阅 “实际观察者”，最终 “新创建的被观察者” 的 <code>subscribeActual()</code> 方法被调用，此方法触发的操作有：</li>
<li>创建一个观察者，也就是 “新创建的观察者”，向 “实际的被观察者” 订阅；</li>
<li>实际的被观察者发出数据，通过调用 “新创建的观察者” 的 <code>onNext()</code> 方法向其传递数据；</li>
<li>在新创建的被观察者的内部先用 “转换器” 的 <code>apply()</code> 方法将数据类型进行转换，然后调用 “实际观察者” 的 <code>onNext()</code> 方法将转换后的数据传给 “实际观察者”</li>
</ul>
<p>整个过程有点复杂，所以我在上述代码片段中用序号来表示各个过程的调用顺序，同时用一张图来表示 map 变换过程中以上几个角色的交互过程：</p>
<p><img src="/img/in-post/post_rxjava/map_1.png" alt="map 变换"></p>
<p>说明：</p>
<ul>
<li>A 表示实际被观察者，B 表示新创建的观察者，C 表示新创建的被观察者，D 表示实际的观察者，E 代表转换器；</li>
<li>虚线框中的 B 和 C 是 map 变换导致的新创建的角色，它们没有发生订阅关系，但是 C 一旦被订阅就会导致 B 的创建和对实际观察者的订阅；</li>
<li>B 和 D 都是观察者，它们进行了直接的接触：B 将信息转换后交给 D;</li>
</ul>
<p>如果大家理解了一次 map 变换的原理，连续两次 map 变换的的原理就不难理解了，在这里就不赘述了，贴一张和上面类似的交互图，请大家自行理解：</p>
<p><img src="/img/in-post/post_rxjava/map_2.png" alt="2次连续 map 变换"></p>
<h4 id="flatMap-变换"><a href="#flatMap-变换" class="headerlink" title="flatMap 变换"></a>flatMap 变换</h4><p>此处先占坑，日后来填</p>
]]></content>
      <tags>
        <tag>开源库</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>安卓进程通信机制之 AIDL</title>
    <url>/2016/10/28/2016-10-28-android-IPC-AIDL/</url>
    <content><![CDATA[<h1 id="安卓进程通信机制之-AIDL"><a href="#安卓进程通信机制之-AIDL" class="headerlink" title="安卓进程通信机制之 AIDL"></a>安卓进程通信机制之 AIDL</h1><h2 id="什么是-AIDL"><a href="#什么是-AIDL" class="headerlink" title="什么是 AIDL"></a>什么是 AIDL</h2><p>AIDL 全称 <em>Android Interface Definition Language</em>，即 <strong>安卓接口描述语言</strong>。听起来很深奥，其实它的本质就是生成进程间通信接口的辅助工具。它的存在形式是一种 <code>.aidl</code> 文件，开发者需要做的就是在该文件中定义进程间通信的接口，编译的时候 IDE 就会根据我们的 <code>.aidl</code> 接口文件生成可供项目使用的 <code>.java</code> 文件，这和我们说的“语法糖”有些类似。</p>
<p>AIDL 的语法就是 java 的语法，就是导包上有点细微差别。java 中如果两个类在相同的包中，是不需要进行导包操作的，但是在 AIDL 中，则必须进行导包声明。</p>
<span id="more"></span>

<h2 id="AIDL-详解"><a href="#AIDL-详解" class="headerlink" title="AIDL 详解"></a>AIDL 详解</h2><p>构想一个场景：我们有一个图书管理系统，这个系统的通过 CS 模式来实现。具体的管理功能由服务端进程来实现，客户端只需要调用相应的接口就可以。</p>
<p>那么首先定义这个管理系统的 ADIL 接口。</p>
<p>我们在 <code>/src</code> 新建 <code>aidl</code> 包，包中有 Book.java 、Book.aidl、IBookManager.aidl 这三个文件。</p>
<ul>
<li>Book.java</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.aidl book</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span> <span class="keyword">implements</span> <span class="title">Parcelable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> bookId;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Book</span><span class="params">(String name, <span class="keyword">int</span> bookId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.bookId = bookId;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Book</span><span class="params">(Parcel source)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = source.readString();</span><br><span class="line">        <span class="keyword">this</span>.bookId = source.readInt();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">describeContents</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeToParcel</span><span class="params">(Parcel dest, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">        dest.writeString(name);</span><br><span class="line">        dest.writeInt(bookId);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Creator&lt;Book&gt;  CREATOR = <span class="keyword">new</span> Creator&lt;Book&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Book <span class="title">createFromParcel</span><span class="params">(Parcel source)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Book(source);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Book[] newArray(<span class="keyword">int</span> size) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Book[size];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Book.aidl</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.aidl;</span><br><span class="line"></span><br><span class="line">Parcelable Book;</span><br></pre></td></tr></table></figure>

<ul>
<li>IBookManager.aidl</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.aidl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.aidl.Book;</span><br><span class="line"></span><br><span class="line">inteface IBookManager &#123;</span><br><span class="line">   <span class="function">List&lt;Book&gt; <span class="title">getBookList</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">addBook</span><span class="params">(in Book book)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面对这三个文件分别进行说明：</p>
<ul>
<li><code>Book.java</code> 是我们定义的实体类，它实现了 <code>Parcelable</code> 接口，这样 <code>Book</code> 类才能在进程间传输。</li>
<li><code>Book.aidl</code> 是这个实体类在 AIDL 中的声明。</li>
<li><code>IBookManager</code> 是服务端和客户端通信的接口。（注意，在 AIDL 接口中除基本类型外，参数前须加方向，<code>in</code> 表示输入型参数，<code>out</code> 表示输出型参数，<code>inout</code> 表示输入输出型参数）</li>
</ul>
<p>编译器编译后，android studio 为我们的项目自动生成了一个 <code>.java</code> 文件，这个文件包含三个类，这三个类分别是 <code>IBookManager</code>, <code>Stub</code> 和 <code>Proxy</code>，这三个类都是静态类型，我们完全可以把他们分开来，三个类定义如下：</p>
<ul>
<li><code>IBookManager</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IBookManager</span> <span class="keyword">extends</span> <span class="title">android</span>.<span class="title">os</span>.<span class="title">IInterface</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBook</span><span class="params">(net.bingyan.library.Book book)</span> <span class="keyword">throws</span> android.os.RemoteException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> java.util.List&lt;net.bingyan.library.Book&gt; getBookList() <span class="keyword">throws</span> android.os.RemoteException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Stub</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Stub</span> <span class="keyword">extends</span> <span class="title">android</span>.<span class="title">os</span>.<span class="title">Binder</span> <span class="keyword">implements</span> <span class="title">net</span>.<span class="title">bingyan</span>.<span class="title">library</span>.<span class="title">IBookManager</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> java.lang.String DESCRIPTOR = <span class="string">&quot;net.bingyan.library.IBookManager&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TRANSACTION_addBook = (android.os.IBinder.FIRST_CALL_TRANSACTION + <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TRANSACTION_getBookList = (android.os.IBinder.FIRST_CALL_TRANSACTION + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Construct the stub at attach it to the interface.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Stub</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.attachInterface(<span class="keyword">this</span>, DESCRIPTOR);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Cast an IBinder object into an net.bingyan.library.IBookManager interface,</span></span><br><span class="line"><span class="comment">         * generating a proxy if needed.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> net.bingyan.library.<span class="function">IBookManager <span class="title">asInterface</span><span class="params">(android.os.IBinder obj)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> ((obj == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);</span><br><span class="line">            <span class="keyword">if</span> (((iin != <span class="keyword">null</span>) &amp;&amp; (iin <span class="keyword">instanceof</span> net.bingyan.library.IBookManager))) &#123;</span><br><span class="line">                <span class="keyword">return</span> ((net.bingyan.library.IBookManager) iin);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> net.bingyan.library.IBookManager.Stub.Proxy(obj);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> android.os.<span class="function">IBinder <span class="title">asBinder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTransact</span><span class="params">(<span class="keyword">int</span> code, android.os.Parcel data, android.os.Parcel reply, <span class="keyword">int</span> flags)</span> <span class="keyword">throws</span> android.os.RemoteException </span>&#123;</span><br><span class="line">            <span class="keyword">switch</span> (code) &#123;</span><br><span class="line">                <span class="keyword">case</span> INTERFACE_TRANSACTION: &#123;</span><br><span class="line">                    reply.writeString(DESCRIPTOR);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> TRANSACTION_addBook: &#123;</span><br><span class="line">                    data.enforceInterface(DESCRIPTOR);</span><br><span class="line">                    net.bingyan.library.Book _arg0;</span><br><span class="line">                    <span class="keyword">if</span> ((<span class="number">0</span> != data.readInt())) &#123;</span><br><span class="line">                        _arg0 = net.bingyan.library.Book.CREATOR.createFromParcel(data);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        _arg0 = <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">this</span>.addBook(_arg0);</span><br><span class="line">                    reply.writeNoException();</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> TRANSACTION_getBookList: &#123;</span><br><span class="line">                    data.enforceInterface(DESCRIPTOR);</span><br><span class="line">                    java.util.List&lt;net.bingyan.library.Book&gt; _result = <span class="keyword">this</span>.getBookList();</span><br><span class="line">                    reply.writeNoException();</span><br><span class="line">                    reply.writeTypedList(_result);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.onTransact(code, data, reply, flags);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Proxy</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">net</span>.<span class="title">bingyan</span>.<span class="title">library</span>.<span class="title">IBookManager</span> </span>&#123;</span><br><span class="line">            <span class="keyword">private</span> android.os.IBinder mRemote;</span><br><span class="line"></span><br><span class="line">            Proxy(android.os.IBinder remote) &#123;</span><br><span class="line">                mRemote = remote;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> android.os.<span class="function">IBinder <span class="title">asBinder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> mRemote;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> java.lang.<span class="function">String <span class="title">getInterfaceDescriptor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> DESCRIPTOR;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * Demonstrates some basic types that you can use as parameters</span></span><br><span class="line"><span class="comment">             * and return values in AIDL.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBook</span><span class="params">(net.bingyan.library.Book book)</span> <span class="keyword">throws</span> android.os.RemoteException </span>&#123;</span><br><span class="line">                android.os.Parcel _data = android.os.Parcel.obtain();</span><br><span class="line">                android.os.Parcel _reply = android.os.Parcel.obtain();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    _data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">                    <span class="keyword">if</span> ((book != <span class="keyword">null</span>)) &#123;</span><br><span class="line">                        _data.writeInt(<span class="number">1</span>);</span><br><span class="line">                        book.writeToParcel(_data, <span class="number">0</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        _data.writeInt(<span class="number">0</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    mRemote.transact(Stub.TRANSACTION_addBook, _data, _reply, <span class="number">0</span>);</span><br><span class="line">                    _reply.readException();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    _reply.recycle();</span><br><span class="line">                    _data.recycle();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> java.util.List&lt;net.bingyan.library.Book&gt; getBookList() <span class="keyword">throws</span> android.os.RemoteException &#123;</span><br><span class="line">                android.os.Parcel _data = android.os.Parcel.obtain();</span><br><span class="line">                android.os.Parcel _reply = android.os.Parcel.obtain();</span><br><span class="line">                java.util.List&lt;net.bingyan.library.Book&gt; _result;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    _data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">                    mRemote.transact(Stub.TRANSACTION_getBookList, _data, _reply, <span class="number">0</span>);</span><br><span class="line">                    _reply.readException();</span><br><span class="line">                    _result = _reply.createTypedArrayList(net.bingyan.library.Book.CREATOR);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    _reply.recycle();</span><br><span class="line">                    _data.recycle();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> _result;</span><br><span class="line">            &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<p>对生成的这三个类的说明如下：</p>
<ul>
<li><code>IBookManager</code> 这个类是我们定义的接口，android studio 给它添加了一个父类，让它继承自 android.os.interface 这个接口，这个接口只有一个方法 <code>IBinder asBinder()</code>，这样 <code>IBookManager</code> 中就有三个待实现的方法了，它是服务端进程和客户端进程通信的窗口。</li>
<li><code>Stub</code> 是个抽象类，这个类继承自 <code>android.os.Binder</code>，并且实现了 <code>IBookManager</code> 这个接口。在 <code>Stub</code> 中，已经实现了 <code>asBinder()</code> 这个接口方法，还有两个是我们定义的 AIDL 接口方法留给继承它的子类去实现。它用在服务端，因此服务端需要实现这两个方法。</li>
<li><code>Proxy</code> 顾名思义是一个代理类，它在客户端使用，是服务端在客户端的一个代理，它也实现了 <code>IBookManager</code> 接口，并且实现了 <code>IBookManager</code> 中的所有方法。</li>
</ul>
<p>现在我们对这三个类逐个分析：</p>
<ul>
<li><p><code>IBookManager</code> 这个类没什么好说的，它只是简单继承了 <code>IInterface</code> 这个接口，这个接口的作用就是将 <code>IBookManager</code> 转换成 <code>IBinder</code>。</p>
</li>
<li><p><code>Proxy</code> 这个类上面已经提到过了，它就是进程间通信机制的一个封装类，通过构造方法我们也容易看出来，其内部实现机制就是 <code>Binder</code>。它的构造方法接受一个 <code>IBinder</code> 类型的参数，参数名为 <code>remote</code>，显然，它代表着服务端。我们看看这个类中的方法 <code>addBook()</code> 和 <code>getBookList()</code>：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBook</span><span class="params">(net.bingyan.library.Book book)</span> <span class="keyword">throws</span> android.os.RemoteException </span>&#123;</span><br><span class="line">      android.os.Parcel _data = android.os.Parcel.obtain();</span><br><span class="line">      android.os.Parcel _reply = android.os.Parcel.obtain();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">            _data.writeInterfaceToken(DESCRIPTOR)</span><br><span class="line">            <span class="keyword">if</span> ((book != <span class="keyword">null</span>)) &#123;</span><br><span class="line">                _data.writeInt(<span class="number">1</span>);</span><br><span class="line">                book.writeToParcel(_data, <span class="number">0</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                _data.writeInt(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            mRemote.transact(Stub.TRANSACTION_addBook, _data, _reply, <span class="number">0</span>);</span><br><span class="line">            _reply.readException();</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            _reply.recycle();</span><br><span class="line">            _data.recycle();</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> java.util.List&lt;net.bingyan.library.Book&gt; getBookList() <span class="keyword">throws</span> android.os.RemoteException &#123;</span><br><span class="line">       android.os.Parcel _data = android.os.Parcel.obtain();</span><br><span class="line">       android.os.Parcel _reply = android.os.Parcel.obtain();</span><br><span class="line">       java.util.List&lt;net.bingyan.library.Book&gt; _result;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">             _data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">             mRemote.transact(Stub.TRANSACTION_getBookList, _data, _reply, <span class="number">0</span>);</span><br><span class="line">             _reply.readException();</span><br><span class="line">             _result = _reply.createTypedArrayList(net.bingyan.library.Book.CREATOR);</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            _reply.recycle();</span><br><span class="line">            _data.recycle();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> _result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它们是编译器自动实现的，这两个方法有很多类似之处，可以先在这里透露下：这两个方法就是客户端进程调用服务端进程的窗口。在这两个方法的开始，它们都定义了两个 <code>Parcel</code>（中文译名：包裹）对象。<code>Parcel</code> 这个类我们看上去很眼熟，是的，<code>Book</code> 类中的 <code>writeToParcel()</code> 和 <code>CREATOR</code> 中的 <code>createFromParcel()</code> 的参数就是 <code>Parcel</code> 类型的，关于这个类文档中解释如下：</p>
<blockquote>
<p>Container for a message (data and object references) that can<br>  be sent through an IBinder.  A Parcel can contain both flattened data<br>  that will be unflattened on the other side of the IPC (using the various<br>  methods here for writing specific types, or the general<br>  {@link Parcelable} interface), and references to live {@link IBinder}<br>  objects that will result in the other side receiving a proxy IBinder<br>  connected with the original IBinder in the Parcel.</p>
</blockquote>
<p>翻译一下：<code>Parcel</code> 是一个可以通过 <code>IBinder</code> 进行消息传递的一个容器。一个 <code>Parcel</code> 可以包含可序列化的数据，这些数据会在 <code>IPC</code> 的另一端被反序列化；它也可以包含指向 <code>IBinder</code> 对象的引用，这会使得另一端接收到一个 <code>IBinder</code> 类型的代理对象，这个代理对象连接着 <code>Parcel</code> 中的原始 <code>IBinder</code> 对象。</p>
<p>下面用图来直观的说明：<br><img src="/img/in-post/post-android-IPC-AIDL/IPC_1.png"></p>
<p>如图，我们可以很直观的看到服务端以 <code>Parcel</code> 作为数据包裹依靠 <code>Binder</code> 和客户端进行通信。数据包裹就是序列化之后的对象。</p>
<p>如上所述，这两个方法都定义了两个 <code>Parcel</code> 对象，分别叫做 <code>_data</code> 和 <code>_reply</code>，从客户端的角度来看，<code>_data</code> 就是客户端发送给服务端的数据包裹，<code>_reply</code> 服务端发送给客户端的数据包裹。</p>
<p>之后便开始用这两个对象来和服务端进行通信了。我们观察到，两个方法中都有这么个方法调用 <code>mRemote.transact()</code>。它有四个参数，第一个参数的意义我们后面再讲，第二个参数 <code>_data</code> 负责向服务端发送数据包裹比如接口方法的参数，第三个参数 <code>_reply</code> 负责从服务端接收数据包裹比如接口方法的返回值。这行代码只有一句简单的方法调用，但是却是 AIDL 通信的最核心部分，它其实进行了一次远程方法调用（客户端通过本地代理 <code>Proxy</code> 暴露的接口方法调用服务端 <code>Stub</code> 同名方法），所以能想到它是一个耗时操作。</p>
<p>在我们的例子中：</p>
<ul>
<li><p><code>void addBook(Book book)</code> 需要借助 <code>_data</code> 向服务端发送参数 <code>Book:book</code>，发送的方式就是把 <code>Book</code> 通过其实现的 <code>writeToParcel(Parcel out)</code> 方法打包至 <code>_data</code> 中，正如你能想到的，<code>_data</code> 其实就是参数 <code>out</code>，还记得 <code>Book</code> 中的这个方法的实现吗？ 我们是将 <code>Book</code> 的字段一个个打包至 <code>Parcel</code> 中的。</p>
</li>
<li><p><code>List&lt;Book&gt; getBookList()</code> 需要借助 <code>_reply</code> 从服务端接收返回值 <code>List&lt;Book&gt;:books</code>，方法中的做法是将 <code>Book</code> 中的 <code>CREATOR</code> 这个静态字段作为参数传入 <code>_reply</code> 的 <code>createTypedArrayList()</code> 方法中，还记得 <code>Book</code> 中的 <code>CREATOR</code> 吗？当时你是不是好奇这个静态字段应该怎么用呢？现在一切明了了，我们需要靠这个对象（便于理解我们可以叫它”反序列化器“）对来自服务端的数据反序列化为对象或者对象数组。很明显 <code>CREATOR</code> 借助 <code>_reply</code> 反序列化生成了 <code>List&lt;Book&gt;:books</code>。</p>
</li>
</ul>
<p>当然这两个方法中的 <code>_data</code> 和 <code>_reply</code> 不仅传递了对象，还传递了一些校验信息，这个我们可以不去深究，但应注意的是，<code>Parcel</code> 打包顺序和解包顺序要严格对应。例如，第一个打包的是 <code>int:i</code>，那么第一解包的也应该是这个整型值。也即打包时第一次调用的如果是 <code>Parcel.writeInt(int)</code>，解包时第一次调用的应该是 <code>Parcel.readInt()</code>。</p>
<p>到此，客户端的 <code>Proxy</code> 讲解完了，下面我们看看服务端的 Stub。</p>
<ul>
<li><p><code>Stub</code> 中实现了 <code>IBookManager</code> 的其中一个方法 <code>asBinder()</code>，它的实现很简单，就是把 <code>Stub</code> 自身返回。因为 <code>Stub</code> 本身就继承自 <code>Binder</code>，而 <code>Binder</code> 继承自 <code>IBinder</code>，所以没有任何问题。你会问：还有两个方法没实现呢？这两个方法就是我们定义的接口方法，它们留给服务端进程去实现，也就是说，到时候我们在服务端进程中需要定义一个 <code>Stub</code> 的实现者。下面对 <code>Stub</code> 中的两个重要方法进行分析：</p>
<ul>
<li><code>IBookManager asInterface(IBinder obj)</code></li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> net.bingyan.library.<span class="function">IBookManager <span class="title">asInterface</span><span class="params">(android.os.IBinder obj)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> ((obj == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);</span><br><span class="line">            <span class="keyword">if</span> (((iin != <span class="keyword">null</span>) &amp;&amp; (iin <span class="keyword">instanceof</span> net.bingyan.library.IBookManager))) &#123;</span><br><span class="line">                <span class="keyword">return</span> ((net.bingyan.library.IBookManager) iin);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> net.bingyan.library.IBookManager.Stub.Proxy(obj);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>这个方法是用来给客户端调用的，作用是将 <code>Binder</code> 转换成 <code>IBookManager</code> 这个接口。通过 Binder 进行通信时，服务端会传给客户端一个 Binder 对象（如果是同一进程就是 <code>Stub</code>，不是同一进程就是 <code>BinderProxy</code>)。客户端问：你给我这个对象有什么用？服务端答曰：贫道我这有个方法 <code>asInterface()</code>，你将 <code>Binder</code> 放入其中便可得到你想要的东西了。那么这个方法到底做了什么，竟有如此神效？我们来分析下。</p>
<p>方法中有个判断：如果我们的服务端进程和客户端进程是同一进程，那么就直接将 <code>Binder</code>（此时是 <code>Stub</code>）通过类型转换转成 <code>IBookManager</code>；如果不是同一进程，那么就通过代理类 <code>Proxy</code> 将 <code>Binder</code>(其实这个时候是一个 <code>BinderProxy</code>，它是服务端 <code>Binder</code>，也就是 <code>Stub</code> 在客户端的代理) 转换成 <code>IBookManager</code>。为什么这么做，我们知道如果服务端进程和客户端进程不是同一进程，那么它们的内存就不能共享，就不能通过一般的方式进行通信。但是我们如果自己去实现进程间通信方式，对于普通开发者来说成本太大，因此编译器帮我们生成了一个封装了了进程间通信的工具，也就是这个 <code>Proxy</code>，这个类对底层的进程通信机制进行了封装只暴露出通信接口 <code>IBookManager</code>。总之，不管是同一进程还是不同进程，通过这个方法 <code>Binder</code> 对象最终都转化成了 <code>IBookManager</code> 这个通信接口。客户端只需调用这个接口中定义的两个方法便可实现和服务端的通信而不需要了解其中的细节(是进程内通信还是进程间通信)。具体的使用场景我们会在后面的实例中进行讲解。</p>
<ul>
<li><code>onTransact(int code, Parcel data, Parcel reply, int flags)</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTransact</span><span class="params">(<span class="keyword">int</span> code, android.os.Parcel data, android.os.Parcel reply, <span class="keyword">int</span> flags)</span> <span class="keyword">throws</span> android.os.RemoteException </span>&#123;</span><br><span class="line">           <span class="keyword">switch</span> (code) &#123;</span><br><span class="line">               <span class="keyword">case</span> INTERFACE_TRANSACTION: &#123;</span><br><span class="line">                    reply.writeString(DESCRIPTOR);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">case</span> TRANSACTION_addBook: &#123;</span><br><span class="line">                    data.enforceInterface(DESCRIPTOR);</span><br><span class="line">                    net.bingyan.library.Book _arg0;</span><br><span class="line">                    <span class="keyword">if</span> ((<span class="number">0</span> != data.readInt())) &#123;</span><br><span class="line">                        _arg0 = net.bingyan.library.Book.CREATOR.createFromParcel(data);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        _arg0 = <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">this</span>.addBook(_arg0);</span><br><span class="line">                    reply.writeNoException();</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">case</span> TRANSACTION_getBookList: &#123;</span><br><span class="line">                    data.enforceInterface(DESCRIPTOR);</span><br><span class="line">                    java.util.List&lt;net.bingyan.library.Book&gt; _result = <span class="keyword">this</span>.getBookList();</span><br><span class="line">                    reply.writeNoException();</span><br><span class="line">                    reply.writeTypedList(_result);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">super</span>.onTransact(code, data, reply, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法我们是不是也很熟悉呢？我们在 <code>Proxy</code> 中有一个类似的方法 <code>transact(int, Parcel, Parcel, int)</code>，它们的参数一样，而且它们都是 <code>Binder</code> 中定义的方法，那么它们有什么联系呢？</p>
<p>前面说了，<code>transact()</code> 执行了一个远程调用，如果说 <code>transact()</code> 是远程调用的发起，那么 <code>onTransact()</code> 就是远程调用的响应。真实过程是客户端发起远程方法调用，android 系统底层对这个调用进行响应和处理，之后回调服务端的 <code>onTransact()</code> 方法，从数据包裹中取出方法参数，交给服务端实现的同名方法，最后将返回值打包返回给客户端。</p>
<p>需要注意的是， <code>onTransact()</code> 是在服务端进程的 <code>Binder</code> 线程池中进行的，这就意味着如果我们的要在 <code>onTransact()</code> 方法中更新 UI，就必须借助 <code>Handler</code>。</p>
<p>这两个方法的第一个参数的含义是 AIDL 接口方法的标识码，在 <code>Stub</code> 中，定义了两个常量作为这两个方法的标示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TRANSACTION_addBook = (android.os.IBinder.FIRST_CALL_TRANSACTION + <span class="number">0</span>);</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TRANSACTION_getBookList = (android.os.IBinder.FIRST_CALL_TRANSACTION + <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>服务端响应客户端的调用时，会根据这个参数进行判断：如果 <code>code == TRANSACTION_addBook</code>，说明客户端调用的是 <code>addBook()</code>；如果 <code>code == TRANSACTION_getBookList</code>，说明客户端调用的是 <code>getBookList()</code>，然后交由相应的服务端方法处理。</p>
<p>最后用一张图来表示整个通信过程（来自《安卓开发艺术探索》）：<br><img src="/img/in-post/post-android-IPC-AIDL/IPC_2.png"></p>
<p>了解了 AIDL 的原理，接下来我们看看 AIDL 在安卓程序中的应用。</p>
<h2 id="AIDL-的使用"><a href="#AIDL-的使用" class="headerlink" title="AIDL 的使用"></a>AIDL 的使用</h2><p>相信大家应该都和清楚 <code>Service</code> 的使用了吧，<code>Service</code> 虽然称作“服务”，并且运行于后台，但是它们默认还是运行在默认进程的主线程中。其实让 <code>Service</code> 运行在默认进程中，有点大材小用了。android 的很多系统服务都运行于单独的进程中，供其他应用调用，比如窗口管理服务。这样做的好处是可以多个应用共享同一个服务，节约了资源，也便于集中管理各个客户端，要注意问题的就是线程安全问题。</p>
<p>那么接下来我们就用 AIDL 实现一个简单的 CS 架构的图书管理系统。</p>
<p>首先我们定义服务端：</p>
<ul>
<li><code>BookManagerService</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookManagerService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Book&gt; mLibrary = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> IBookManager mBookManager = <span class="keyword">new</span> IBookManager.Stub() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBook</span><span class="params">(Book book)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (mLibrary) &#123;</span><br><span class="line">                mLibrary.add(book);</span><br><span class="line">                Log.d(<span class="string">&quot;BookManagerService&quot;</span>, <span class="string">&quot;now our library has &quot;</span> + mLibrary.size() + <span class="string">&quot; books&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> List&lt;Book&gt; <span class="title">getBookList</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> mLibrary;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mBookManager.asBinder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">service</span></span></span><br><span class="line"><span class="tag">      <span class="attr">android:process</span>=<span class="string">&quot;:remote&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">android:name</span>=<span class="string">&quot;.BookManagerService&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>服务端我们定义了 <code>BookManagerService</code> 这个类，在它里面我们创建了服务端的 <code>Stub</code> 对象，并且实现了需要实现的两个 AIDL 接口方法来定义服务端的图书管理策略。在 <code>onBind()</code> 方法中我们将 <code>IBookManager</code> 对象作为 <code>IBinder</code> 返回。我们知道，当我们绑定一个服务时，系统会调用 <code>onBinder()</code> 方法得到服务端的 <code>IBinder</code> 对象，并将其转换成客户端的 <code>IBinder</code> 对象传给客户端。对于进程间通信来说，虽然服务端的 <code>IBinder</code> 和 客户端的 <code>IBinder</code> 是两个 <code>IBinder</code> 对象，但他们在底层都是同一个对象。在 xml 中注册 <code>Service</code> 时我们给它指定了进程名，这样 <code>Service</code> 就能运行在单独的进程中了。</p>
<p>接下来看看客户端的实现：</p>
<ul>
<li><code>Client</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TextView textView;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> IBookManager bookManager;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(<span class="meta">@Nullable</span> Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.library_book_manager_system_client);</span><br><span class="line"></span><br><span class="line">        Intent i  = <span class="keyword">new</span> Intent(Client.<span class="keyword">this</span>, BookManagerService.class);</span><br><span class="line">        bindService(i, conn, BIND_AUTO_CREATE);</span><br><span class="line"></span><br><span class="line">        Button addABook = (Button) findViewById(R.id.button);</span><br><span class="line">        addABook.setOnClickListener(v -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (bookManager == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                bookManager.addBook(<span class="keyword">new</span> Book(<span class="number">0</span>, <span class="string">&quot;book&quot;</span>));</span><br><span class="line">                textView.setText(getString(R.string.book_management_system_book_count, String.valueOf(bookManager.getBookList().size())));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        textView = (TextView) findViewById(R.id.textView);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ServiceConnection conn = <span class="keyword">new</span> ServiceConnection() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName name, IBinder service)</span> </span>&#123;</span><br><span class="line">            Log.d(<span class="string">&quot;Client --&gt;&quot;</span>, service.toString());</span><br><span class="line"></span><br><span class="line">            bookManager = IBookManager.Stub.asInterface(service);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceDisconnected</span><span class="params">(ComponentName name)</span> </span>&#123;</span><br><span class="line">            Log.d(<span class="string">&quot;Client&quot;</span>, name.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">&quot;vertical&quot;</span> <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:weightSum</span>=<span class="string">&quot;1&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:gravity</span>=<span class="string">&quot;center&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;add a book&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;111dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/button&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginTop</span>=<span class="string">&quot;10dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;@string/book_management_system_book_count&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;231dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:gravity</span>=<span class="string">&quot;center&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/textView&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>我们的客户端就是一个 <code>Activity</code>，<code>onCreate()</code> 中进行了服务的绑定，<code>bindService()</code> 方法中有一参数 <code>ServiceConnection:conn</code>，因为绑定服务是异步进行的，这个参数的作用就是绑定服务成功后回调的接口，它有两个方法：一个是连接服务成功后回调，另一个在与服务端断开连接后回调。我们现在关心的主要是 <code>onServiceConnected()</code> 方法，在这里我们只做了一件事：将服务端转换过来的 <code>IBinder</code> 对象转换成 AIDL 接口，我们定义 <code>IBookManager:bookManager</code> 字段来保持对其的引用。这样的话，我们就可以通过这个 <code>bookManager</code> 来进行方法的远程调用。我们给客户端的 <code>Button</code> 注册事件：每一次点击都会向服务端增加一本书，并将图书馆现有的图书数量显示出来。</p>
<p>现在我们看看程序的运行效果：</p>
<center> <img src="/img/in-post/post-android-IPC-AIDL/AIDL.gif"/> </center>

<p>每当我们点击按钮，我们就成功的向服务端添加了一本书，说明我们通过 AIDL 跨进程通信成功了。</p>
<p><strong>参考书籍</strong><br>《安卓开发艺术探索》 任玉刚 著</p>
]]></content>
      <tags>
        <tag>Android</tag>
        <tag>IPC</tag>
      </tags>
  </entry>
  <entry>
    <title>安卓动态加载入门</title>
    <url>/2016/11/11/2016-11-11-android-load-class-dynamically/</url>
    <content><![CDATA[<h1 id="安卓动态加载入门"><a href="#安卓动态加载入门" class="headerlink" title="安卓动态加载入门"></a>安卓动态加载入门</h1><p>这几周为了理解安卓动态加载技术算是花了不少时间，遇到很多坑，当然也学到了不少。一开始是学习 java 虚拟机，了解类文件格式，然后又在各种博客网站上看 dalvik 虚拟机和 dex 文件格式，了解安卓的类加载机制，到后来又去了解 art 虚拟机和 oat 文件格式。虽然有些地方没搞太清楚，学习的不够深入，但总算把动态加载的大概原理弄清了，也算是为之后更深入学习安卓动态加载以及热修复、热更新等技术打下基础吧。</p>
<span id="more"></span>

<h2 id="什么是动态加载技术"><a href="#什么是动态加载技术" class="headerlink" title="什么是动态加载技术"></a>什么是动态加载技术</h2><p>这个在网上没有看到严格的定义，不过就我个人的理解，动态加载代码就是通过在运行时加载外部代码（磁盘，网络等）改变程序行为的技术。关于安卓动态加载技术的文章网上有很多，但很多都是基于较低安卓版本的，对于较高版本有些地方不一定适用。我这里准备基于 andriod M 来和大家分享一下安卓的动态加载技术，让大家对这项技术有一个初步的了解。</p>
<h2 id="动态加载技术详解"><a href="#动态加载技术详解" class="headerlink" title="动态加载技术详解"></a>动态加载技术详解</h2><p>不管是 java 应用还是安卓应用，动态加载技术的核心都是类加载机制，所以我们有必要先了解下安卓的类加载机制，而安卓的类加载机制沿袭了普通的 java 应用的类加载机制，因此我们先看看 java 虚拟机（JVM）是怎么加载类的。</p>
<h3 id="JVM-类加载机制"><a href="#JVM-类加载机制" class="headerlink" title="JVM 类加载机制"></a>JVM 类加载机制</h3><p>JVM 的类加载机制是双亲委派模型，但是这个“双亲”感觉有点误导，因此我更喜欢叫它委派式模型。这里不对 JVM 委派式的类加载机制做过多分析，贴上一张图供大家去理解：</p>
<p><img src="/img/in-post/post_android_load_class_dynamically/android-load-class-dynamically-1.png"></p>
<p>结合这张图说明几点：</p>
<ul>
<li><code>BootStrapClassLoader</code> 是顶级的类加载器，它是唯一一个不继承自 <code>ClassLoader</code> 的类加载器，它高度集成于 JVM，是 <code>ExtensionClassLoader</code> 的父加载器，它的类加载路径是 <code>JDK\jre\lib</code> 和 用户指定的虚拟机参数 <code>-Xbootclasspath</code> 的值。</li>
<li><code>ExtensionClassLoader</code> 是 <code>BootStrapClassLoader</code> 的子加载器，同时是 <code>SystemClassLoader</code> （有的地方称 <code>AppClassLoader</code>）的父加载器，它的类加载路径是 <code>JDK\jre\lib\ext</code> 和系统属性 <code>java.ext.dirs</code> 的值。</li>
<li><code>SystemClassLoader</code> 是 <code>ExtensionClassLoader</code> 的子加载器，同时是我们的应用程序的类加载器，我们在应用程序中编写的类一般情况下（如果没有用到动态加载技术的话）都是通过这个类加载加载的。它的类加载路径是环境变量 <code>CLASSPATH</code> 的值或者用户通过命令行可选项 <code>-cp (-classpath)</code> 指定的值。</li>
<li>类加载器由于父子关系形成树形结构，开发人员可以开发自己的类加载器从而实现动态加载功能，但必须给这个类加载器指定树上的一个节点作为它的父加载器。</li>
<li>因为类加载器是通过包名和类名（或者说类的全限定名），所以由于委派式加载机制的存在，全限定名相同的类不会在有 <strong>祖先—子孙</strong> 关系的类加载器上分别加载一次，不管这两个类的实现是否一样。</li>
<li>不同的类加载器加载的类一定是不同的类，即使它们的全限定名一样。如果全限定名一样，那么根据上一条，这两个类加载器一定没有 <strong>祖先-子孙</strong> 的关系。这样来看，可以通过自定义类加载器使得相同全限定名但实现不同的类存在于同一 JVM 中，也就是说，类加载器相当于给类在包名之上又加了个命名空间。</li>
<li>如果两个相同全限定名的类由两个非 <strong>祖先-子孙</strong> 关系的类加载器加载，这两个类之间通过 <code>instanceof</code> 和 <code>equals()</code> 等进行比较时总是返回 <code>false</code>。</li>
</ul>
<p>我们知道，安卓应用和普通的 java 应用不同，它们运行于 Dalvik 虚拟机。JVM 是基于栈的虚拟机，而 Dalvik 是基于寄存器的虚拟机。因此，java 虚拟机具有更大的指令集，而 Dalvik 虚拟机的指令更长。除此之外，考虑到 Dalvik 虚拟机运行于移动设备，内存空间和 CPU 执行效率有限，因此采用 dex 作为储存类字节码信息的文件。当 java 程序编译成 class 后，编译器会使用 dx 工具将所有的class 文件整合到一个 dex 文件，目的是使其中各个类能够共享数据，在一定程度上降低了冗余，同时也是文件结构更加紧凑。虽然这两种虚拟机有诸多不同，但是 Dalvik 继承了 JVM 的委派式的类加载机制，因此上面的<strong>部分</strong>（主要是后面四条）结论对于安卓来说也是同样适用的。</p>
<p>因为安卓的类加载机制也是委派式的，所以如果你知道 JVM 的类加载机制，那么通过类比学习安卓的类加载机制就很容易了。本来准备放张图来对比说明安卓的类加载模型的，但是想想我们还是有必要先了解安卓中两个重要的类加载器以及内部的细节：<code>DexClassLoader</code> 和 <code>PathClassLoader</code>。</p>
<h3 id="DexClassLoader-amp-PathClassLoader"><a href="#DexClassLoader-amp-PathClassLoader" class="headerlink" title="DexClassLoader &amp; PathClassLoader"></a>DexClassLoader &amp; PathClassLoader</h3><p>先看看这两个类加载器的定义（点击超链接可查看注释）：</p>
<ul>
<li><a href="http://androidxref.com/7.0.0_r1/xref/libcore/dalvik/src/main/java/dalvik/system/DexClassLoader.java">DexCloassLoader</a></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> dalvik.system;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DexClassLoader</span> <span class="keyword">extends</span> <span class="title">BaseDexClassLoader</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DexClassLoader</span><span class="params">(String dexPath, String optimizedDirectory, String libraryPath, ClassLoader parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(dexPath, <span class="keyword">new</span> File(optimizedDirectory), libraryPath, parent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><a href="http://androidxref.com/7.0.0_r1/xref/libcore/dalvik/src/main/java/dalvik/system/PathClassLoader.java">PathClassLoader</a></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> dalvik.system;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PathClassLoader</span> <span class="keyword">extends</span> <span class="title">BaseDexClassLoader</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PathClassLoader</span><span class="params">(String dexPath, ClassLoader parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(dexPath, <span class="keyword">null</span>, <span class="keyword">null</span>, parent);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PathClassLoader</span><span class="params">(String dexPath, String libraryPath, ClassLoader parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(dexPath, <span class="keyword">null</span>, libraryPath, parent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，这两个类加载器都是继承自 <a href="http://androidxref.com/7.0.0_r1/xref/libcore/dalvik/src/main/java/dalvik/system/BaseDexClassLoader.java">BaseDexClassLoader</a>，只是分别实现了自己的构造方法。那么我们自然对这个 BaseDexClassLoader 很感兴趣，看看它的构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BaseDexClassLoader</span><span class="params">(String dexPath, File optimizedDirectory, String librarySearchPath, ClassLoader parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(parent);</span><br><span class="line">        <span class="keyword">this</span>.pathList = <span class="keyword">new</span> DexPathList(<span class="keyword">this</span>, dexPath, librarySearchPath, optimizedDirectory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说下这个构造方法的几个参数：</p>
<ul>
<li>第一个参数指的是我们要加载的 dex 文件的路径，它有可能是多个 dex 路径，取决于我们要加载的 dex 文件的个数，多个路径之间用 <code>:</code> 隔开。</li>
<li>第二个参数指的是优化后的 dex 存放目录。实际上，dex 其实还并不能被虚拟机直接加载，它需要系统的优化工具优化后才能真正被利用。优化之后的 dex 文件我们把它叫做 odex （optimized dex，说明这是被优化后的 dex）文件。其实从 class 到 dex 也算是经历了一次优化，这种优化的是机器无关的优化，也就是说不管将来运行在什么机器上，这种优化都是遵循固定模式的，因此这种优化发生在 apk 编译。而从 dex 文件到 odex 文件，是机器相关的优化，它使得 odex 适配于特定的硬件环境，不同机器这一步的优化可能有所不同，所以这一步需要在应用安装等运行时期由机器来完成。需要注意的是，在较早版本的系统中，这个目录可以指定为外部存储中的目录，较新版本的系统为了安全只允许其为应用程序私有存储空间（<code>/data/data/apk-package-name/</code>）下的目录，一般我们可以通过 <code>Context#getDir(String dirName)</code> 得到这个目录。</li>
<li>第三个参数的意义是库文件的的搜索路径，一般来说是 <code>.so</code> 库文件的路径，也可以指明多个路径。</li>
<li>第四个参数就是要传入的父加载器，一般情况我们可以通过 <code>Context#getClassLoader()</code> 得到应用程序的类加载器然后把它传进去。</li>
</ul>
<p>这个构造函数的意义很简单，它做了两件事：连接了父加载器；构造了一个 <a href="http://androidxref.com/7.0.0_r1/xref/libcore/dalvik/src/main/java/dalvik/system/DexPathList.java">DexPathList</a> 实例保存在 <code>pathList</code> 中。这个 <code>pathList</code> 现在我们还不知道它是何方神圣，但是我们通过类名隐约的感觉到它保存了 Dalvik 虚拟机要加载的 dex 文件的路径，实际情况如何呢？我们看看这个类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DexPathList</span><span class="params">(ClassLoader definingContext, String dexPath,</span></span></span><br><span class="line"><span class="params"><span class="function">            String librarySearchPath, File optimizedDirectory)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (definingContext == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;definingContext == null&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dexPath == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;dexPath == null&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (optimizedDirectory != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (!optimizedDirectory.exists())  &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                       <span class="string">&quot;optimizedDirectory doesn&#x27;t exist: &quot;</span></span><br><span class="line">                       + optimizedDirectory);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (!(optimizedDirectory.canRead()</span><br><span class="line">                           &amp;&amp; optimizedDirectory.canWrite())) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                       <span class="string">&quot;optimizedDirectory not readable/writable: &quot;</span></span><br><span class="line">                       + optimizedDirectory);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">this</span>.definingContext = definingContext;</span><br><span class="line"></span><br><span class="line">       ArrayList&lt;IOException&gt; suppressedExceptions = <span class="keyword">new</span> ArrayList&lt;IOException&gt;();</span><br><span class="line">       <span class="comment">// save dexPath for BaseDexClassLoader</span></span><br><span class="line">       <span class="keyword">this</span>.dexElements = makeDexElements(splitDexPath(dexPath), optimizedDirectory,</span><br><span class="line">                              suppressedExceptions, definingContext);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// Native libraries may exist in both the system and</span></span><br><span class="line">       <span class="comment">// application library paths, and we use this search order:</span></span><br><span class="line">       <span class="comment">//</span></span><br><span class="line">       <span class="comment">//   1. This class loader&#x27;s library path for application libraries (librarySearchPath):</span></span><br><span class="line">       <span class="comment">//   1.1. Native library directories</span></span><br><span class="line">       <span class="comment">//   1.2. Path to libraries in apk-files</span></span><br><span class="line">       <span class="comment">//   2. The VM&#x27;s library path from the system property for system libraries</span></span><br><span class="line">       <span class="comment">//      also known as java.library.path</span></span><br><span class="line">       <span class="comment">//</span></span><br><span class="line">       <span class="comment">// This order was reversed prior to Gingerbread; see http://b/2933456.</span></span><br><span class="line">       <span class="keyword">this</span>.nativeLibraryDirectories = splitPaths(librarySearchPath, <span class="keyword">false</span>);</span><br><span class="line">       <span class="keyword">this</span>.systemNativeLibraryDirectories =</span><br><span class="line">               splitPaths(System.getProperty(<span class="string">&quot;java.library.path&quot;</span>), <span class="keyword">true</span>);</span><br><span class="line">       List&lt;File&gt; allNativeLibraryDirectories = <span class="keyword">new</span> ArrayList&lt;&gt;(nativeLibraryDirectories);</span><br><span class="line">       allNativeLibraryDirectories.addAll(systemNativeLibraryDirectories);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">this</span>.nativeLibraryPathElements = makePathElements(allNativeLibraryDirectories,</span><br><span class="line">                                                         suppressedExceptions,</span><br><span class="line">                                                         definingContext);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (suppressedExceptions.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">this</span>.dexElementsSuppressedExceptions =</span><br><span class="line">               suppressedExceptions.toArray(<span class="keyword">new</span> IOException[suppressedExceptions.size()]);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           dexElementsSuppressedExceptions = <span class="keyword">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个构造方法也很简单，这里我们主要看这几行代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.dexElements = makeDexElements(splitDexPath(dexPath), optimizedDirectory,</span><br><span class="line">                              suppressedExceptions, definingContext);</span><br><span class="line">...</span><br><span class="line"><span class="keyword">this</span>.nativeLibraryDirectories = splitPaths(librarySearchPath, <span class="keyword">false</span>);</span><br><span class="line"><span class="keyword">this</span>.systemNativeLibraryDirectories = </span><br><span class="line">                splitPaths(System.getProperty(<span class="string">&quot;java.library.path&quot;</span>), <span class="keyword">true</span>);</span><br><span class="line">List&lt;File&gt; allNativeLibraryDirectories = <span class="keyword">new</span> ArrayList&lt;&gt;(nativeLibraryDirectories);</span><br><span class="line">allNativeLibraryDirectories.addAll(systemNativeLibraryDirectories);</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.nativeLibraryPathElements = makePathElements(allNativeLibraryDirectories,</span><br><span class="line">                                          suppressedExceptions,</span><br><span class="line">                                          definingContext);</span><br></pre></td></tr></table></figure>

<p>这几行代码做的事也很清晰明了，就是给两个字段赋值。一个是 <code>dexElements</code>，另一个是 <code>nativeLibraryPathElements</code>。我们来看看这两个字段是怎么得到的：</p>
<ul>
<li><code>dexElements</code> 是通过 <code>makeDexElements()</code> 方法得到的，我们主要关注这个方法的前两个参数。第二个参数前面已经说了，是 dex 文件优化后的存放目录。第一个参数是通过 <code>splitDexPath()</code> 得到的，这个方法方法最终会调用 <code>splitPaths()</code>，所以我们看看 <code>splitPaths()</code> 是怎样的：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;File&gt; <span class="title">splitPaths</span><span class="params">(String searchPath, <span class="keyword">boolean</span> directoriesOnly)</span> </span>&#123;</span><br><span class="line">       List&lt;File&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (searchPath != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">for</span> (String path : searchPath.split(File.pathSeparator)) &#123;</span><br><span class="line">               <span class="keyword">if</span> (directoriesOnly) &#123;</span><br><span class="line">                   <span class="keyword">try</span> &#123;</span><br><span class="line">                       StructStat sb = Libcore.os.stat(path);</span><br><span class="line">                       <span class="keyword">if</span> (!S_ISDIR(sb.st_mode)) &#123;</span><br><span class="line">                           <span class="keyword">continue</span>;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125; <span class="keyword">catch</span> (ErrnoException ignored) &#123;</span><br><span class="line">                       <span class="keyword">continue</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               result.add(<span class="keyword">new</span> File(path));</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法做的事正如其名字所表达的，就是把用 <code>:</code> 分隔的路径分割后保存为 File 类型的列表返回。现在看看 <code>makeDexElements()</code> 这个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Element[] makeDexElements(List&lt;File&gt; files, File optimizedDirectory,</span><br><span class="line">                                            List&lt;IOException&gt; suppressedExceptions,</span><br><span class="line">                                            ClassLoader loader) &#123;</span><br><span class="line">     <span class="keyword">return</span> makeElements(files, optimizedDirectory, suppressedExceptions, <span class="keyword">false</span>, loader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就是利用已有参数简单调用了 <code>makeElements()</code>，其中，<code>ignoreDexFiles</code> 传入的是 <code>false</code>，<code>makeElements()</code> 的实现： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Element[] makeElements(List&lt;File&gt; files, File optimizedDirectory,</span><br><span class="line">                                          List&lt;IOException&gt; suppressedExceptions,</span><br><span class="line">                                          <span class="keyword">boolean</span> ignoreDexFiles,</span><br><span class="line">                                         ClassLoader loader) &#123;</span><br><span class="line">       Element[] elements = <span class="keyword">new</span> Element[files.size()];</span><br><span class="line">       <span class="keyword">int</span> elementsPos = <span class="number">0</span>;</span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * Open all files and load the (direct or contained) dex files</span></span><br><span class="line"><span class="comment">        * up front.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">           File zip = <span class="keyword">null</span>;</span><br><span class="line">           File dir = <span class="keyword">new</span> File(<span class="string">&quot;&quot;</span>);</span><br><span class="line">           DexFile dex = <span class="keyword">null</span>;</span><br><span class="line">           String path = file.getPath();</span><br><span class="line">           String name = file.getName();</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (path.contains(zipSeparator)) &#123;</span><br><span class="line">               String split[] = path.split(zipSeparator, <span class="number">2</span>);</span><br><span class="line">               zip = <span class="keyword">new</span> File(split[<span class="number">0</span>]);</span><br><span class="line">               dir = <span class="keyword">new</span> File(split[<span class="number">1</span>]);</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (file.isDirectory()) &#123;</span><br><span class="line">               <span class="comment">// We support directories for looking up resources and native libraries.</span></span><br><span class="line">               <span class="comment">// Looking up resources in directories is useful for running libcore tests.</span></span><br><span class="line">               elements[elementsPos++] = <span class="keyword">new</span> Element(file, <span class="keyword">true</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (file.isFile()) &#123;</span><br><span class="line">               <span class="keyword">if</span> (!ignoreDexFiles &amp;&amp; name.endsWith(DEX_SUFFIX)) &#123;</span><br><span class="line">                   <span class="comment">// Raw dex file (not inside a zip/jar).</span></span><br><span class="line">                   <span class="keyword">try</span> &#123;</span><br><span class="line">                       dex = loadDexFile(file, optimizedDirectory, loader, elements);</span><br><span class="line">                   &#125; <span class="keyword">catch</span> (IOException suppressed) &#123;</span><br><span class="line">                       System.logE(<span class="string">&quot;Unable to load dex file: &quot;</span> + file, suppressed);</span><br><span class="line">                       suppressedExceptions.add(suppressed);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   zip = file;</span><br><span class="line"></span><br><span class="line">                   <span class="keyword">if</span> (!ignoreDexFiles) &#123;</span><br><span class="line">                       <span class="keyword">try</span> &#123;</span><br><span class="line">                           dex = loadDexFile(file, optimizedDirectory, loader, elements);</span><br><span class="line">                       &#125; <span class="keyword">catch</span> (IOException suppressed) &#123;</span><br><span class="line">                           <span class="comment">/*</span></span><br><span class="line"><span class="comment">                            * IOException might get thrown &quot;legitimately&quot; by the DexFile constructor if</span></span><br><span class="line"><span class="comment">                            * the zip file turns out to be resource-only (that is, no classes.dex file</span></span><br><span class="line"><span class="comment">                            * in it).</span></span><br><span class="line"><span class="comment">                            * Let dex == null and hang on to the exception to add to the tea-leaves for</span></span><br><span class="line"><span class="comment">                            * when findClass returns null.</span></span><br><span class="line"><span class="comment">                            */</span></span><br><span class="line">                           suppressedExceptions.add(suppressed);</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               System.logW(<span class="string">&quot;ClassLoader referenced unknown path: &quot;</span> + file);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> ((zip != <span class="keyword">null</span>) || (dex != <span class="keyword">null</span>)) &#123;</span><br><span class="line">               elements[elementsPos++] = <span class="keyword">new</span> Element(dir, <span class="keyword">false</span>, zip, dex);</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="keyword">if</span> (elementsPos != elements.length) &#123;</span><br><span class="line">           elements = Arrays.copyOf(elements, elementsPos);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> elements;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法的名字也很好的说明了它要做的事，就是装配 <code>Element</code> 数组。装配 <code>Element</code> 数组的工作主要在 <code>for</code> 循环中，除了异常情况，它的每一次循环都构造了一个 <code>Element</code>。<code>Element</code> 是什么东西？你可以大概的把它理解为一个实体类。忽略异常情况，我们现在来分析这些 <code>Element</code> 是如何构造的，首先循环的开始部分定义了构造 <code>Element</code> 要用到的参数，然后对传入的每个 <code>File</code> 判断其类型：</p>
<ul>
<li><p>第一个判断我也没看太懂，不知道为什么这么做，好在这不是重点，我们往后看。</p>
</li>
<li><p>第二个判断是，如果文件是一个目录，那么直接把这个目录传入 <code>Element</code> 的构造方法构造一个 <code>Element</code>；如果不是就进行下一个判断。</p>
</li>
<li><p>第三个判断中又有两个判断：</p>
<ul>
<li>根据后缀看它是不是 dex 文件，如果是，那么就通过 <code>loadDexFile()</code> 来加载一个 <a href="http://androidxref.com/7.0.0_r1/xref/libcore/dalvik/src/main/java/dalvik/system/DexFile.java">DexFile</a> 对象（这个 <code>DexFile</code> 是什么我们等下再讲，你可以把它理解为一个对应着一个 dex 文件的对象）。如果成功加载了，那么就把它传入 <code>Element</code> 构造方法构造一个 <code>Element</code>。</li>
<li>如果不是 dex 文件，那么不管它什么后缀名，都把它看作是一个 zip，前提是它必须是一个 zip 格式的文件（如 zip，jar，apk），并且这个 zip 格式的文件必须要包含一个 dex 文件，同时这个文件须位于 zip 内部的根目录下。然后又会利用这个 zip 文件加载一个 <code>DexFile</code> 对象。最后将这个 zip 和连同加载出来的 <code>DexFile</code> 对象一起传入 <code>Element</code> 的构造方法构造一个 <code>Element</code> 对象。</li>
</ul>
</li>
</ul>
<p><code>Element</code> 数组的构造我们大概理解清楚了。现在看下 <code>loadDexFile()</code> 怎样加载 <code>DexFile</code> 的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> DexFile <span class="title">loadDexFile</span><span class="params">(File file, File optimizedDirectory, ClassLoader loader,</span></span></span><br><span class="line"><span class="params"><span class="function">                                      Element[] elements)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (optimizedDirectory == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">new</span> DexFile(file, loader, elements);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           String optimizedPath = optimizedPathFor(file, optimizedDirectory);</span><br><span class="line">           <span class="keyword">return</span> DexFile.loadDex(file.getPath(), optimizedPath, <span class="number">0</span>, loader, elements);</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先说明下，无论是 <code>DexFile(File file, Classloader loader, Elements[] elements)</code> 还是<br><code>DexFile.loadDex()</code> 最终都会调用 <code>DexFile(String sourceName, String outputName, int flags, ClassLoader loader, DexPathList.Element[] elements)</code> 这个构造方法。所以 <code>loadDexFile()</code> 这个方法的逻辑就是：如果 <code>optimizedDirectory</code> 为 null，那么就直接利用 dex 文件对应的 <code>file</code> 构造一个 <code>DexFile</code>；否则就根据要加载的 dex（或者包含了 dex 的 zip） 的文件名和优化后的 dex 存放的目录组合成优化后的 dex（也就是 odex）文件的输出路径，然后利用原始路径和优化后的输出路径构造出一个 <code>DexFile</code>。关于 <code>DexFile</code> 内部的细节到时候分析类加载过程的时候会讲，这里就不细说了。</p>
<p>通过前面的分析我们知道，我们可以知道 <code>dexElements</code> 主要作用就是用来保存和 dex 文件对应的 <code>DexFile</code> 对象的。 </p>
<ul>
<li><code>nativeLibraryPathElements</code> 产生的方法和 <code>pathList</code> 差不多，它保存的主要是本地方法库（本地方法库的存在形式一般是 <code>.so</code> 文件）对应的对象，包括应用程序的本地方法库和系统的本地方法库。这里就不对它过多讲解了。</li>
</ul>
<p>分析完这两字段，现在我们回过头来看看 <code>DexPathList</code> 这个对象，这个对象持有 <code>dexElements</code> 和 <code>nativeLibraryPathElements</code> 这两个属性，也就是说它保存了 dex 和 本地方法库。而 dex 保存着类的字节码信息，这样的话如果我们的类加载器要加载某个类的话，是不是只要操作这个对象就可以了呢？事实上的确如此，我们看看 <code>DexPathList</code> 的文档说明：</p>
<blockquote>
<p>A pair of lists of entries, associated with a {@code ClassLoader}.<br>One of the lists is a dex/resource path &mdash; typically referred<br>to as a “class path” &mdash; list, and the other names directories<br>containing native code libraries. Class path entries may be any of:<br>a {@code .jar} or {@code .zip} file containing an optional<br>top-level {@code classes.dex} file as well as arbitrary resources,<br>or a plain {@code .dex} file (with no possibility of associated<br>resources).</br>This class also contains methods to use these lists to look up<br>classes and resources.</p>
</blockquote>
<p>大概的意思就是 <code>DexPathList</code> 的作用和 JVM 中的 <code>classpath</code> 的作用类似，JVM 根据 <code>classpath</code> 来查找类，而 Dalvik 利用 <code>DexPathList</code> 来查找并加载类。<code>DexPathList</code> 包含的路径可以是 <code>.dex </code>文件的路径，也可以是包含了 dex 的 <code>.jar</code> 和 <code>.zip</code> 文件的路径。</p>
<p>对于类加载器的分析先到这里，现在我们看看 <code>BaseDexClassLoader</code> 是如何加载类的。</p>
<h3 id="BaseClassLoader-加载类的过程"><a href="#BaseClassLoader-加载类的过程" class="headerlink" title="BaseClassLoader 加载类的过程"></a>BaseClassLoader 加载类的过程</h3><p>我们知道，一个类加载器的入口方法是 <code>loadClass()</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String className, <span class="keyword">boolean</span> resolve) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        Class&lt;?&gt; clazz = findLoadedClass(className);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (clazz == <span class="keyword">null</span>) &#123;</span><br><span class="line">            ClassNotFoundException suppressed = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                clazz = parent.loadClass(className, <span class="keyword">false</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                suppressed = e;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (clazz == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    clazz = findClass(className);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                    e.addSuppressed(suppressed);</span><br><span class="line">                    <span class="keyword">throw</span> e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> clazz;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这个方法封装了委派式加载机制，所以一般不重写。<code>CLassLoader</code> 的子类通常重写 <code>findClass()</code> 来定义自己的类加载策略。<code>BaseDexClassLoader</code> 也继承自 <code>ClassLoader</code>，因此我们就从 <code>findClass()</code> 方法来分析下 <code>BaseClassLoader</code> 加载类的过程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">       List&lt;Throwable&gt; suppressedExceptions = <span class="keyword">new</span> ArrayList&lt;Throwable&gt;();</span><br><span class="line">       Class c = pathList.findClass(name, suppressedExceptions);</span><br><span class="line">       <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">           ClassNotFoundException cnfe = <span class="keyword">new</span> ClassNotFoundException(<span class="string">&quot;Didn&#x27;t find class \&quot;&quot;</span> + name + <span class="string">&quot;\&quot; on path: &quot;</span> + pathList);</span><br><span class="line">           <span class="keyword">for</span> (Throwable t : suppressedExceptions) &#123;</span><br><span class="line">               cnfe.addSuppressed(t);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">throw</span> cnfe;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法的重点就是 <code>Class c = pathList.findClass(name, suppressedException)</code>，<code>pathList</code> 很熟悉对不对？它就是前面分析的 <code>BaseDexClassLoader</code> 中的 <code>DexPathList</code> 对象。这里 <code>BaseClassLoader</code> 把查找类的任务委托给了 <code>pathList</code>。</p>
<p>我们看看 <code>DexPathList</code> 的 <code>findClass()</code> 对象做了哪些事：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Class <span class="title">findClass</span><span class="params">(String name, List&lt;Throwable&gt; suppressed)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">for</span> (Element element : dexElements) &#123;</span><br><span class="line">           DexFile dex = element.dexFile;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (dex != <span class="keyword">null</span>) &#123;</span><br><span class="line">               Class clazz = dex.loadClassBinaryName(name, definingContext, suppressed);</span><br><span class="line">               <span class="keyword">if</span> (clazz != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   <span class="keyword">return</span> clazz;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (dexElementsSuppressedExceptions != <span class="keyword">null</span>) &#123;</span><br><span class="line">           suppressed.addAll(Arrays.asList(dexElementsSuppressedExceptions));</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法的逻辑很清晰，它遍历了 <code>dexElements</code> 中的所有 <code>DexFile</code>，通过 <code>DexFile</code> 的 <code>loadClassBinaryName()</code> 方法加载目标类。可见，<code>dexElements</code> 又把查找类的任务委托给了 <code>DexFile</code>，看来 <code>DexFile</code> 这个对象的地位最低，大佬们都假装把活干完了，暗地里却把活丢给了它。前面说了，<code>DexFile</code> 对应着一个 dex 文件(或者包含 dex 文件的 zip 格式文件)，那么我们看看他是怎样在对应的 dex 文件中查找类的。</p>
<p>首先分析它的构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">DexFile</span><span class="params">(String sourceName, String outputName, <span class="keyword">int</span> flags, ClassLoader loader,</span></span></span><br><span class="line"><span class="params"><span class="function">           DexPathList.Element[] elements)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (outputName != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               String parent = <span class="keyword">new</span> File(outputName).getParent();</span><br><span class="line">               <span class="keyword">if</span> (Libcore.os.getuid() != Libcore.os.stat(parent).st_uid) &#123;</span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Optimized data directory &quot;</span> + parent</span><br><span class="line">                           + <span class="string">&quot; is not owned by the current user. Shared storage cannot protect&quot;</span></span><br><span class="line">                           + <span class="string">&quot; your application from code injection attacks.&quot;</span>);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">catch</span> (ErrnoException ignored) &#123;</span><br><span class="line">               <span class="comment">// assume we&#x27;ll fail with a more contextual error later</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       mCookie = openDexFile(sourceName, outputName, flags, loader, elements);</span><br><span class="line">       mFileName = sourceName;</span><br><span class="line">       <span class="comment">//System.out.println(&quot;DEX FILE cookie is &quot; + mCookie + &quot; sourceName=&quot; + sourceName + &quot; outputName=&quot; + outputName);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>估计你已经找到这个方法的重点了，没错，就是 <code>openDexFile()</code>，它最终会调用 <code>openDexFileNative()</code>，这家伙是个本地方法，我们就不<a href="http://blog.csdn.net/jltxgcy/article/details/50552674">深究</a>了。它做的事就是把对应的 dex 文件加载到内存中，然后返回给 Java 层一个 <code>Object:mCookie</code> 用来标识本次和 Java 层的交互，后续的操作包括从 dex 文件中加载目标类和关闭 <code>DexFile</code> 对象释放资源都用到了这个 <code>mCookie</code>。此外，这个本地方法还做了一件重要的事，那就是优化 dex 并将其输出到指定文件夹。</p>
<p>在构造方法中 <code>DexFile</code> 就完成了 dex 文件的加载过程。现在我们回到 <code>DexFile</code> 对象的 <code>loadClassBinaryName()</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Class <span class="title">loadClassBinaryName</span><span class="params">(String name, ClassLoader loader, List&lt;Throwable&gt; suppressed)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> defineClass(name, loader, mCookie, <span class="keyword">this</span>, suppressed);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Class <span class="title">defineClass</span><span class="params">(String name, ClassLoader loader, Object cookie,</span></span></span><br><span class="line"><span class="params"><span class="function">                                    DexFile dexFile, List&lt;Throwable&gt; suppressed)</span> </span>&#123;</span><br><span class="line">       Class result = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           result = defineClassNative(name, loader, cookie, dexFile);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (NoClassDefFoundError e) &#123;</span><br><span class="line">           <span class="keyword">if</span> (suppressed != <span class="keyword">null</span>) &#123;</span><br><span class="line">               suppressed.add(e);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">           <span class="keyword">if</span> (suppressed != <span class="keyword">null</span>) &#123;</span><br><span class="line">               suppressed.add(e);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>终于看到了尽头，没错，class 对象在 java 层加载过程的尽头就是这个 <code>defineClass()</code> 方法。这个方法调用本地方法 <code>defineClassNative()</code> 从 dex 中查找目标类，如果找到了，就把这个代表这个类的 <code>Class</code> 对象返回。至此，Dalvik 虚拟机加载类的整个过程就结束了。现在我们回过头看看 <code>DexClassLoader()</code> 和 <code>PathClassLoader()</code>，这两个类加载器的唯一区别就是前者指定了优化后的 dex 文件的输出路径，后者没有指定。也就这一点差异造成了它们不同的使用场景：<code>DexClassLoader</code> 用来加载 .dex 文件以及包含 dex 文件的 .jar、.zip 和未安装的 .apk 文件，因此需要指定优化后的 dex 文件的输出路径；<code>PathClassLoader</code> 一般用来加载已经安装到设备上的 <code>.apk</code>，因为应用在安装的时候已经对 apk 文件中的 dex 进行了优化，并且会输出到 <code>/data/dalvik-cache</code> 目录下（android M 在这目录下找不到，应该是改成了 <code>/data/app/com.example.app-x/oat</code> 目录下），所以它不需要指定优化后 dex 的输出路径。下面用一张图来总结下安卓的类加载机制：</p>
<p><img src="/img/in-post/post_android_load_class_dynamically/android-load-class-dynamically-2.png"></p>
<p>对这个模型作一下说明：</p>
<ul>
<li><p><code>BootClassLoader</code> 是顶级的类加载器，这个类加载器在系统启动时就已经建立了，整个系统只有一个实例，它用来加载安卓核心类库。</p>
</li>
<li><p><code>PathClassLoader</code> 是每个应用进程的 Dalvik 虚拟机私有的类加载器，在应用启动时创建。它的 <code>DexPathList</code> 的 dex 加载路径是 <code>/data/app/apk-package-name-x/base.apk</code>（android M），用来加载我们已安装应用的 apk 中的 dex 文件。我们在应用中编写的的类默认是委托此类加载。</p>
</li>
<li><p>Custom ClassLoader，这是开发人员自己实现的类加载器，通常是 <code>PathClassLoader</code> 或者 <code>DexClassLoader</code>。如果使用前者通常用来加载已经安装过的插件 apk 中的 dex 文件，如果使用后者通常用来加载 <code>.dex</code> 文件以及包含 dex 的 <code>.jar</code>、<code>.zip</code> 和 未安装的 <code>.apk</code> 文件。</p>
</li>
<li><p>我们可以做如下类比：</p>
<ul>
<li>把 <strong>Dalvik</strong> 类比于 <strong>JVM</strong></li>
<li>把 <strong>dex</strong> 文件 类比于 <strong>class</strong> 文件</li>
<li>把 <strong>dex 文件的路径（<code>DexPathList</code>）</strong> 类比于 <strong>类加载路径（<code>classpath</code>）</strong> 。</li>
</ul>
</li>
</ul>
<p>相信现在大家对安卓的类加载机制有了大概的了解，为了避免文章篇幅过长，我打算把动态加载在安卓中的应用放在下一篇博客当中，感谢大家的阅读。</p>
]]></content>
      <tags>
        <tag>Android</tag>
        <tag>动态加载</tag>
      </tags>
  </entry>
  <entry>
    <title>命令行编译制作一个 Java 程序</title>
    <url>/2016/11/05/2016-11-5-compile-java-through-command-line/</url>
    <content><![CDATA[<h1 id="命令行编译制作一个-Java-程序"><a href="#命令行编译制作一个-Java-程序" class="headerlink" title="命令行编译制作一个 Java 程序"></a>命令行编译制作一个 Java 程序</h1><p>和很多同学一样，一开始学 java 都是用 Eclipse、intellij 等 IDE 来写 java 程序的，这些 IDE 极大的简化了开发流程，很多工作都在不知不觉中帮我们做好了。出于好奇，在网上查阅各种资料后，决定自己动手用最原始的方式————命令行，编译并打包一个 hello world。</p>
<span id="more"></span>

<h2 id="第一步：编写源代码"><a href="#第一步：编写源代码" class="headerlink" title="第一步：编写源代码"></a>第一步：编写源代码</h2><p>因为是一个 hello world，用记事本来写也没任何问题。<br>首先我们在桌面创建项目文件夹 <code>HelloWorld</code>，在里面新建一个包名为 <code>xyz.lwenkun</code>，然后在该包下编写如下程序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.lwenkun;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.lib;</span><br><span class="line"><span class="comment">//Example.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      Lib lib = <span class="keyword">new</span> Lib();</span><br><span class="line">      lib.print();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时在桌面新建一个包 ”com.lib“，在里面编写 <code>Lib.java</code> 作为我们 HelloWorld 要依赖的类： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lib</span><br><span class="line"><span class="comment">//Lib.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lib</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="第二步：编译"><a href="#第二步：编译" class="headerlink" title="第二步：编译"></a>第二步：编译</h2><p>源码准备好后，就开始编译工作了，编译源码需要用到 <code>javac</code> 命令，使用方法是 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javac &lt;options&gt; &lt;source-files&gt;</span><br></pre></td></tr></table></figure>

<p>因为我们的项目依赖于 <code>Lib</code> 这个类，所以我们首先把这个类编译好：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javac /Users/lwenkun/desktop/com/lib/Lib.java</span><br></pre></td></tr></table></figure>

<p>然后再编译主类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">javac -cp /Users/lwenkun/desktop /Users/lwenkun/desktop/HelloWorld/xyz/lwenkun/Example.java</span><br></pre></td></tr></table></figure>

<p>不同于编译 <code>Lib</code> 类，这里我们用到了 <code>-cp</code> 选项。其中 <code>-cp</code> 是 <code>-classpath</code> 的简写，<code>-classpath</code> 后面指定的一般是被引用的类所属类包所在的目录或者所在 jar 包的路径（我们称其为 <code>classpath</code>），编译时或者运行时 JVM 的<strong>系统类加载器</strong>就要用到 <code>classpath</code> 变量来搜索目标类。注意这个变量指明的是类所属<strong>类包所在的目录</strong>或者<strong>所在 jar 包的路径</strong>而不是<strong>具体类的路径</strong>。比如在编译某个类时要引用另一个类 <code>Lib1</code>，这个类在类包 <code>com.example1</code> 中，而这个类包又在 <code>/Users/lwenkun/desktop/package-dir1</code> 目录下 ，那么我只需指定 <code>classpath</code> 为 <code>/Users/lwenkun/desktop/package-dir1</code> 就可以了。当然在实际情况中一个类引用到的类有很多，如果这些被引用的类(1)在同一个包下(2)或者它们所属类包在同一目录下(3)或者在同一 jar 包内，<code>classpath</code> 自然就为同一个值，那就不需要重复指定了。但是如果它们(1)在不同的包里而且这些类包位于不同的目录下(2)或者在不同的 jar 包内，比如我还要引用一个类 <code>Lib2</code>，它在一个名为 <code>com.example2</code> 的类包下，这个类包又位于 <code>/Users/lwenkun/desktop/package-dir2</code> 目录下，那么就要指定多个 <code>classpath</code> 了，这些 <code>classpath</code> 之间用 <code>:</code> （macOSx、Linux、Unix）或者 <code>;</code> （Windows）隔开，如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">javac -cp /Users/lwenkun/desktop/<span class="keyword">package</span>-dir1:/Users/lwenkun/desktop/<span class="keyword">package</span>-dir2 ClassToBeCompiled.java</span><br></pre></td></tr></table></figure>

<p>关于 <code>classpath</code> 的更多解释，可以看看<a href="http://developer.51cto.com/art/201209/357217.htm">这篇文章</a>。要注意的是：如果不指定的话，classpath 的默认值是 <code>.</code>，代表的就是当前的用户目录；如果用户指定了那这个默认值就会被清除。</p>
<p>在我们的 HelloWorld 项目中，我们用到了位于桌面的 <code>com.lib</code> 包中的 <code>Lib</code> 类，所以我们需要指定的 <code>classpath</code> 当然是 <code>／Users/lwenkun/desktop</code> 了。</p>
<p>执行完后这两个编译命令后会分别在各自源文件所在目录生成 java 字节码文件 <code>Example.class</code> 和 <code>Lib.class</code>。源文件现在已经没用了，我们把源文件移除，只留下 <code>Example.class</code> 和 <code>Lib.class</code>。</p>
<p>实际上编译完之后就可以运行了，运行 java 字节码的命令是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java &lt;options&gt;  &lt;main-class&gt; [args...]</span><br></pre></td></tr></table></figure>

<p>这里我们运行的命令是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java -cp /Users/lwenkun/desktop:/Users/lwenkun/desktop/HelloWorld xyz.lwenkun.Example</span><br></pre></td></tr></table></figure>

<p>发现和编译时格式差不多，<code>-cp</code> 后面指定的是运行时的 <code>classpath</code>, 虚拟机此时会根据这个值查找目标类。要注意的就是最后面的类名是主类的全限定名，比如我们的主类的全限定名就为 <code>xyz.lwenkun.Example</code>。系统查找类会根据类包所在目录结合类的全限定名来定位具体的类。来说下这条命令做了些什么：首先当然是启动 java 虚拟机，然后查找指定的主类，依据什么来查找呢？当然就是前面指定的 <code>classpath</code>，先在第一个目录下找，根据全限定名，类的位置应该是 <code>/Users/lwenkun/desktop/xyz/lwenkun/Example</code>，发现找不到，再用同样的方法在第二个目录中找，这时候类的位置应该是 <code>/Users/lwenkun/desktop/HelloWorld/xyz/lwenkun/Example</code>，发现找到了，那么就加载这个类并执行这个类的 <code>mian()</code> 方法。<code>main()</code> 方法中又用到了 <code>Lib</code> 这个类，它在 <code>Example</code> 中的声明是 <code>com.lib.Lib</code>，类加载器又用类似方法开始查找 <code>Lib</code> 类，发现在第一个目录中找到了该类，那么就把它加载到内存当中。这里省略了很多细节，关于系统查找类的详细说明，可以看看<a href="http://docs.oracle.com/javase/6/docs/technotes/tools/findingclasses.html">这篇文章</a>。</p>
<p>命令的运行结果是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hello world</span><br></pre></td></tr></table></figure>

<h2 id="第三步：打包"><a href="#第三步：打包" class="headerlink" title="第三步：打包"></a>第三步：打包</h2><p>打包就是我们的项目打包成 jar 包，jar 包是一种 zip 格式的文件，从结构上来看我们可以简单的理解为 jar 包就是把几个类包压缩在一起。常见的 jar 包有两种：一种作为其他程序的依赖库，没有主类；另一种是作为可执行的程序，有主类，用鼠标点击就可以运行。我们的项目包含主类，因此我们把它打包成可执行的 jar 包。关于 jar 包更深入的分析可以看看<a href="https://www.ibm.com/developerworks/cn/java/j-jar/">这篇文章</a>。jar 文件构大致如下：</p>
<p> <img src="/img/in-post/post_compile_java_through_command_line/structure_of_jar.png"></p>
<p> 不管是哪种 jar 包，它们都有一个 <code>META-INF</code> 目录，下面有一个 <code>MANIFEST.MF</code> 文件，这个文件是个清单，记录着 jar 包相关的一些属性，常用的如 <code>Main-Class</code> 和 <code>Class-Path</code>，前者指定主类，也就是程序的入口点，后者的作用和命令行中的 <code>-cp</code> 是同样的含义，用来指定引用到的类所属类包所在的目录或者所在的 jar 包路径。如果打包时我们不指明清单文件那么打包工具会生成一个默认的清单添加到 jar 包中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Manifest-Version: 1.0</span><br><span class="line">Created-By: 1.8.0_101 (Oracle Corporation)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>默认的清单中没有 <code>Main-Class</code> 和 <code>Class-Path</code> 等属性，如果需要这些属性我们必须自己添加。添加方法是新建一个 <code>MANIFEST.txt</code> 文件(文件名和后缀不重要)，用文本编辑器打开，在里面添加某些属性：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">属性名1: 属性值1</span><br><span class="line">属性名2: 属性值2</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>到时候我们就能通过打包命令把这个文件中的属性追加到默认的清单文件中了。如果有和默认属性名称相同的属性，会将默认属性覆盖掉。</p>
<p>打包用到的命令是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">jar &#123;ctxui&#125;[vfmn0PMe] [jar-file] [manifest-file] [entry-point] [-C dir] files ...</span><br></pre></td></tr></table></figure>

<p>其中 <code>jar-file</code> 是输出的 jar 包的文件名，<code>manifest-file</code> 是清单文件的名称（如果有的话），<code>files...</code> 是指若干要打包的 Class 文件。</p>
<p>介绍几种比较简单的打包方式（<a href="http://www.jianshu.com/p/61cfa1347894">更多 jar 相关命令</a>）：</p>
<ul>
<li>使用默认清单文件和几个类包创建一个 jar 文件</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jar cf class.jar package-root-dirs...</span><br></pre></td></tr></table></figure>

<ul>
<li>使用现有清单文件和几个类包创建一个 jar 文件</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jar cfm class.jar mainfest-file package-root-dirs...</span><br></pre></td></tr></table></figure>

<ul>
<li>使用现有的清单文件并用 <code>foo</code> 目录下的所有包创建一个 jar 文件</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jar cvfm classes.jar manifest-file -C foo/ .</span><br></pre></td></tr></table></figure>

<p>其中，<code>package-root-dir</code> 指的是包的根目录，例如，在我们的项目中就是 <code>/Users/lwenkun/desktop/HelloWorld/xyz</code>。<code>foo</code> 就是包所在的目录，在我们的项目中就是 <code>/Users/lwenkun/desktop/HelloWorld</code>。</p>
<p>我们先将依赖类所在包的打成 <code>lib.jar</code> ：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jar cf lib.jar /Users/lwenkun/desktop/com</span><br></pre></td></tr></table></figure>

<p>然后把生成的 <code>lib.jar</code> 放在 <code>HelloWorld</code> 文件夹的 <code>lib</code> 文件夹中。</p>
<p>对于主项目，因为我们的项目有主类，所以要声明 <code>Main-Class</code> 属性；又因为我们的项目有要依赖的类，并且我们要依赖的类的类包没有和我们的主项目的类包在同一目录下，所以要声明 <code>Class-Path</code> 属性。因此我们要创建包含如下内容的清单文件 <code>MANIFEST.txt</code>（文件名和后缀不重要，只要是文本类型的）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Main-Class: xyz.lwenkun.Example</span><br><span class="line">Class-Path: lib/lib.jar</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这样打包时文件中的这些属性就会追加到默认清单文件中了。根据前面我们对 <code>classpath</code> 的解释，如果我们的项目依赖的类分别处于三个 jar 包和一个类包中，其中 jar 包位于 <code>lib</code> 目录下，名称分别为 <code>lib1.jar</code>、<code>lib2.jar</code> 和 <code>lib3.jar</code>，类包位于桌面（<code>desktop</code>），那么我们的清单内容就应该是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Main-Class: xyz.lwenkun.Example</span><br><span class="line">Class-Path: lib/lib1.jar lib/lib2.jar</span><br><span class="line"> lib/lib3.jar /Users/lwenkun/desktop</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>Class-path</code> 前三项指定的是 jar 包的路径（相对），最后一项指定的是类包所在目录（绝对）。</p>
<p>注意几点：</p>
<ul>
<li><code>MANIFEST</code> 清单的格式是 <code>key: value</code>，冒号后面还有一个空格（如上）</li>
<li>依赖库之间通过空格来分隔</li>
<li>每行一个属性，但是如果我们依赖的库太多了，可以转行，但是行首要加个空格（如上）</li>
<li>最后，也是最容易忽视的一点，最后一个属性写完后要连续回车两次作为结束。否则，最后一行属性会被丢弃</li>
</ul>
<p>现在我们来打包主项目中的类包：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">jar cfm helloworld.jar MANIFEST.txt /Users/lwenkun/desktop/HelloWorld/xyz</span><br></pre></td></tr></table></figure>

<p>这样我们就在当前目录下(项目根目录 <code>HelloWorld</code>)生成了一个 <code>helloworld.jar</code>。把类包打包后，类包对于我们来说已经没用了，可以都移除掉。现在我们用命令行运行这个程序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java -jar /Users/lwenkun/desktop/HelloWorld/helloworld.jar</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hello world</span><br></pre></td></tr></table></figure>

<p>这里是通过 jar 包来执行我们的程序，因为 jar 包中指定了 <code>Main-Class</code>，所以 JVM 就能找到相应的主类并执行；同时在 <code>MANIFEST.MF</code> 中我们指定了 <code>Class-Path</code>，把我们依赖的 jar 包的相对路径添加进去了，所以要用到依赖类的时候，JVM 也能根据这个相对路径和依赖类的全限定名定位到依赖类。</p>
<p>如果我们打包时忘记了添加 <code>Main-Class</code> 这个属性怎么办呢？当然最好的方式是重新打包。当然你说你就不想重新打包，那也行，那么执行方式就是这样的了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java -cp /Users/lwenkun/desktop/HelloWorld/helloworld.jar xyz.lwenkun.Example</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hello world</span><br></pre></td></tr></table></figure>

<p>这里把主项目的 jar 包的路径添加进 <code>classpath</code>，然后在后面指明主类。前面说了 <code>classpath</code> 指明的是类包所在目录，也可以是类所在 jar 包的路径。其实你可能已经明白，类包目录和 jar 包路径其实是同一回事，它们都是类包的容器。</p>
<p>我们的程序有依赖库(<code>/Users/lwenkun/desktop/HelloWorld/lib/lib.jar</code>)，如果你又忘记添加 <code>Class-Path</code> 属性又该怎么办？可能你已经知道方法了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java -cp /Users/lwenkun/desktop/HelloWorld/helloworld.jar:/Users/lwenkun/desktop/HelloWorld/lib/lib.jar xyz.lwenkun.Example</span><br></pre></td></tr></table></figure>

<p>我们把依赖类所在 jar 包的路径添加到 <code>classpath</code> 中，这样的话，虽然 <code>MANIFEST.MF</code> 中没有声明我们程序依赖的 jar 包路径，JVM 照样能够根据 <code>-cp</code> 指定的路径找到我们的依赖类。</p>
<p>参考资料：</p>
<ul>
<li><a href="http://www.360doc.com/content/10/1006/17/61497_58863251.shtml">MANIFEST.MF中的格式问题</a></li>
<li><a href="http://developer.51cto.com/art/201209/357217.htm">Java环境变量Classpath</a></li>
<li><a href="http://www.cnblogs.com/lleid/archive/2013/03/21/java.html">命令行执行Java文件</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/java/j-jar/">JAR 文件揭密</a></li>
</ul>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>安卓应用获取系统服务的过程</title>
    <url>/2016/12/05/2016-12-05-how-android-apps-get-system-services/</url>
    <content><![CDATA[<h1 id="安卓应用获取系统服务的过程"><a href="#安卓应用获取系统服务的过程" class="headerlink" title="安卓应用获取系统服务的过程"></a>安卓应用获取系统服务的过程</h1><p>在安卓系统中存在着各种各样的系统服务， 例如 <a href="http://androidxref.com/7.0.0_r1/xref/frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java"><code>ActivityManagerService</code></a>, <a href="http://androidxref.com/7.0.0_r1/xref/frameworks/base/services/core/java/com/android/server/wm/WindowManagerService.java"><code>WindowManagerService</code></a>, <a href="http://androidxref.com/7.0.0_r1/xref/frameworks/base/services/core/java/com/android/server/clipboard/ClipboardService.java"><code>ClipboardService</code></a> 等。这些系统服务大都运行在进程 system_server 中，为每个应用提供服务。而应用程序运行于自己的默认进程当中，因此，想要获取系统服务，必定需要进行进程间的通信。而安卓中的进程间通信大多通过 <code>Binder</code> 机制进行，因此，要想深入理解应用是如何获取的系统服务的，必须先要了解安卓的 <code>Binder</code> 机制。如果对 <code>Binder</code> 机制不太了解的同学可以参考我的<a href="/2016/10/28/android-IPC-AIDL">这篇博客</a>。</p>
<span id="more"></span>
<p>安卓中的系统服务作用各不相同，所以，如果对每个服务的内部细节做过多的探讨，不利于我们从宏观的角度去理解安卓的系统服务的大致原理。如果你想知道各个服务的具体实现，那么这篇文章并不适合你。</p>
<h2 id="Context-getSystemService"><a href="#Context-getSystemService" class="headerlink" title="Context#getSystemService"></a>Context#getSystemService</h2><p>大家对这方法应该很熟悉了，开发应用的时候我们就是通过这个接口获取系统服务的。系统设计人员总是想为应用开发者提供各种便利，减轻他们的负担。以至于对于开发者来说，系统服务的获取简单得用一行代码就能搞定。那么，我们看看系统到底是如何简化服务的获取过程的。首先从这个方法入手：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getSystemService</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> SystemServiceRegistry.getSystemService(<span class="keyword">this</span>, name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它的实现也是如此简单，以至于我们必须转入 <code>SystemServiceRegistry</code> 一探究竟。</p>
<h2 id="SystemServiceRegistry"><a href="#SystemServiceRegistry" class="headerlink" title="SystemServiceRegistry"></a>SystemServiceRegistry</h2><p>源码太多，我就不贴出来了，大家点击<a href="http://androidxref.com/7.0.0_r1/xref/frameworks/base/core/java/android/app/SystemServiceRegistry.java">这里</a>自己看看。</p>
<p>这个类逻辑很简洁，它最引人注目的地方就是开头的那一大坨静态初始化代码块。这块代码异常整齐，清一色的 <code>registerService()</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">......</span><br><span class="line"></span><br><span class="line">registerService(Context.WIFI_SERVICE, WifiManager.class,</span><br><span class="line">                <span class="keyword">new</span> CachedServiceFetcher&lt;WifiManager&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> WifiManager <span class="title">createService</span> <span class="params">(ContextImpl ctx)</span></span>&#123;</span><br><span class="line">        IBinder b = ServiceManager.getService(Context.WIFI_SERVICE);</span><br><span class="line">        IWifiManager service = IWifiManager.Stub.asInterface(b);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> WifiManager(ctx.getOuterContext(), service,</span><br><span class="line">                ConnectivityThread.getInstanceLooper());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">registerService(Context.WIFI_P2P_SERVICE, WifiP2pManager.class,</span><br><span class="line">                <span class="keyword">new</span> StaticServiceFetcher&lt;WifiP2pManager&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> WifiP2pManager <span class="title">createService</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        IBinder b = ServiceManager.getService(Context.WIFI_P2P_SERVICE);</span><br><span class="line">        IWifiP2pManager service = IWifiP2pManager.Stub.asInterface(b);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> WifiP2pManager(service);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<p>我们似乎明白，这里注册了一系列的系统服务。而且因为是写在静态代码块中，所以在类加载的时候这些服务就注册了。但是，为什么要对这些系统服务进行注册呢？且看 <code>registerService()</code> 这个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Statically registers a system service with the context.</span></span><br><span class="line"><span class="comment"> * This method must be called during static initialization only.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">registerService</span><span class="params">(String serviceName, Class&lt;T&gt; serviceClass,</span></span></span><br><span class="line"><span class="params"><span class="function">                                       ServiceFetcher&lt;T&gt; serviceFetcher)</span> </span>&#123;</span><br><span class="line">        SYSTEM_SERVICE_NAMES.put(serviceClass, serviceName);</span><br><span class="line">        SYSTEM_SERVICE_FETCHERS.put(serviceName, serviceFetcher);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>又一个陌生的类 <code>ServiceFetcher</code> 出现了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">interface</span> <span class="title">ServiceFetcher</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">       <span class="function">T <span class="title">getService</span><span class="params">(ContextImpl ctx)</span></span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个接口定义了 <code>getService()</code> 这个方法，从名字也能看出，它是用来获取服务的。因此我们有理由推断，这个接口就相当于一个服务获取策略。获取服务时，通过调用这个接口的 <code>getService()</code> 方法就能得到相应的服务。因此，<code>registerService()</code> 这个方法并没有将真正的服务注册进去，而是注册了一个服务获取策略。因为各种服务的获取策略不尽相同，系统定义了三种实现 <code>ServiceFetcher</code> 接口的抽象类，它们分别是 <code>CachedServiceFetcher</code>，<code>StaticServiceFetcher</code> 和 <code>StaticApplicationContextServiceFetcher</code>，简单说明一下这三个类：</p>
<ul>
<li>CachedServiceFetcher</li>
</ul>
<p><code>CachedServiceFetcher</code> 获取服务的策略是：先从缓存数组中找，如果找到就将其返回；如果没有，那就创建一个服务，缓存之后再将其返回。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CachedServiceFetcher</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">ServiceFetcher</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> mCacheIndex;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CachedServiceFetcher</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mCacheIndex = sServiceCacheSize++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> T <span class="title">getService</span><span class="params">(ContextImpl ctx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Object[] cache = ctx.mServiceCache;</span><br><span class="line">        <span class="keyword">synchronized</span> (cache) &#123;</span><br><span class="line">            <span class="comment">// Fetch or create the service.</span></span><br><span class="line">            Object service = cache[mCacheIndex];</span><br><span class="line">            <span class="keyword">if</span> (service == <span class="keyword">null</span>) &#123;</span><br><span class="line">                service = createService(ctx);</span><br><span class="line">                cache[mCacheIndex] = service;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> (T)service;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> T <span class="title">createService</span><span class="params">(ContextImpl ctx)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ul>
<li>StaticServiceFetcher</li>
</ul>
<p><code>StaticServiceFetcher</code> 获取服务的策略是：用一个 <code>mCachedInstance</code> 的成员变量作为缓存来保存服务，如果这个变量不为空就直接返回；否则就创建一个服务，缓存至这个变量后返回。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticServiceFetcher</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">ServiceFetcher</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T mCachedInstance;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> T <span class="title">getService</span><span class="params">(ContextImpl unused)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (StaticServiceFetcher.<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mCachedInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                mCachedInstance = createService();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> mCachedInstance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> T <span class="title">createService</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ul>
<li>StaticApplicationContextServiceFetcher</li>
</ul>
<p><code>StaticApplicationContextServiceFetcher</code> 获取服务的策略和 <code>StaticServiceFetcher</code> 是一样的，就不赘述了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticApplicationContextServiceFetcher</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">ServiceFetcher</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T mCachedInstance;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> T <span class="title">getService</span><span class="params">(ContextImpl ctx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (StaticApplicationContextServiceFetcher.<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mCachedInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                mCachedInstance = createService(appContext != <span class="keyword">null</span> ? appContext : ctx);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> mCachedInstance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> T <span class="title">createService</span><span class="params">(Context applicationContext)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>我们会发现，这三个抽象类有一个共同的特点，那就是它们都是用缓存策略实现了 <code>getService()</code> 这个方法，同时抽离出 <code>CreateServiceFetcher()</code> 这个抽象方法。这之中的意图可想而知，就是让子类只需关注如何将这个服务创建出来，不需要关注这个服务的缓存策略，因为缓存策略父类们都已经帮它们实现了。</p>
<p>需要注意的是，<code>CachedServiceFetcher</code> 将获取过的服务缓存在 <code>Context</code> 的 <code>mServiceCache</code> 这个对象中，这个对象是一个 <code>Object</code> 类型的数组。你可能会问，为什么选择用数组来缓存，数组的容量是固定的，你怎么知道要缓存多少服务。我们看看 <code>Context</code> 的 <code>mServiceCache</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Object[] mServiceCache = SystemServiceRegistry.createServiceCache();</span><br></pre></td></tr></table></figure>

<p>又回到了 <code>SystemServiceRegister</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object[] createServiceCache() &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> Object[sServiceCacheSize];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果发现这个数组的大小为 <code>sServiceCacheSize</code>，<code>sServiceCacheSize</code> 在上面 <code>CachedServiceFetcher</code> 的构造函数中进行了自增运算，而 <code>CachedServiceFetcher</code> 是在注册的时候创建的，因此注册了多少个 <code>CachedServiceFetcher</code>，<code>cache</code> 就有多大，因此我们不必担心缓存空间不够用。</p>
<p>貌似有点扯远了，现在我们回过头来分析 <code>registerService()</code>，发现它就做了两件事：</p>
<ul>
<li>把该服务的 <code>class</code> 对象和服务名对应起来</li>
<li>把该服务的服务名和获取该服务的策略对应起来</li>
</ul>
<p>服务获取策略注册完了，那么你自然会问，怎样通过这个策略获取服务呢？现在我们来看看 <code>SystemServiceRegistry</code> 的 <code>getSystemService()</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getSystemService</span><span class="params">(ContextImpl ctx, String name)</span> </span>&#123;</span><br><span class="line">    ServiceFetcher&lt;?&gt; fetcher = SYSTEM_SERVICE_FETCHERS.get(name);</span><br><span class="line">    <span class="keyword">return</span> fetcher != <span class="keyword">null</span> ? fetcher.getService(ctx) : <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这就印证了我们之前的推断。获取系统服务时，先通过注册时的对应好的关系找出这个服务对应的服务获取策略（也就是 <code>ServiceFetcher</code> 对象），然后调用这个服务的获取策略的 <code>getService()</code> 方法获取这个服务。前面分析了，三种 <code>ServiceFetcher</code> 获取服务的策略都是先从缓存中找，如果没有就创建一个。那么服务是怎样创建的呢？如果你仔细观察过那一系列的 <code>registerService()</code>，就会发现大多数服务是这样创建的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">IBinder b = ServiceManager.getService(service_name);</span><br><span class="line">ServiceInterface service = ServiceInterface.Stub.asInterface(b);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> xxxManager(ctx, ServiceInterface);</span><br></pre></td></tr></table></figure>

<p>有没有种似曾相识的感觉？这和我们使用 AIDL 实现进程间通信时客户端的行为是一样的：</p>
<ul>
<li>获取服务端传过来的 <code>Binder</code>（对于进程间通信，其实它是一个 <code>BinderProxy</code> 对象）</li>
<li>将这个 <code>Binder</code> 通过 <code>asInterface()</code> 转换成相应 AIDL 接口的客户端代理</li>
</ul>
<p>我们知道，<code>Binder</code> 的作用相当于一把钥匙，客户端拿到这个 <code>Binder</code> 用 <code>asInterface()</code> 将其转换成相应 AIDL 接口的客户端代理后就可以 “随意使唤” 服务端了。只不过在这里是服务接口(如 <code>IActivityManager</code>，<code>IWindowManager</code>)而不是 AIDL 接口，并且在服务接口的客户端代理上又包装了一层，但实际上还是通过操作代理对象进行进程间通信的。</p>
<p>我们发现所有服务的客户端 <code>Binder</code>（<code>BinderProxy</code>） 都来自于 <code>ServiceManager</code>，看来这个类就是我们接下来要研究的重点。那么有请 <code>ServiceManager</code> 登场。</p>
<h2 id="ServiceManager"><a href="#ServiceManager" class="headerlink" title="ServiceManager"></a>ServiceManager</h2><p>不用我过多解释估计你也明白这个类的作用，它就是服务的管理类。安卓的系统服务种类繁多，自然需要一个管理者对它们进行统一的管理，<code>ServiceManager</code> 就充当了这样一个角色。那么，它是怎样对那些系统服务进行管理的呢？我们可以看看它的<a href="http://androidxref.com/7.0.0_r1/xref/frameworks/base/core/java/android/os/ServiceManager.java">源码</a>。源码不多，我们首先看看这个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IBinder <span class="title">getService</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        IBinder service = sCache.get(name);</span><br><span class="line">        <span class="keyword">if</span> (service != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> service;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> getIServiceManager().getService(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        Log.e(TAG, <span class="string">&quot;error in getService&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法的作用很明显，就是根据服务名获取一个服务对应的客户端 <code>Binder</code>（<code>BinderProxy</code>）对象。获取 <code>Binder</code> 的过程是先从缓存 <code>sCache</code> 中查找是否存在缓存过的 <code>Binder</code> 对象，不存在就通过 <code>getIServiceManager().getService(name)</code> 来获取并返回。这里我们只对 <code>sCache</code> 和 <code>getIServiceManager()</code> 感兴趣。先看 <code>sCache</code>：</p>
<ul>
<li>sCache</li>
</ul>
<p>通过上面的代码我们发现，当缓存中没有需要的 <code>Binder</code>（<code>BinderProxy</code>）时，会通过 <code>getIServiceManager().getService()</code> 获取，但是我们并没有把获取到的 <code>Binder</code>（<code>BinderProxy</code>） 进行缓存，这样一来，<code>sCache</code> 岂不是一直都是空的？我们看看它是怎样得到的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initServiceCache</span><span class="params">(Map&lt;String, IBinder&gt; cache)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sCache.size() != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;setServiceCache may only be called once&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sCache.putAll(cache);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么我们只要找到 <code>initServiceCache()</code> 的调用者就可以知道 <code>sCache</code> 是怎样被初始化的。在源码中遨游一小阵子之后发现最终它是这样被初始化的（<a href="http://androidxref.com/7.0.0_r1/xref/frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java#getCommonServicesLocked">ActivityManagerService#getCommonServicesLocked</a>）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> HashMap&lt;String, IBinder&gt; <span class="title">getCommonServicesLocked</span><span class="params">(<span class="keyword">boolean</span> isolated)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mAppBindArgs == <span class="keyword">null</span>) &#123;</span><br><span class="line">        mAppBindArgs = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!isolated) &#123;</span><br><span class="line">            <span class="comment">// Setup the application init args</span></span><br><span class="line">            mAppBindArgs.put(<span class="string">&quot;package&quot;</span>, ServiceManager.getService(<span class="string">&quot;package&quot;</span>));</span><br><span class="line">            mAppBindArgs.put(<span class="string">&quot;window&quot;</span>, ServiceManager.getService(<span class="string">&quot;window&quot;</span>));</span><br><span class="line">            mAppBindArgs.put(Context.ALARM_SERVICE,</span><br><span class="line">                    ServiceManager.getService(Context.ALARM_SERVICE));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mAppBindArgs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这就说明只有 <code>PackageManagerService</code>，<code>WindowManagerService</code> 和 <code>AlarmManagerService</code> 对应的客户端 <code>Binder</code>（<code>BinderProxy</code>） 被缓存在 <code>sCache</code> 中的，其他服务的都是现用现取。至于为什么只对这三个 <code>BinderProxy</code> 进行缓存，我也不是太清楚，大家有兴趣可以去研究研究。</p>
<ul>
<li>getIServiceManager()</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> IServiceManager <span class="title">getIServiceManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sServiceManager != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> sServiceManager;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Find the service manager</span></span><br><span class="line">        sServiceManager = ServiceManagerNative.asInterface(BinderInternal.getContextObject());</span><br><span class="line">        <span class="keyword">return</span> sServiceManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是典型的单例模式，并且我们还发现 <code>sServiceManager</code> 也是通过 IPC 得到的（源码中 <code>xxxManagerNative</code> 其实就相当于 AIDL 中的 <code>Stub</code>），说明这个 <code>ServiceManager</code> 其实也是一个代理类。也就是说我们获取系统服务的过程，就是通过 <code>ServiceManager</code> 这个代理获取其他服务的客户端代理的过程。</p>
<p>OK，安卓获取系统服务的过程就介绍到这里，感谢大家的阅读，有什么不对的地方还望大家不吝赐教。</p>
]]></content>
      <tags>
        <tag>Android</tag>
        <tag>IPC</tag>
        <tag>System Service</tag>
        <tag>Binder</tag>
      </tags>
  </entry>
  <entry>
    <title>安卓中 Service 的启动过程（上）</title>
    <url>/2016/12/15/2016-12-13-process-of-starting-a-service/</url>
    <content><![CDATA[<h1 id="Service-的启动过程（上）"><a href="#Service-的启动过程（上）" class="headerlink" title="Service 的启动过程（上）"></a>Service 的启动过程（上）</h1><p>作为四大组件的 <code>Service</code>，由于没有 UI 界面，只能默默无闻地在后台工作。虽然我们说他是后台工作的，但是他还是默认进程的主线程中运行的，除非我们给它指定了单独的进程。<code>Service</code> 的启动过程有两种，一种是 <code>startService()</code>，另一种是 <code>bindService()</code>。我会在接下来的两篇文章中分别来介绍着两种启动方式，首先我们来探究 <code>startService()</code> 启动服务的过程。</p>
<span id="more"></span>

<h2 id="通过-startService-启动一个-Service"><a href="#通过-startService-启动一个-Service" class="headerlink" title="通过 startService 启动一个 Service"></a>通过 startService 启动一个 Service</h2><p><code>Activity</code> 和 <code>Service</code> 都是从 <code>ContextWrapper</code> 继承而来，而 <code>ContextWrapper</code> 继承自 <code>Context</code> 这个抽象类，所以我们通常把 <code>Activity</code> 和 <code>Service</code> 看作是 <code>Context</code> 对象。<code>ContextWrapper</code> 的实现用的是典型的装饰者模式，它的一系列的方法都靠内部的被装饰者的同名方法来实现，这和代理模式有点类似。而这个被装饰者通常是一个 <code>ContextImpl</code>，它是 <code>Context</code> 的真正实现者。</p>
<p><code>startService()</code> 是 <code>Context</code> 中定义的一个方法，由于 <code>Activity</code> 和 <code>Service</code> 属于 <code>ContextWrapper</code> 类型，所以这个方法真正的实现在 <code>ContextImpl#startService()</code> 中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ComponentName <span class="title">startService</span><span class="params">(Intent service)</span> </span>&#123;</span><br><span class="line">    warnIfCallingFromSystemProcess();</span><br><span class="line">    <span class="keyword">return</span> startServiceCommon(service, mUser);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>startService()</code> 会调用 <code>startServiceCommon()</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ComponentName <span class="title">startServiceCommon</span><span class="params">(Intent service, UserHandle user)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ......</span><br><span class="line">        ComponentName cn = ActivityManagerNative.getDefault().startService(</span><br><span class="line">            mMainThread.getApplicationThread(), service, service.resolveTypeIfNeeded(</span><br><span class="line">                        getContentResolver()), getOpPackageName(), user.getIdentifier());   </span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">return</span> cn;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e.rethrowFromSystemServer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ActivityManagerNative.getDefault()</code> 返回的是一个 <code>ActivityManagerProxy</code> 对象，它作为 AMS 在本进程的代理，如果我们的应用程序要和 AMS 打交道，必须要以它为媒介。这样看来 <code>ActvitiyManagerService</code> 并不像它名字所暗示的那样只管理 <code>Activity</code>，<code>Servcie</code> 也同样归它管。显然，这是一个远程调用，具体的实现在 <code>ActivityManagerService#startService()</code> 中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ComponentName <span class="title">startService</span><span class="params">(IApplicationThread caller, Intent service,</span></span></span><br><span class="line"><span class="params"><span class="function">        String resolvedType, String callingPackage, <span class="keyword">int</span> userId)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> TransactionTooLargeException </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> callingPid = Binder.getCallingPid();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> callingUid = Binder.getCallingUid();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> origId = Binder.clearCallingIdentity();</span><br><span class="line">        ComponentName res = mServices.startServiceLocked(caller, service,</span><br><span class="line">                resolvedType, callingPid, callingUid, callingPackage, userId);</span><br><span class="line">        Binder.restoreCallingIdentity(origId);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法并没有做什么，它把事情交给了 <code>mService</code>， <code>mService</code> 是一个 <code>ActiveServices</code> 对象。在早期的安卓版本中并没有这个类，后来重构时抽出这个类专门用来管理 <code>Service</code>，<code>ActiveServices#startServiceLocked()</code> 有点长，我们挑重要部分来看：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ServiceLookupResult res =</span><br><span class="line">        retrieveServiceLocked(service, resolvedType, callingPackage,</span><br><span class="line">                callingPid, callingUid, userId, <span class="keyword">true</span>, callerFg, <span class="keyword">false</span>);</span><br><span class="line">......</span><br><span class="line">ServiceRecord r = res.record;</span><br><span class="line">......</span><br><span class="line"><span class="keyword">return</span> startServiceInnerLocked(smap, service, r, callerFg, addToStarting);</span><br></pre></td></tr></table></figure>
<p>这个方法根据这个 <code>Service</code> 对应的 <code>Intent</code> 解析出一个 <code>ServiceRecord</code>，然后把事情交给了 <code>startServiceInnerLocked()</code>，这个方法的核心就是调用了 <code>bringUpServiceLocked()</code>，因此我们进入 <code>ActiveService#bringUpServiceLocked()</code> 看看：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">bringUpServiceLocked</span><span class="params">(ServiceRecord r, <span class="keyword">int</span> intentFlags, <span class="keyword">boolean</span> execInFg,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">boolean</span> whileRestarting, <span class="keyword">boolean</span> permissionsReviewRequired)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> TransactionTooLargeException </span>&#123;</span><br><span class="line">        </span><br><span class="line">        ......</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> isolated = (r.serviceInfo.flags&amp;ServiceInfo.FLAG_ISOLATED_PROCESS) != <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">final</span> String procName = r.processName;</span><br><span class="line">        ProcessRecord app;</span><br><span class="line">        <span class="keyword">if</span> (!isolated) &#123;</span><br><span class="line">            app = mAm.getProcessRecordLocked(procName, r.appInfo.uid, <span class="keyword">false</span>);</span><br><span class="line">            ......</span><br><span class="line">            <span class="keyword">if</span> (app != <span class="keyword">null</span> &amp;&amp; app.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    app.addPackage(r.appInfo.packageName, r.appInfo.versionCode, mAm.mProcessStats);</span><br><span class="line">                    realStartServiceLocked(r, app, execInFg);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (TransactionTooLargeException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> e;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                    Slog.w(TAG, <span class="string">&quot;Exception when starting service &quot;</span> + r.shortName, e);</span><br><span class="line">                &#125;</span><br><span class="line">             &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            app = r.isolatedProc;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ......</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (app == <span class="keyword">null</span> &amp;&amp; !permissionsReviewRequired) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((app=mAm.startProcessLocked(procName, r.appInfo, <span class="keyword">true</span>, intentFlags,</span><br><span class="line">                    <span class="string">&quot;service&quot;</span>, r.name, <span class="keyword">false</span>, isolated, <span class="keyword">false</span>)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                ......</span><br><span class="line">                bringDownServiceLocked(r);</span><br><span class="line">                <span class="keyword">return</span> msg;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (isolated) &#123;</span><br><span class="line">                r.isolatedProc = app;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">if</span> (!mPendingServices.contains(r)) &#123;</span><br><span class="line">            mPendingServices.add(r);</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>这段代码中有一个分支：</p>
<ul>
<li>如果 <code>Service</code> 要运行在启动服务的进程中（默认情况），就直接转到 <code>realStartServiceLocked()</code> 方法；</li>
<li>如果 <code>Service</code> 需要运行在指定进程（注册时给 <code>Service</code> 指定进程名）中就会通知 AMS 新开一个进程（如果这个进程不存在的话），并把这个 <code>Service</code> 对应的 <code>ServiceRecord</code> 对象放进等待列表 <code>mPendingServices</code> 中，当进程开启成功后会从列表中取出 <code>ServiceRecord</code> 对象，然后把 <code>ServiceRecord</code> 对应的 <code>Service</code> 在该进程中创建并运行。</li>
</ul>
<p>下面我们分别对这两种情况进行研究。</p>
<h3 id="在启动服务的进程中创建-Service"><a href="#在启动服务的进程中创建-Service" class="headerlink" title="在启动服务的进程中创建 Service"></a>在启动服务的进程中创建 Service</h3><p>前面说了，如果在启动服务的进程中启动 <code>Service</code> 会进入到 <code>ActiveService#realStartServiceLocked()</code> 方法中，它有两行代码值得关注：</p>
<h5 id="第一行代码"><a href="#第一行代码" class="headerlink" title="第一行代码"></a>第一行代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">app.thread.scheduleCreateService(r, r.serviceInfo,</span><br><span class="line">       mAm.compatibilityInfoForPackageLocked(r.serviceInfo.applicationInfo),</span><br><span class="line">       app.repProcState);</span><br></pre></td></tr></table></figure>
<p>关于这行代码说明两点：</p>
<ul>
<li><code>app</code> 是要运行 <code>Service</code> 的进程对应的 <code>ProcessRecord</code> 对象，系统源码很多地方用 <code>ProcessRecord</code> 代表一个应用进程，这和用 <code>ActivityRecord</code> 代表一个 <code>Activity</code> 以及用 <code>ServiceRecord</code> 代表一个 <code>Service</code> 是同样的道理。</li>
<li><code>thread</code> 是一个 <code>ApplicationThreadProxy</code> 对象，它是应用进程的 <code>ApplicatonThread</code> 对象在 AMS 端的代理，AMS 靠它来和应用进程进行通信。你可能会感到奇怪，前面不是说了应用进程和 AMS 通信靠的是 <code>ActivityManagerProxy</code> 吗，这里怎么出来了一个 <code>ApplicationThreadProxy</code> ？我们要清楚，<code>Binder</code> 实现的进程间通信是单向的，其信息传递方向是 <code>BinderProxy</code> —&gt; <code>Binder</code>。但是很显然，应用进程和 AMS 是需要双向通信的，所以要想实现双向通信，必须有两对 <code>Binder</code>-<code>BinderProxy</code> 才行，这就是 <code>ApplicationThread</code> 和 <code>ApplicationThreadProxy</code> 存在的的原因。应用进程和 AMS 的通信可以用下图来表示：</li>
</ul>
<p><img src="/img/in-post/post_android_process_of_starting_a_service/post-1.png"></p>
<p>虽然在这里是 <code>ActiveServices</code> 与应用进程通信，但 <code>ActiveServices</code> 也是用来辅助 AMS 管理 <code>Service</code> 的，所以也可以把这个过程看作是 AMS 与 应用进程的通信。（要知道早期的安卓版本没有 <code>ActiveServices</code> 这个类，这些逻辑都是在 AMS 中的）</p>
<p>这行代码的作用是通知应用进程根据已知信息创建一个 <code>Service</code>，那么应用进程是怎样创建这个 <code>Service</code> 的呢？进入到 <code>ApplicationThread#scheduleCreateService()</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">scheduleCreateService</span><span class="params">(IBinder token,</span></span></span><br><span class="line"><span class="params"><span class="function">        ServiceInfo info, CompatibilityInfo compatInfo, <span class="keyword">int</span> processState)</span> </span>&#123;</span><br><span class="line">    updateProcessState(processState, <span class="keyword">false</span>);</span><br><span class="line">    CreateServiceData s = <span class="keyword">new</span> CreateServiceData();</span><br><span class="line">    s.token = token;</span><br><span class="line">    s.info = info;</span><br><span class="line">    s.compatInfo = compatInfo;</span><br><span class="line">    sendMessage(H.CREATE_SERVICE, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>scheduleCreateService()</code> 中，先是把 AMS 传来的信息封装成一个 <code>CreateServcieData</code> 对象，然后调用 <code>sendMessage()</code> 把信息发送出去。注意，<code>sendMessage()</code> 是 <code>ActivitytThead</code> 的方法，因为 <code>ApplicationThread</code> 是 <code>ActivityThread</code> 的内部类，所以对 <code>ActivityThread</code> 有完全的访问权限。这样一来消息就从 <code>ApplicationThread</code> 传到了 <code>ActivityThread</code>，我们来看看 <code>ActivityThread#sendMessage()</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(<span class="keyword">int</span> what, Object obj)</span> </span>&#123;</span><br><span class="line">    sendMessage(what, obj, <span class="number">0</span>, <span class="number">0</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>转到另一个重载方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(<span class="keyword">int</span> what, Object obj, <span class="keyword">int</span> arg1, <span class="keyword">int</span> arg2, <span class="keyword">boolean</span> async)</span> </span>&#123;</span><br><span class="line">    Message msg = Message.obtain();</span><br><span class="line">    msg.what = what;</span><br><span class="line">    msg.obj = obj;</span><br><span class="line">    msg.arg1 = arg1;</span><br><span class="line">    msg.arg2 = arg2;</span><br><span class="line">    <span class="keyword">if</span> (async) &#123;</span><br><span class="line">        msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mH.sendMessage(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里把信息传给了 <code>mH</code> 这个 <code>Handler</code> 对象，这个 <code>Handler</code> 对象是在应用进程的主线程中创建的，所以最终的结果是把创建 <code>Service</code> 的消息传到了主线程。现在你终于明白了为什么 <code>Service</code> 会在主线程运行吧？看看 <code>mH</code> 是怎样处理这个消息的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> CREATE_SERVICE:</span><br><span class="line">    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, (<span class="string">&quot;serviceCreate: &quot;</span> + String.valueOf(msg.obj)));</span><br><span class="line">    handleCreateService((CreateServiceData)msg.obj);</span><br><span class="line">    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<p>百转千回，消息最终传到了 <code>handleCreateService()</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleCreateService</span><span class="params">(CreateServiceData data)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    </span><br><span class="line">    LoadedApk packageInfo = getPackageInfoNoCheck(</span><br><span class="line">            data.info.applicationInfo, data.compatInfo);</span><br><span class="line">    Service service = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        java.lang.ClassLoader cl = packageInfo.getClassLoader();</span><br><span class="line">        service = (Service) cl.loadClass(data.info.name).newInstance();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (localLOGV) Slog.v(TAG, <span class="string">&quot;Creating service &quot;</span> + data.info.name);</span><br><span class="line">        ContextImpl context = ContextImpl.createAppContext(<span class="keyword">this</span>, packageInfo);</span><br><span class="line">        context.setOuterContext(service);</span><br><span class="line">        Application app = packageInfo.makeApplication(<span class="keyword">false</span>, mInstrumentation);</span><br><span class="line">        service.attach(context, <span class="keyword">this</span>, data.info.name, data.token, app,</span><br><span class="line">                ActivityManagerNative.getDefault());</span><br><span class="line">        service.onCreate();</span><br><span class="line">        mServices.put(data.token, service);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ActivityManagerNative.getDefault().serviceDoneExecuting(</span><br><span class="line">                    data.token, SERVICE_DONE_EXECUTING_ANON, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> e.rethrowFromSystemServer();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里是 <code>Service</code> 真正被创建的地方，这个方法做了以下几件事：</p>
<ul>
<li>根据类名用应用程序的类加载器加载并实例化一个 <code>Service</code>。</li>
<li>创建一个 <code>ContextImpl</code> 对象，把 <code>Service</code> 作为它的额外层 <code>Context</code> 对象。</li>
<li>为这个 <code>Service</code> 创建一个 <code>Application</code> 对象，当然，如果应用进程已经存在 <code>Application</code> 就不会重复创建，具体大家可以看看 <code>LoadedAPK#makeApplication()</code> 的实现，这里就不详细讲了。</li>
<li>用 <code>Service</code> 的 <code>attach()</code> 方法把相应信息附加到 <code>Service</code>，其中，<code>context</code> 是之前创建的 <code>ContextImpl</code> 对象，在 <code>attach()</code> 方法中会把它作为 <code>Service</code> 内部的被装饰对象；<code>this</code> 代表本进程中的 <code>ActivityThread</code> 对象；<code>data.info.name</code> 是这个 <code>Service</code> 的名称；<code>data.token</code> 是从 AMS 传过来的 <code>ServiceRecord</code> 对象，它是一个 <code>Binder</code>，作为这个 <code>Service</code> 的标识。</li>
<li>调用 <code>Service</code> 的 <code>onCreate()</code> 方法。</li>
<li>把 <code>token</code> 和 <code>Service</code> 的映射关系保存在 <code>mServices</code> 中。</li>
<li>通过 <code>ActivityManagerProxy</code> 告知 AMS <code>Service</code> 已经创建好了，让其完成后续的工作。</li>
</ul>
<p>关于后续 AMS 做了哪些事，我们就不深究了，大家有兴趣可以自行阅读源码。现在我们看看 <code>ActiveService#realStartServiceLocked()</code> 中的另一行代码。</p>
<h4 id="第二行代码"><a href="#第二行代码" class="headerlink" title="第二行代码"></a>第二行代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">sendServiceArgsLocked(r, execInFg, <span class="keyword">true</span>);</span><br></pre></td></tr></table></figure>

<p>这个方法的核心部分在这里：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">r.app.thread.scheduleServiceArgs(r, si.taskRemoved, si.id, flags, si.intent);</span><br></pre></td></tr></table></figure>
<p>这里又通过 <code>ApplicationThreadProxy</code> 和应用进程进行了通信，我们看看应用进程是怎样响应这个方法调用的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">scheduleServiceArgs</span><span class="params">(IBinder token, <span class="keyword">boolean</span> taskRemoved, <span class="keyword">int</span> startId,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">int</span> flags ,Intent args)</span> </span>&#123;</span><br><span class="line">    ServiceArgsData s = <span class="keyword">new</span> ServiceArgsData();</span><br><span class="line">    s.token = token;</span><br><span class="line">    s.taskRemoved = taskRemoved;</span><br><span class="line">    s.startId = startId;</span><br><span class="line">    s.flags = flags;</span><br><span class="line">    s.args = args;</span><br><span class="line">    sendMessage(H.SERVICE_ARGS, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和前面一样，同样是把信息封装好后通过安卓的消息机制投递到主线程中，我们看看 <code>Handler:mH</code> 是怎样处理这个消息的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> SERVICE_ARGS:</span><br><span class="line">    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, (<span class="string">&quot;serviceStart: &quot;</span> + String.valueOf(msg.obj)));</span><br><span class="line">    handleServiceArgs((ServiceArgsData)msg.obj);</span><br><span class="line">    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<p>转入 <code>ActivityThread#handleServiceArgs</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleServiceArgs</span><span class="params">(ServiceArgsData data)</span> </span>&#123;</span><br><span class="line">    Service s = mServices.get(data.token);</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ......</span><br><span class="line">            <span class="keyword">int</span> res;</span><br><span class="line">            <span class="keyword">if</span> (!data.taskRemoved) &#123;</span><br><span class="line">                res = s.onStartCommand(data.args, data.flags, data.startId);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                s.onTaskRemoved(data.args);</span><br><span class="line">                res = Service.START_TASK_REMOVED_COMPLETE;</span><br><span class="line">            &#125;</span><br><span class="line">            QueuedWork.waitToFinish();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ActivityManagerNative.getDefault().serviceDoneExecuting(</span><br><span class="line">                        data.token, SERVICE_DONE_EXECUTING_START, data.startId, res);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> e.rethrowFromSystemServer();</span><br><span class="line">            &#125;</span><br><span class="line">            ensureJitEnabled();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里先根据 <code>token</code> 取出保存的 <code>Service</code>，然后根据 <code>data.taskRemoved</code> 的值回调 <code>Service</code> 中的相应方法，一般情况下这个值是为 <code>false</code> 的，也就是说 <code>Service</code> 的 <code>onStartCommand()</code> 方法会得到调用。至此在服务启动者的进程中创建服务的过程就分析完了，现在我们看看指定进程中启动服务的过程是怎样的。</p>
<h3 id="在指定进程中创建并启动-Service-的过程"><a href="#在指定进程中创建并启动-Service-的过程" class="headerlink" title="在指定进程中创建并启动 Service 的过程"></a>在指定进程中创建并启动 Service 的过程</h3><p>如果注册 <code>Service</code> 的时候我们给 <code>Service</code> 指定了进程名，那么 <code>Service</code> 就会在那个进程中被创建并运行，这个时候启动过程就会走向另一条分支，还记得出现分支的地方吗？它在 <code>ActiveService#bringUpServiceLocked()</code> 中，这条分支会执行以下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">bringUpServiceLocked</span><span class="params">(ServiceRecord r, <span class="keyword">int</span> intentFlags, <span class="keyword">boolean</span> execInFg,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">boolean</span> whileRestarting, <span class="keyword">boolean</span> permissionsReviewRequired)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> TransactionTooLargeException </span>&#123;</span><br><span class="line">        ......        </span><br><span class="line">        <span class="keyword">if</span> (app == <span class="keyword">null</span> &amp;&amp; !permissionsReviewRequired) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((app=mAm.startProcessLocked(procName, r.appInfo, <span class="keyword">true</span>, intentFlags,</span><br><span class="line">                    <span class="string">&quot;service&quot;</span>, r.name, <span class="keyword">false</span>, isolated, <span class="keyword">false</span>)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                ......</span><br><span class="line">                bringDownServiceLocked(r);</span><br><span class="line">                <span class="keyword">return</span> msg;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (isolated) &#123;</span><br><span class="line">                r.isolatedProc = app;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">if</span> (!mPendingServices.contains(r)) &#123;</span><br><span class="line">            mPendingServices.add(r);</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意到这行代码 <code>mAm.startProcessLocked()</code>，<code>mAm</code> 就是 AMS，这里通过 AMS 开启了一个进程。现在我们进入 <code>ActivityManagerService#startProcessLocked()</code> 这个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">startProcessLocked</span><span class="params">(ProcessRecord app,</span></span></span><br><span class="line"><span class="params"><span class="function">        String hostingType, String hostingNameStr)</span> </span>&#123;</span><br><span class="line">    startProcessLocked(app, hostingType, hostingNameStr, <span class="keyword">null</span> <span class="comment">/* abiOverride */</span>,</span><br><span class="line">            <span class="keyword">null</span> <span class="comment">/* entryPoint */</span>, <span class="keyword">null</span> <span class="comment">/* entryPointArgs */</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>转向它的一个重载方法，这个重载方法有点长，但它的核心代码也就一句话：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Process.ProcessStartResult startResult = Process.start(entryPoint,</span><br><span class="line">        app.processName, uid, uid, gids, debugFlags, mountExternal,</span><br><span class="line">        app.info.targetSdkVersion, app.info.seinfo, requiredAbi, instructionSet,</span><br><span class="line">        app.info.dataDir, entryPointArgs);</span><br></pre></td></tr></table></figure>
<p><code>Process#start()</code> 会利用这些参数向 native 层 fork 一个进程。注意到这个方法的第一参数 <code>String:entryPoint</code>，顾名思义，它是进程的入口点，其值为 <code>&quot;android.app.ActivityThread&quot;</code>。对于 <code>ActivityThread</code> 我们应该很熟悉了，每个应用进程都有一个 <code>ActivityThread</code> 对象，它代表着应用进程的主线程，处理着内部类 <code>ApplicationThread</code> 发送过来的来自 AMS 的各种消息。进程创建好后 native 层代码后就会调用这个类的静态方法 <code>main()</code>，它的实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">final</span> File configDir = Environment.getUserConfigDirectory(UserHandle.myUserId());</span><br><span class="line">    TrustedCertificateStore.setDefaultUserDirectory(configDir);</span><br><span class="line">    Process.setArgV0(<span class="string">&quot;&lt;pre-initialized&gt;&quot;</span>);</span><br><span class="line">    Looper.prepareMainLooper();</span><br><span class="line">    ActivityThread thread = <span class="keyword">new</span> ActivityThread();</span><br><span class="line">    thread.attach(<span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (sMainThreadHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">        sMainThreadHandler = thread.getHandler();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">false</span>) &#123;</span><br><span class="line">        Looper.myLooper().setMessageLogging(<span class="keyword">new</span></span><br><span class="line">                LogPrinter(Log.DEBUG, <span class="string">&quot;ActivityThread&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// End of event ActivityThreadMain.</span></span><br><span class="line">    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">    Looper.loop();</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Main thread loop unexpectedly exited&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它很简短，主要做了这几件事：</p>
<ul>
<li>为主线程准备消息循环</li>
<li>为应用进程创建一个 <code>ActivityThread</code> 对象</li>
<li>调用 <code>ActivityThread</code> 的 <code>attach()</code> 方法</li>
<li>开启消息循环</li>
</ul>
<p>这样我们的应用进程就进入到一个死循环中了，不断的接受消息并执行。所以我们会说安卓应用是消息驱动的。我们重点关注 <code>attach()</code> 方法，它有这样一段代码值得关注：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> IActivityManager mgr = ActivityManagerNative.getDefault();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    mgr.attachApplication(mAppThread);</span><br><span class="line">&#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">    <span class="keyword">throw</span> ex.rethrowFromSystemServer();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里通过 <code>ActivityManagerProxy</code> 远程调用了 AMS 的 <code>attachApplication()</code> 方法，参数是 <code>mAppThread</code>，而它是这样初始化的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> ApplicationThread mAppThread = <span class="keyword">new</span> ApplicationThread();</span><br></pre></td></tr></table></figure>
<p>说明它就是 <code>ApplicationThread</code> 对象，前面说了，AMS 要想向应用进程发送消息，需要借助 <code>ApplicationThreadProxy</code> 对象。而通过 <code>Binder</code> 机制 <code>ApplicationThread</code> 在 AMS 那边就转化成了 <code>ApplicationThreadProxy</code> 对象，所以这个对象就是在此时传给 AMS 的。在 AMS 中，<code>attachApplication()</code> 会直接调用 <code>attachApplicationLocked()</code>，对于这个方法，我们挑需要的代码段来看：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!badApp) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        didSomething |= mServices.attachApplicationLocked(app, processName);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        Slog.wtf(TAG, <span class="string">&quot;Exception thrown starting services in &quot;</span> + app, e);</span><br><span class="line">        badApp = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>mServices</code> 就是 <code>ActiveServices</code>，进入 <code>ActiveServices#attachApplicationLocked()</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">attachApplicationLocked</span><span class="params">(ProcessRecord proc, String processName)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> didSomething = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// Collect any services that are waiting for this process to come up.</span></span><br><span class="line">    <span class="keyword">if</span> (mPendingServices.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        ServiceRecord sr = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;mPendingServices.size(); i++) &#123;</span><br><span class="line">                sr = mPendingServices.get(i);</span><br><span class="line">                <span class="keyword">if</span> (proc != sr.isolatedProc &amp;&amp; (proc.uid != sr.appInfo.uid</span><br><span class="line">                        || !processName.equals(sr.processName))) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                mPendingServices.remove(i);</span><br><span class="line">                i--;</span><br><span class="line">                proc.addPackage(sr.appInfo.packageName, sr.appInfo.versionCode,</span><br><span class="line">                        mAm.mProcessStats);</span><br><span class="line">                realStartServiceLocked(sr, proc, sr.createdFromFg);</span><br><span class="line">                didSomething = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (!isServiceNeeded(sr, <span class="keyword">false</span>, <span class="keyword">false</span>)) &#123;</span><br><span class="line">                    bringDownServiceLocked(sr);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">           ......</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大家还记得 <code>mPendingServices</code> 吗？前面说了，如果在指定进程当中运行一个 <code>Service</code>，会先创建一个进程，然后在把该 <code>Service</code> 对应的 <code>ServiceRecord</code> 对象放入 <code>mPendingServices</code> 中，待进程创建好了就会从中取出 <code>ServiceRecord</code>，然后根据它在进程中创建 <code>Service</code>。具体过程是怎样的呢？我们看看这个方法主要作了哪些事：</p>
<p>遍历 <code>mPendingServices</code>，根据 <code>ProcessRecord:proc</code> 和 <code>String:processName</code> 提供的进程信息找出要运行在这个进程的 <code>ServiceRecord</code>，然后调用 <code>realStartServiceLocked()</code> 方法并把找到的 <code>ServiceRecord</code> 作为参数传入其中。<code>realStartServiceLocked()</code> 之后的流程前面已经有介绍，这里就不重复讲了。</p>
<p>至此，通过 <code>startService()</code> 启动服务的整个过程就介绍完了，在接下来的一篇文章中我会介绍通过 <code>bindService()</code> 创建并绑定一个 <code>Service</code> 的详细流程。感谢大家的阅读，有什么不对的地方还望大家不吝赐教。</p>
]]></content>
      <tags>
        <tag>Android</tag>
        <tag>四大组件</tag>
      </tags>
  </entry>
  <entry>
    <title>android 记坑</title>
    <url>/2017/02/24/2017-02-24-android-dev-log/</url>
    <content><![CDATA[<h1 id="android-记坑"><a href="#android-记坑" class="headerlink" title="android 记坑"></a>android 记坑</h1><h2 id="调用相机获取图片"><a href="#调用相机获取图片" class="headerlink" title="调用相机获取图片"></a>调用相机获取图片</h2><p>有两种方法获取图片，分别对应不同的需求：一种是获取缩略图，适合用来做头像或者其他比较小的 icon ；另一种是获取原图，如果有保存或查看原图的需求，就应该用这种方法。</p>
<span id="more"></span>

<h3 id="获取缩略图"><a href="#获取缩略图" class="headerlink" title="获取缩略图"></a>获取缩略图</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Intent getThumbnail = <span class="keyword">new</span> Intent(MediaStore.ACTION_IMAGE_CAPTURE);</span><br><span class="line">File file = createEmptyFile();</span><br><span class="line"><span class="keyword">if</span> (getThumbnail.resolveActivity(getPackageManager()) != <span class="keyword">null</span>)</span><br><span class="line">    startActivityForResult(getThumbnail, REQUEST_GET_THUMBNAIL);</span><br></pre></td></tr></table></figure>

<p>这样就调用了相机拍照，然后我们在 <code>onActivityResult()</code> 中获取图片：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onActivityResult</span><span class="params">(<span class="keyword">int</span> requestCode, <span class="keyword">int</span> resultCode, Intent data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (requestCode == REQUEST_GET_THUMBNAIL) &#123;</span><br><span class="line">        <span class="keyword">if</span> (resultCode == RESULT_OK) &#123;</span><br><span class="line">            Bitmap bitamp;</span><br><span class="line">            <span class="keyword">if</span> (data != <span class="keyword">null</span>) </span><br><span class="line">                bitmap = (Bitmap) data.getExtras().get(<span class="string">&quot;data&quot;</span>);</span><br><span class="line">            thumbnail.setImageBitmap(bitmap);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="获取原图"><a href="#获取原图" class="headerlink" title="获取原图"></a>获取原图</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Intent getBigPhoto = <span class="keyword">new</span> Intent(MediaStore.ACTION_IMAGE_CAPTURE);</span><br><span class="line">File file = createEmptyFile(); <span class="comment">//用于输出原图</span></span><br><span class="line">currentFile = file;</span><br><span class="line">Uri uri = Uri.fromFile(file);<span class="comment">//将 file 转换成 uri 格式</span></span><br><span class="line">getBigPhoto.putExtra(MediaStore.EXTRA_OUTPUT, uri);</span><br><span class="line">startActivityForResult(Intent, REQUEST_GET_BIG_PHOTO);</span><br></pre></td></tr></table></figure>
<p>然后图片就会自动输出到你指定的文件，如果同时你又想获取原图，你就会这样做：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onActivityResult</span><span class="params">(<span class="keyword">int</span> requestCode, <span class="keyword">int</span> resultCode, Intent data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (requestCode == REQUEST_GET_BIG_PHOTO) &#123;</span><br><span class="line">        <span class="keyword">if</span> (resultCode == RESULT_OK) &#123;</span><br><span class="line">            Bitmap bitamp;</span><br><span class="line">            <span class="keyword">if</span> (data != <span class="keyword">null</span>) </span><br><span class="line">                bitmap = (Bitmap) data.getExtras().get(<span class="string">&quot;data&quot;</span>);</span><br><span class="line">            thumbnail.setImageBitmap(bitmap);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好了，看似一切正常，但是总有一些你意想不到的异常发生，我来指出这之中有问题的几个坑吧（权限问题就不讲了）吧：</p>
<ul>
<li><code>File</code> 转换成 <code>Uri</code> 格式这一步时，如果你是上面那样转换的，那么在 android N 上你就会得到 <code>FileUriExposedException</code>，因为这样做是不安全的，你将文件的真实 <code>Uri</code> 暴露出去了，其他应用可能对这个文件有完全的控制权。安全的做法是通过 [FileProvider.getUriForFile(Context, String, File)](<a href="https://developer.android.google.cn/reference/android/support/v4/content/FileProvider.html#getUriForFile">https://developer.android.google.cn/reference/android/support/v4/content/FileProvider.html#getUriForFile</a>(android.content.Context, java.lang.String, java.io.File)) 暴露所要提供的 <code>Uri</code>。这样提供给其他的应用的 <code>Uri</code> 不会暴露出文件的真实位置，因为这只是这是文件的一个 “镜像地址”，其他应用只能调用系统功能才能将此 <code>Uri</code> 定位到实际位置。</li>
<li>如果你想同时获取原图和缩略图，那么你就错了，这二者不可兼得。每次调用相机，只能获取缩略图或者原图，这和你是否指定 <code>MediaStore.EXTRA_OUTPUT</code> 附加字段有关：如果没有指定，说明你并不想将获取的图片输出（即保存为原图)，此时 <code>onActivityResult()</code> 的第三个参数就不为 <code>null</code>，你可以从中取出缩略图；但是如果指定了，说明你想将照片输出为原图，那么第三个参数就为 <code>null</code>，你并不能从中获取缩略图。</li>
</ul>
<h2 id="将图片添加至媒体库"><a href="#将图片添加至媒体库" class="headerlink" title="将图片添加至媒体库"></a>将图片添加至媒体库</h2><p>我们的应用经常有将图片保存到磁盘的需求，但是保存的图片在下一次开机前媒体库是检测不到的，也就是说我们在图库中是看不到刚才保存的图片的，因此也就无法和其他应用共享。要将保存的图片加入媒体库中需要做一点额外的工作，下面介绍实现方法：</p>
<h3 id="发送广播通知媒体库扫描此图片"><a href="#发送广播通知媒体库扫描此图片" class="headerlink" title="发送广播通知媒体库扫描此图片"></a>发送广播通知媒体库扫描此图片</h3><p>这一方法在安卓官方培训<a href="https://developer.android.google.cn/training/camera/photobasics.html">教程</a>中有提到，它是这样做的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">galleryAddPic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Intent mediaScanIntent = <span class="keyword">new</span> Intent(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE);</span><br><span class="line">    File f = <span class="keyword">new</span> File(mCurrentPhotoPath);</span><br><span class="line">    Uri contentUri = Uri.fromFile(f);</span><br><span class="line">    mediaScanIntent.setData(contentUri);</span><br><span class="line">    <span class="keyword">this</span>.sendBroadcast(mediaScanIntent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="和系统进程通信将图片添加至媒体库"><a href="#和系统进程通信将图片添加至媒体库" class="headerlink" title="和系统进程通信将图片添加至媒体库"></a>和系统进程通信将图片添加至媒体库</h3><p>另外一种是通过 <code>MediaScannerConnection</code> 实现的，这一方法的原理就是和系统进程进行通信，具体做法是这样的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Class Client implements MediaScannerConnectionClient &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MediaScannerConnection conn;</span><br><span class="line">    <span class="keyword">private</span> String filePath;</span><br><span class="line">    <span class="keyword">private</span> String mimeType;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Client</span><span class="params">(Context c, String filePath, String mimeType)</span> </span>&#123;</span><br><span class="line">        conn = <span class="keyword">new</span> MediaScannrConnection(context, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMediaScannerConnected</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        conn.scanFile(filePath, mimeType);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onScanCompleted</span><span class="params">(String path, Uri uri)</span> </span>&#123;</span><br><span class="line">        Log.d(<span class="string">&quot;Client&quot;</span>, <span class="string">&quot;path:&quot;</span> + path + <span class="string">&quot;; uri:&quot;</span> + uri);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scanFile</span><span class="params">(String path, String mimeType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.filePath = filePath;</span><br><span class="line">        <span class="keyword">this</span>.mimeType = mimeType;</span><br><span class="line">        conn.connect();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="直接操作媒体库的数据库"><a href="#直接操作媒体库的数据库" class="headerlink" title="直接操作媒体库的数据库"></a>直接操作媒体库的数据库</h3><p>第三种方法是直接将图片信息直接添加媒体库的数据库中，其实前面两种方法的底层实现也是这样的，只是屏蔽了相关细节，避免我们直接接触数据库。因为要操作其他应用的数据库，所以要用到 <code>ContentResolver</code>，具体实现是这样的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ContentValues values = <span class="keyword">new</span> ContentValues();</span><br><span class="line"></span><br><span class="line">values.put(Images.Media.DATE_TAKEN, System.currentTimeMillis());</span><br><span class="line">values.put(Images.Media.MIME_TYPE, <span class="string">&quot;image/jpeg&quot;</span>);</span><br><span class="line">values.put(MediaStore.MediaColumns.DATA, filePath);</span><br><span class="line"></span><br><span class="line">context.getContentResolver().insert(Images.Media.EXTERNAL_CONTENT_URI, values);</span><br></pre></td></tr></table></figure>
<p>下面分别介绍其中遇到的坑：</p>
<ul>
<li>第一种方法在 android 4.4 以下时是可以的，但是有个问题就是通过广播将单个文件添加至媒体库性能上不划算；在 android 4.4 会出现 <code>SecurityException</code>，原因是 android 4.4 禁止非系统应用发送系统广播，而扫描媒体文件的广播属于系统广播，因此运行时会崩溃；但是我在 android 5.0 至 7.1 上实测却可行，或许系统已经开放了此权限。</li>
<li>第二种和第三种方法没有版本限制，是通用的方法。</li>
<li>前两种方法有一点要注意，如果该图片存放至应用的私有目录下（无论内部存储还是外部存储），媒体库都无法扫描到该文件（没有权限）；第三种方法则没有这种限制，因为它不是通过扫描，而是直接操作数据库的方式添加的。</li>
</ul>
<h2 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h2><p>###创建通知</p>
<ul>
<li>如果你的 target sdk 大于 26 (O)，那么发布通知时应该指定通知渠道，否则通知不能发送成功。</li>
<li>发送通知时必须指定 smallIcon，并且 smallIcon 必须是 drawable 资源 ID ，否则会导致系统的 SystemUI 崩溃。</li>
<li>设置通知的 PendingIntent 时需要注意，如果 Intent 中有附加字段需要传递，一定记得带 FLAG_UPDATE_CURRENT 这个标志，至于为什么，可以看看这篇文章：<a href="https://www.kancloud.cn/digest/androidframeworks/127784">说说 PendingIntent 的内部机制</a>。</li>
</ul>
<p>— 未完待续</p>
]]></content>
      <tags>
        <tag>Android</tag>
        <tag>记坑</tag>
      </tags>
  </entry>
  <entry>
    <title>Messenger 的工作原理</title>
    <url>/2017/02/25/2017-02-25-how-does-messenger-work/</url>
    <content><![CDATA[<h1 id="Messenger-的工作原理"><a href="#Messenger-的工作原理" class="headerlink" title="Messenger 的工作原理"></a>Messenger 的工作原理</h1><p>我们知道，<code>Handler</code> 是安卓用来进行线程间通信的工具，但是如果涉及到进程间通信呢，可以用 Handler 吗？答案是否定的。因为 <code>Handler</code> 实现的线程共享是基于统一进程的线程共享同一进程空间这一事实的。而不同进程拥有不同的进程空间，所以 <code>Hander</code> 机制不能于进程间通信。别太沮丧，安卓为我们提供了一个 Handler 的变体让我们可以通过和 <code>Handler</code> 类似的方式实现进程间通信，它就是 <code>Messenger</code>。</p>
<span id="more"></span>

<h2 id="IMessenger"><a href="#IMessenger" class="headerlink" title="IMessenger"></a>IMessenger</h2><p>我们知道进程间通信如果是通过 <code>Binder</code> 实现的，<code>Messenger</code> 也不例外。既然如此，那么一定会有 <code>Binder</code> 接口作为服务端和客户端的通信契约（类似于 AIDL 接口），在这里这个接口就是 <code>IMessenger</code>。它的定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IMessenger</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">send</span><span class="params">(Message msg)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于这个接口，需要有服务端的实现和客户端的实现。其中服务端的实现就“藏”在 <code>Handler</code> 中，它是 <code>Handler</code> 的内部类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MessengerImpl</span> <span class="keyword">extends</span> <span class="title">IMessenger</span>.<span class="title">Stub</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        msg.sendingUid = Binder.getCallingUid();</span><br><span class="line">        Handler.<span class="keyword">this</span>.sendMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于 <code>Stub</code> 类是什么，在<a href="/2016/10/28/android-IPC-AIDL/">安卓进程通信机制之 AIDL</a>已经解释过了，它是一个继承自 <code>Binder</code> 的抽象类，内部封装了 <code>Binder</code> 通信机制，同时它还实现了 <code>IMessenger</code> 接口，但是它自己并没有真正意义的实现，而是留给服务端去实现，这里也就是 <code>MessengerImpl</code>。<code>MessengerImpl</code> 实现这个接口的方式就是简单地把发送来的消息转发给外部类 <code>Handler</code>，由 <code>Handler</code> 投递给消息队列。</p>
<h2 id="Messenger"><a href="#Messenger" class="headerlink" title="Messenger"></a>Messenger</h2><p>既然我们说 <code>Messenger</code> 是 <code>Handler</code> 的变体，那么我们自然的会认为 <code>Messenger</code> 应该具有这样的功能，或者说使用方法：在客户端进程中投送一个消息给服务端，服务端通过解析这个消息的内容执行相应的动作。那么，<code>Messenger</code> 是怎样做到的呢？它和 <code>IMessenger</code> 和 <code>MessengerImpl</code> 又有什么关联？首先我们从它的构造方法看起：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Messenger</span><span class="params">(Handler target)</span> </span>&#123;</span><br><span class="line">    mTarget = target.getIMessenger();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Messenger</span><span class="params">(IBinder target)</span> </span>&#123;</span><br><span class="line">    mTarget = IMessenger.Stub.asInterface(target);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 <code>mTarget</code> 是一个 <code>IMessenger</code> 对象；而 <code>target.getIMessenger()</code> 就是前面的 <code>MessengerImpl</code> 对象。从这里我们很容易发现通过第一个构造方法构造的 <code>Messenger</code> 其 <code>mTarget</code> 是 <code>Binder</code> 接口在服务端的实现；而第二个构造方法构造出的 <code>Messenger</code> 其 <code>mTarget</code> 是 <code>Binder</code> 接口在客户端的实现（不懂的话可以看看我的<a href="/2016/10/28/android-IPC-AIDL/">这篇文章</a>)。</p>
<p>现在我们对 <code>Messenger</code> 有了一个具体的认知：为了给开发者提供最简单的接口，系统又在 <code>IMessenger</code> 的基础之上用 <code>Messenger</code> 又封装了一层，将 <code>Binder</code> “隐藏”起来。我们通过 <code>Messenger</code> 的使用示例来说明：</p>
<p>首先定义服务端，我们在 Service 中实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> MessengerServer extends Service &#123;</span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MessengerHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         handlerMessage(Message msg) &#123;</span><br><span class="line">             <span class="keyword">switch</span>(msg.what) &#123;</span><br><span class="line">                 <span class="keyword">case</span> TO_MESSENGER_SERVER :</span><br><span class="line">                     Log.d(<span class="string">&quot;MessengerServer&quot;</span>, );</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;    </span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> Messenger(<span class="keyword">new</span> MessengerHandler).getBinder();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后是客户端的实现，我们放在 <code>Activity</code> 中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessengerClient</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> finanl Messenger server;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ServiceConnection conn = <span class="keyword">new</span> ServiceConnection() &#123;</span><br><span class="line">        <span class="meta">@Override</span> </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName className, IBinder service)</span> </span>&#123;</span><br><span class="line">            server = <span class="keyword">new</span> Messenger(service);</span><br><span class="line">            Message msg = Message.obtain(<span class="keyword">null</span>, TO_MESSENGER_SERVER);</span><br><span class="line">            Bundle data = <span class="keyword">new</span> Bundle();</span><br><span class="line">            data.putString(<span class="string">&quot;This msg is from client&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                mServer.send(msg);<span class="comment">//发送消息给客户端，进行了一次远程调用</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServieDisconnected</span><span class="params">(ComponentName className)</span> </span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        ......</span><br><span class="line">        Intent i = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, MessengerService.class);</span><br><span class="line">        bindService(intent, mConnection, Context.BIND_AUTO_CREATE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就通过 <code>Messenger</code> 实现了进程间的通信，这和我们用 <code>Handler</code> 实现线程间通信非常相似。<code>Messenger</code> 在服务端和客户端都有使用，但是使用的构造方法不一样，这也正和前面的分析一致。用一张图来说明 <code>Messenger</code> 的工作原理：</p>
<p><img src="/img/in-post/post_how_does_messenger_work/how_does_messenger_work.png"></p>
<p>对于这张图说明如下：</p>
<ul>
<li>实现了客户端消息到服务端的传递。</li>
<li>整个过程的实质是两端的 mTarget 通过 Binder 通信，其他对象只是起辅助作用。</li>
</ul>
]]></content>
      <tags>
        <tag>Android</tag>
        <tag>IPC</tag>
        <tag>Binder</tag>
      </tags>
  </entry>
  <entry>
    <title>探究 Java 虚拟机栈</title>
    <url>/2017/03/06/2017-03-06-explore-java-vm-stack/</url>
    <content><![CDATA[<h1 id="探究-Java-虚拟机栈"><a href="#探究-Java-虚拟机栈" class="headerlink" title="探究 Java 虚拟机栈"></a>探究 Java 虚拟机栈</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Java 虚拟机的内存模型分为两部分：一部分是线程共享的，包括 Java 堆和方法区；另一部分是线程私有的，包括虚拟机栈和本地方法栈，以及程序计数器这一小部分内存。今天我就 Java 虚拟机栈做一些比较浅的探究。</p>
<p>熟悉 Java 的同学应该都知道了，JVM 是基于栈的。但是这个“栈” 具体指的是什么？难道就是虚拟机栈？想要回答这个问题我们先要从虚拟机栈的结构谈起。</p>
<span id="more"></span>

<h2 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h2><h3 id="何为虚拟机栈"><a href="#何为虚拟机栈" class="headerlink" title="何为虚拟机栈"></a>何为虚拟机栈</h3><p>虚拟机栈的栈元素是栈帧，当有一个方法被调用时，代表这个方法的栈帧入栈；当这个方法返回时，其栈帧出栈。因此，虚拟机栈中栈帧的入栈顺序就是方法调用顺序。什么是栈帧呢？栈帧可以理解为一个方法的运行空间。它主要由两部分构成，一部分是局部变量表，方法中定义的局部变量以及方法的参数就存放在这张表中；另一部分是操作数栈，用来存放操作数。我们知道，Java 程序编译之后就变成了一条条字节码指令，其形式类似汇编，但和汇编有不同之处：汇编指令的操作数存放在数据段和寄存器中，可通过存储器或寄存器寻址找到需要的操作数；而 Java 字节码指令的操作数存放在操作数栈中，当执行某条带 n 个操作数的指令时，就从栈顶取 n 个操作数，然后把指令的计算结果（如果有的话）入栈。因此，当我们说 JVM 执行引擎是基于栈的时候，其中的“栈”指的就是操作数栈。举个简单的例子对比下汇编指令和 Java 字节码指令的执行过程，比如计算 <code>1 + 2</code>，在汇编指令是这样的：</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mov</span> ax, <span class="number">1</span> <span class="comment">;把 1 放入寄存器 ax</span></span><br><span class="line"><span class="keyword">add</span> ax, <span class="number">2</span> <span class="comment">;用 ax 的内容和 2 相加后存入 ax</span></span><br></pre></td></tr></table></figure>

<p>而 JVM 的字节码指令是这样的：</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">iconst_1</span> <span class="comment">//把整数 1 压入操作数栈</span></span><br><span class="line"><span class="symbol">iconst_2</span> <span class="comment">//把整数 2 压入操作数栈</span></span><br><span class="line"><span class="symbol">iadd</span> <span class="comment">//栈顶的两个数相加后出栈，结果入栈</span></span><br></pre></td></tr></table></figure>

<p>由于操作数栈是内存空间，所以字节码指令不必担心不同机器上寄存器以及机器指令的差别，从而做到了平台无关。</p>
<p>注意，局部变量表中的变量不可直接使用，如需使用必须通过相关指令将其加载至操作数栈中作为操作数使用。比如有一个方法 <code>void foo()</code>，其中的代码为：<code>int a = 1 + 2; int b = a + 3;</code>，编译为字节码指令就是这样的：</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">iconst_1</span> <span class="comment">//把整数 1 压入操作数栈</span></span><br><span class="line"><span class="symbol">iconst_2</span> <span class="comment">//把整数 2 压入操作数栈</span></span><br><span class="line"><span class="symbol">iadd</span> <span class="comment">//栈顶的两个数出栈后相加，结果入栈；实际上前三步会被编译器优化为：iconst_3</span></span><br><span class="line"><span class="symbol">istore_1</span> <span class="comment">//把栈顶的内容放入局部变量表中索引为 1 的 slot 中，也就是 a 对应的空间中</span></span><br><span class="line"><span class="symbol">iload_1</span> <span class="comment">// 把局部变量表索引为 1 的 slot 中存放的变量值（3）加载至操作数栈</span></span><br><span class="line"><span class="symbol">iconst_3</span> </span><br><span class="line"><span class="symbol">iadd</span> <span class="comment">//栈顶的两个数出栈后相加，结果入栈</span></span><br><span class="line"><span class="symbol">istore_2</span> <span class="comment">// 把栈顶的内容放入局部变量表中索引为 2 的 slot 中，也就是 b 对应的空间中</span></span><br><span class="line"><span class="symbol">return</span> <span class="comment">// 方法返回指令，回到调用点</span></span><br></pre></td></tr></table></figure>

<p>需要说明的是，局部变量表以及操作数栈的容量的最大值在编译时就已经确定了，运行时不会改变。并且局部变量表的空间是可以复用的，例如，当指令的位置超出了局部变量表中某个变量 a 的作用域时，如果有新的局部变量 b 要被定义，b 就会覆盖 a 在局部变量表的空间。</p>
<p>盗用别人的图以让大家对虚拟机栈有个直观的认识（其中小字体 Stack 指的的是虚拟机栈，Frame 是栈帧，Local variables 是局部变量表，Operand Stack 是操作数栈）：</p>
<p><img src="/img/in-post/post_java_vm_stack/vm_stack.png" alt="虚拟机栈"></p>
<h2 id="由虚拟机栈引出的问题"><a href="#由虚拟机栈引出的问题" class="headerlink" title="由虚拟机栈引出的问题"></a>由虚拟机栈引出的问题</h2><p>看完上面的代码大家可能会有几点疑惑：什么是 slot？那些指令是什么意思？为什么 <code>a</code> 对应的 slot 的索引值不是从零开始的，它明明是第一个定义的变量啊？</p>
<p>对于这些问题我们一个个来解决。</p>
<h3 id="什么是-slot"><a href="#什么是-slot" class="headerlink" title="什么是 slot"></a>什么是 slot</h3><p>首先什么是 slot？slot 是局部变量表中的空间单位，虚拟机规范中有规定，对于 32 位之内的数据，用一个 slot 来存放，如 <code>int</code>，<code>short</code>，<code>float</code> 等；对于 64 位的数据用连续的两个 slot 来存放，如 <code>long</code>，<code>double</code> 等。引用类型的变量 JVM 并没有规定其长度，它可能是 32 位，也有可能是 64 位的，所以既有可能占一个 slot，也有可能占两个 slot。</p>
<h3 id="JVM-字节码指令"><a href="#JVM-字节码指令" class="headerlink" title="JVM 字节码指令"></a>JVM 字节码指令</h3><p>第二个问题，那些指令是什么意思？</p>
<h4 id="指令格式"><a href="#指令格式" class="headerlink" title="指令格式"></a>指令格式</h4><p>首先我们要理解 Java 指令的格式，Java 的指令以字节为单位，也就是一个字节代表一条指令。比如 <code>iconst_1</code> 就是一条指令，它占一个字节，那么自然 Java 指令不会超过 256 条。实际上 Java 指令目前定义了 200 多条。指令虽然是一个字节，但是它也可以带自己的操作数。JVM 中有这样一条指令 <code>putstatic</code>，其作用是给特定的的静态字段赋值。但是给哪个字段赋值呢？仅仅通过这条指令并不能说明，那么只有通过操作数来指定了。紧跟在 <code>putstatic</code> 后面的两个字节就是它的操作数，这个操作数是一个索引值，指向运行时常量池中该静态字段对应的符号引用。由于符号引用包含了该字段的基本信息，如所属类、简单名称以及描述符，因此 <code>putstatic</code> 指令就知道是给哪个类的哪个字段赋值了。</p>
<p>指令的操作数分两种：一种是嵌入在指令中的，通常是指令字节后面的若干个字节；另一种是存放在操作数栈中的。为了区别，我们把前者叫做直接操作数，把后者叫做栈内操作数。这两者的区别是：直接操作数是在编译时就已经确定的，运行时不会改变，它和指令一样存放于类文件方法表的 Code 属性中；而栈内操作数是运行时确定的，即程序在执行过程中动态生成的。拿 <code>putstatic</code> 指令来说，它有一个直接操作数，该操作数是一个索引值（前面已经提到），它由两个字节组成，紧跟在 <code>putstatic</code> 对应的字节之后；同时它还有一个栈内操作数，位于操作数栈的栈顶，这个操作数就是要赋给静态字段的值，其对应的字节数根据静态字段的类型决定。如果静态字段的类型是 <code>short</code>、<code>int</code>、<code>boolean</code>、<code>char</code> 或者 <code>byte</code>，那么这个操作数就必须是 <code>int</code> 类型，即由栈顶的 4 个字节组成；如果是 <code>float</code>、<code>double</code> 或者 <code>long</code> 类型，那么操作数就是相应的类型，即由栈顶的 4 个、8 个 或者 8 个 字节组成；如果静态字段是引用类型，那么这个操作数的类型也必须是引用类型，即由栈顶的 8 个字节组成。</p>
<p>再举一个例子。<code>iconst_&lt;i&gt;</code> 代表了一个指令族，它的意思是把整数 i 放入操作数栈中，i 的范围是(m1, 0, 1, 2, 3, 4, 5)，其中 m1 代表的是 -1。注意，这里的 i 并不是指令的操作数（即非直接操作数，也非栈内操作数），如 <code>iconst_1</code>、<code>iconst_2</code> 和 <code>iconst_3</code> 都是由一个字节组成的字节码指令。我们可以把 i 可以看作是指令的 “隐含操作数”，即指令本身就蕴含了操作数。如果整数 i 超过 [-1, 5] 这个范围，就不能用 <code>iconst_&lt;i&gt;</code> 表示了，因为仅一个字节的字节码指令不可能蕴含所有的整数。此时就需要 <code>bipush</code> 这条指令了，这条指令有一个直接操作数，由一个字节组成，用来表示要放入栈顶的那个整数，该整数放入栈顶时通过扩展符号位变为 32 位的整型。但是一个字节也表示不了所有的整数，如果整数值超过一个字节所能表示的范围，就只能通过 <code>ldc</code> 这条指令了，这条指令带有一个字节的直接操作数，它代表的是一个指向运行时常量池中 <code>Constant_Integer_info</code> 类型常量的索引，通过索引的方式引用运行时常量池中的整数，再大的整数也不怕了。</p>
<h4 id="阅读指令文档"><a href="#阅读指令文档" class="headerlink" title="阅读指令文档"></a>阅读指令文档</h4><p>授之以鱼不如授之以渔，在这里不可能将所有的指令都讲解一番，因此我和大家分享一下如何阅读 oracle 官网关于字节码指令的文档吧。文档的地址是：<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html</a></p>
<p>我们拿 <code>astore</code> 指令来说：<br>关于它的文档描述如下：</p>
<p><img src="/img/in-post/post_java_vm_stack/java_instruction_astore.png" alt="astore 指令"></p>
<p>说明和翻译：</p>
<ul>
<li>第一行的粗体字是指令的名称；</li>
<li>Operation 是指令的功能：把引用存入本地变量中；</li>
<li>Format 是指令的格式：它的第一个字节是指令，名称为 <code>astore</code>，第二个字节是指令的直接操作数，名称为 index；Forms 指的是指令的十进制（十六进制）码，<code>astore</code> 的十进制（十六进制）码是 <code>58（0x3a)</code>；</li>
<li>Operation Stack 是指令执行前后的操作数栈的状态：第一行代表的是指令执行前操作数的状态，第二行是指令执行后操作数栈的状态，箭头是栈顶方向。<code>astore</code> 执行前栈顶是对象引用 objectRef，它是 <code>astore</code> 的栈内操作数，执行后 objectRef 被弹出并存入局部变量表中；</li>
<li>Description 是对这条指令的描述：index 是无符号字节，这个 index 必须指向当前栈帧的局部变量表的某个位置。操作数栈的栈顶的那个引用值必须是 returnAddress（方法返回地址）或者是 reference （对象引用）。这个引用会被弹出，其值会被存入局部变量表中索引为 index 的 slot 中；</li>
<li>Notes 是注意事项：实现 Java 中的 <code>finally</code> 子句时，<code>astore</code> 指令使用的操作数类型是一个 returnAddress，与 <code>astore</code> 对应的 <code>aload</code> 指令（将局部变量表的的引用值压栈）不能将类型为 returnAddress 类型的值加载到操作数栈，而只能是 reference 类型。<code>aload</code> 和 <code>astore</code> 这种不对称的设计是有意而为之的。<code>astore</code> 指令可以和 <code>wide</code> 指令配合使用以用无符号双字节类型的索引来获取局部变量表中的变量。</li>
</ul>
<h3 id="局部变量表的第一个变量"><a href="#局部变量表的第一个变量" class="headerlink" title="局部变量表的第一个变量"></a>局部变量表的第一个变量</h3><p>从 Java 语言的层面讲，静态方法和实例方法的本质区别在于是否是对象所共享的。而从 JVM 的角度来看，方法（无论静态方法还是实例方法）其实都是对象共享的，实例变量才是对象私有的。对 JVM 而言，静态方法和实例方法的本质区别在于是否需要和具体对象关联：静态方法可以通过类名来调用，它不需要和具体对象关联；而实例方法必须通过对象来进行调用，它需要和具体对象关联。那么，实例方法和具体对象是如何产生关联的呢？其实很简单，编译器在编译时会将方法接收者作为一个隐含参数传入该实例方法，这个参数在方法中有一个很熟悉的名字，叫做 “this”。之所以实例方法可以访问该类的实例变量和其它实例方法，正是因为它有 “this” 这个隐含参数。举个例子，类 <code>A</code> 中的某个方法 <code>b</code> 需要访问实例变量 <code>x</code>，由于实例变量是对象私有的，如果 <code>b</code> 是静态方法，由于它没有具体对象的引用，它并不知道该访问哪个对象的实例变量 <code>x</code>；如果 <code>b</code> 是实例方法，通过隐含参数 <code>this</code> 就能确定要访问的实例变量是 <code>this.x</code>。那么，为什么静态方法也不能调用该类的实例方法呢？本质原因也是没有 <code>this</code> 引用。因为调用实例方法的前提是要传入一个隐含参数，实例方法本来就有这个引用，所以能够把它作为隐含参数传入另一个实例方法；静态方法没有 <code>this</code> 引用，无法给实例方法提供指向方法接收者的隐含参数，因此不能调用实例方法。</p>
<p>如果看懂了上面说的那些，第三个问题也就迎刃而解了。因为我们定义的方法是 <code>void foo()</code>，它是实例方法，因此会有一个指向具体对象的隐含参数 <code>this</code>，<code>this</code> 就存放在局部变量表的第一个位置，即存放在索引为 0 的 slot 中，又由于它的作用域从方法开始一直到方法结束，因此它在局部变量表中的位置不会被其他变量覆盖，从而使得我们在方法中定义的变量只能放在局部变量表后面的位置中。需要注意的是，如果方法有参数（非隐含参数），那么参数会按顺序紧接着 <code>this</code> 存放在局部变量表中，由于参数作用域也是整个方法体，所以方法中定义的局部变量就只能放在参数后面了。总的来说局部变量表中变量的存放顺序为： <code>this</code>（如果是实例方法）=&gt; 参数（如果有的话）=&gt; 定义的局部变量（如果有的话）。</p>
<h2 id="感谢阅读"><a href="#感谢阅读" class="headerlink" title="感谢阅读"></a>感谢阅读</h2><p>关于虚拟机栈就讲这么多了，Java 虚拟机是一个完整的知识体系，仅仅了解虚拟机栈是不够的，这里没有细讲的关于虚拟机的其它知识，如内存模型、运行时常量池、类加载模型等，还需读者自己学习掌握。这篇文章权起激发大家的学习 JVM 兴趣的作用，同时也作为个人的学习记录和知识总结。之后可能还会写些 JVM 其它方面的总结性文章和大家分享。由于个人水平和理解有限，如果有不对的地方还请大家不吝赐教，感谢阅读！</p>
<p><strong>参考书籍</strong> :《深入理解 Java 虚拟机》周志明 著<br><strong>Java 虚拟机规范</strong> : <a href="https://docs.oracle.com/javase/specs/jvms/se8/html/index.html">The Java® Virtual Machine Specification</a></p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>动态加载应用之简单热更新</title>
    <url>/2017/03/09/2017-03-09-android-hot-fix/</url>
    <content><![CDATA[<h1 id="动态加载应用之简单热更新"><a href="#动态加载应用之简单热更新" class="headerlink" title="动态加载应用之简单热更新"></a>动态加载应用之简单热更新</h1><p>在之前的一片文章中，我和大家分享了<a href="/2016/11/11/android-load-class-dynamically/">安卓动态加载的原理</a>，这篇文章就和大家分享一下动态加载在热更新方面的应用，我会通过一个假想的案例来演示如何在项目利用动态加载实现热更新。</p>
<span id="more"></span>

<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>某项目需要对某些数据集进行排序，但由于时间原因，开发团队使用了一个比较基础的算法实现该排序功能。上线之后才发现该排序算法的性能太差，影响了用户体验，因此开发团队不得不对该算法进行优化。优化后的新版本经过测试、发布、审核成功上线，但对项目进度造成了一定的影响。经历这次事件之后，开发团队吸取了教训：对于经常变动或者需要后期优化的功能，采用热更新技术避免重新发布新版本，从而降低人力成本。接下来我就用一个 demo 来模拟开发团队这次热更新技术的应用。</p>
<h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><h3 id="在项目中插入热更新逻辑"><a href="#在项目中插入热更新逻辑" class="headerlink" title="在项目中插入热更新逻辑"></a>在项目中插入热更新逻辑</h3><p>因为热更新需要从外部加载代码，而项目中的原本的代码并不能预知外部代码细节，因此我们需要定义一份接口实现项目中的代码和外部代码的对接。定义的接口如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Sort</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">getName</span><span class="params">()</span></span>; <span class="comment">// 获取排序算法的名称</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> a[])</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不同的排序策略可以对该接口采用不同的实现，我们当前在项目采用的排序策略是插入排序，其实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InsertSort</span> <span class="keyword">implements</span> <span class="title">Sort</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;插入排序&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; a.length; i ++) &#123;</span><br><span class="line">            <span class="keyword">int</span> key = a[i];</span><br><span class="line">            <span class="keyword">int</span> pos = i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i - <span class="number">1</span> ; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (a[j] &lt; key) <span class="keyword">break</span>;</span><br><span class="line">                a[j + <span class="number">1</span>] = a[j];</span><br><span class="line">                pos = j;</span><br><span class="line">            &#125;</span><br><span class="line">            a[pos] = key;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;I&#x27;m InsertSort&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>把以上两个类放入项目中，同时创建一个 <code>SortActivity</code>，在该 <code>Activity</code> 中对排序算法进行了应用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SortActivity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>[] collection = &#123;<span class="number">21</span>, <span class="number">70</span>, <span class="number">1</span>, <span class="number">88</span>, <span class="number">4</span>, <span class="number">54</span>, <span class="number">22</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">104</span>, <span class="number">37</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(<span class="meta">@Nullable</span> Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_dynamic_loading);</span><br><span class="line">        TextView tvResult = (TextView) findViewById(R.id.tv_result);</span><br><span class="line">        </span><br><span class="line">        Sort sort = getDefaultSort();</span><br><span class="line">        sort.sort(collection);</span><br><span class="line">        <span class="comment">// 显示排序结果</span></span><br><span class="line">        StringBuilder result = <span class="keyword">new</span> StringBuilder(sort.getName() + <span class="string">&quot;: &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; collection.length; i++) &#123;</span><br><span class="line">            result.append(collection[i]);</span><br><span class="line">            <span class="keyword">if</span> (i != collection.length - <span class="number">1</span>) result.append(<span class="string">&quot;, &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        tvResult.setText(result.toString());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> Sort <span class="title">getDefaultSort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> InsertSort();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码和采用热更新技术之前的项目代码无异，为了达到热更新的目的，我们要把关于热更新这一部分的逻辑写在程序中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(<span class="meta">@Nullable</span> Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_dynamic_loading);</span><br><span class="line">    </span><br><span class="line">    Sort sort;</span><br><span class="line">    <span class="keyword">if</span> (hasUpdate()) &#123; <span class="comment">//如果排序算法有更新</span></span><br><span class="line">        sort = getNewSort(); <span class="comment">// 应用新的排序算法</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        sort = getDefaultSort(); <span class="comment">// 否则用默认实现的排序算法</span></span><br><span class="line">    &#125;</span><br><span class="line">    sort.sort(collection)</span><br><span class="line">    <span class="comment">// 显示排序结果</span></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Sort <span class="title">getNewSort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Sort newSort = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Class&lt;?&gt; clazz = getNewSortClass(); <span class="comment">// 获取新的 Sort 实现类</span></span><br><span class="line">        newSort = (Sort) clazz.newInstance(); <span class="comment">// 创建该实现类的实例</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newSort; <span class="comment">// 用新的排序算法实现排序</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">hasUpdate</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 根据需求自行实现，如询问服务器，这里通过读取配置文件内容模拟向服务器询问的过程</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 读取配置文件，默认值为 0，即没有更新</span></span><br><span class="line">        FileReader reader = <span class="keyword">new</span> FileReader(Environment.</span><br><span class="line">            getExternalStorageDirectory().getAbsolutePath()</span><br><span class="line">            + File.separator + <span class="string">&quot;has_update.txt&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> hasUpdate = reader.read();</span><br><span class="line">        System.out.println(<span class="string">&quot;hasUpdate:&quot;</span> + hasUpdate);</span><br><span class="line">        <span class="keyword">return</span> hasUpdate == <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> Class&lt;?&gt; getNewSortClass() <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="comment">// 从服务器下载到本地磁盘</span></span><br><span class="line">    downLoadCodeFromServer();</span><br><span class="line">    <span class="comment">// 假定下载的 .dex 文件在外部存储的根目录下，文件名为 newsort.dex</span></span><br><span class="line">    String path =  Environment.getExternalStorageDirectory().getAbsolutePath() </span><br><span class="line">            + File.separator + <span class="string">&quot;newsort.dex&quot;</span>;</span><br><span class="line">    <span class="comment">// .dex 文件优化输出后的目录为 “optimized_dir”</span></span><br><span class="line">    String optimizedDir = getDir(<span class="string">&quot;optimized_dir&quot;</span>, MODE_PRIVATE).getAbsolutePath();</span><br><span class="line">    <span class="comment">// 创建一个 DexClassLoader，用来加载从网络上下载的 .dex 文件</span></span><br><span class="line">    DexClassLoader loader = <span class="keyword">new</span> DexClassLoader(path, optimizedDir, <span class="keyword">null</span>, getClassLoader);</span><br><span class="line">    <span class="comment">// 新的排序实现类的全名为 me.liwenkun.demo.NewSort，该名称也可从服务端或通过其他方式动态</span></span><br><span class="line">    <span class="comment">// 获取，这里为了简化我们约定新的实现类的类名必须是 NewSort</span></span><br><span class="line">    loader.loadClass(<span class="string">&quot;me.liwenkun.demo.NewSort&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于上面的代码，需要说明几点：</p>
<ul>
<li>为了方便，我把网络请求和文件读取放在了主线程中，实际项目中不可能这样做；</li>
<li>我忽略了权限相关的问题，大家在 demo 中一定要注意读写权限的配置，特别是 6.0 之后的动态权限申请，否则很可能导致热更新失败；</li>
<li>优化后的输出目录一定要是私有的内部存储目录，否则在高版本的系统中会有运行时错误，因为这被认为是不安全的；从服务器下载的 .dex 的位置虽然没有限制，但安全起见最好也放置在内部私有目录中，本例中为了方便起见直接放在外部存储的根目录下（否则手机得 root）；</li>
<li>如果关于 <code>DexClassLoader</code> 这个类加载器的原理和用法不熟悉的话，最好先看看我的<a href="/2016/11/11/android-load-class-dynamically/">这篇文章</a>。</li>
</ul>
<p>至此，项目中关于热更新的逻辑就写完了。现在我们模拟上线，把应用装进手机并运行，结果如下图：</p>
<p><img src="/img/in-post/post_android_dynamically_loading_practice/insert.jpg"></p>
<h3 id="实施热更新"><a href="#实施热更新" class="headerlink" title="实施热更新"></a>实施热更新</h3><p>如果现在觉得这种排序算法还不够好，只需将新的 <code>Sort</code> 实现类编译成 .dex 文件发送给客户端就可以了，不必推送新的版本。比如我想用希尔排序取代插入排序，于是在项目中编写了 <code>NewSort</code> 类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewSort</span> <span class="keyword">implements</span> <span class="title">Sort</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;希尔排序&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> N;</span><br><span class="line">        <span class="keyword">for</span>(N = a.length; h &lt; N / <span class="number">25</span>; h = h * <span class="number">3</span> + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(h &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = h; i &lt; N; ++i) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &gt;= h &amp;&amp; a[j] &lt; a[j - h]; j -= h) &#123;</span><br><span class="line">                    exch(a, j, j - h);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            h /= <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">exch</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> src, <span class="keyword">int</span> dest)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = a[src];</span><br><span class="line">        a[src] = a[dest];</span><br><span class="line">        a[dest] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译之后，我们需要将此类以 jar 包的形式输出，为之后生成 .dex 文件做好准备。因此我们找到 Android Studio 的编译输出文件夹（我这里的位置是 <code>Demo/app/build/intermediates/classes/debug/</code>），找到 NewSort.class，连同 package 将其移出，结果如下图所示：</p>
<p><img src="/img/in-post/post_android_dynamically_loading_practice/structure.png"></p>
<p>在 me 的上一级目录处打开终端，输入命令 <code>jar cf newsort.jar me</code>，执行完后我们在与 me  同级的位置可以看到打包好的 newsort.jar 文件。（关于 .jar 文件的打包可以参考 <a href="/2016/11/05/compile-java-through-command-line/">命令行编译、打包并运行一个 java 程序</a> 这篇文章。）</p>
<p>接下来我们进入 sdk 目录，找到 build-tools 文件夹，该文件夹下有各个版本的 build-tools，如下图所示，我们选择最新的 25.0.2，进入之后会发现有一个名为 dx 的工具，它可以将 jar 包转换成 .dex 文件。所以把我们的 newsort.jar 放入 25.0.2 目录下，然后在 25.0.2 这个目录位置打开终端，输入命令 <code>./dx --dex --output=/Users/lwenkun/desktop/newsort.dex newsort.jar </code> ，命令执行完后在 desktop 文件夹下（也就是桌面）可以看到生成了 newsort.dex 文件，这个文件就是我们最终需要的。</p>
<p><img src="/img/in-post/post_android_dynamically_loading_practice/build-tools.png"></p>
<p>准备好了 .dex 文件后，我们就可以模拟热更新了。我们假设 .dex 文件已经从服务器下载到了本地，因此直接把 newsort.dex 文件拷贝到手机外部存储的根目录下。然后修改根目录下的 has_update.txt 文件，将其中的值修改为 1。然后我们退出应用，等再次打开应用时，插入排序已经成功替换成了希尔排序：</p>
<p><img src="/img/in-post/post_android_dynamically_loading_practice/shell.jpg"></p>
<h2 id="感谢阅读"><a href="#感谢阅读" class="headerlink" title="感谢阅读"></a>感谢阅读</h2><p>动态加载在热更新方面的应用就分享到这里了，网上关于这方面的文章也有很多，大家可以找写这方面的文章看看。由于水平和理解能力有限，有什么不对的地方还望大家不吝赐教，感谢大家的阅读。</p>
<p>参考资料：<a href="https://www.google.com/search?q=%E5%AE%89%E5%8D%93%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD&oq=%E5%AE%89%E5%8D%93%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD&aqs=chrome..69i57j69i61.302j0j9&sourceid=chrome&ie=UTF-8">安卓动态加载</a></p>
]]></content>
      <tags>
        <tag>Android</tag>
        <tag>动态加载</tag>
        <tag>热更新</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 8 方法引用</title>
    <url>/2017/03/23/2017-03-23-java-8-method-references/</url>
    <content><![CDATA[<h1 id="Java-8-方法引用"><a href="#Java-8-方法引用" class="headerlink" title="Java 8 方法引用"></a>Java 8 方法引用</h1><p>形如 <code>ClassName::methodName</code> 或者 <code>objectName::methodName</code> 的表达式，我们把它叫做方法引用（Method Reference）。可能你现在还理解不了，但是编译器足够聪明，或许你可以看看编译器是如何根据 “晦涩难懂” 的 Method Reference 来推断你的意图的。</p>
<span id="more"></span>

<h2 id="方法引用的种类"><a href="#方法引用的种类" class="headerlink" title="方法引用的种类"></a>方法引用的种类</h2><p>方法引用有四种，分别是：</p>
<ul>
<li>指向静态方法的引用</li>
<li>指向某个对象的实例方法的引用</li>
<li>指向某个类型的实例方法的引用</li>
<li>指向构造方法的引用</li>
</ul>
<p>下面通过一些代码示例来和大家分享一下这四种引用使用场景，先定义一个 <code>Person</code> 类，后面我们会用到它：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">compareName</span><span class="params">(Person a, Person b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.getName().compareTo(b.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="指向静态方法的引用"><a href="#指向静态方法的引用" class="headerlink" title="指向静态方法的引用"></a>指向静态方法的引用</h3><p>形式：<code>ContainingClass:staticMethodName</code></p>
<p>如果要想实现一群人按名字排序，一般你会这么做：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Arrays.sort(personArray, <span class="keyword">new</span> Comparator() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Person a, Person b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.getName().compareTo(b.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>第二个参数很复杂，但是目的却很简单：实现 <code>Comparator</code> 的一个比较方法。我们自然会想——相信很多程序员都会这么想：有没有一种方法能够既简单明了又能无歧义的表达我们的意图？当然有，Java 8 引入的 lambda 表达式便很好的简化了我们的代码，瞧：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Array.sort(personArray, (a, b) -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> a.getName().compareTo(b.getName());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><code>(a, b)</code> 是 lambda 表达式的参数列表，箭头后的是方法体。编译器已经被训练得足够聪明：它知道 <code>(a, b)</code> 就是代表着要比较的两个 <code>Person</code> 对象。它在脑海里构想出了这个 lambda 表达式的 “原型”：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Comparator() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Person a, Person b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.getName().compareTo(b.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>机智的编译器从简化的代码中推断出了 <code>Comparator</code> 对象的 “原型”。但是程序员并不满足：还能不能进一步简化？当然可以，在不造成歧义的前提下可以无限地简化一个语法。我们注意到，<code>Person</code> 类有一个静态方法可以用来实现两个对象的比较，于是引入 <strong>指向静态方法的引用</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Arrays.sort(personArray, Person::compareName);</span><br></pre></td></tr></table></figure>

<p><code>Person.compareName()</code> 方法有两个 <code>Person</code> 类型的参数，一个 <code>int</code> 类型的返回值，所以<br><code>Person::compareName</code> 这个方法引用拥有两个 <code>Person</code> 类型的不确定量（在这里指的就是 <code>compareName()</code> 的两个参数；文章末尾有关于不确定量的具体解释）和一个 <code>int</code> 类型的返回值。而 <code>Comparator</code> 中待实现的方法 <code>compare()</code> 也有两个 <code>Person</code> 类型的参数和一个 <code>int</code> 的返回值。方法引用和 <code>Comparator</code> 中要实现的方法有足够的相似度，因此编译器将 <code>Person::compareName</code> 的不确定量和返回值与 <code>compare()</code> 的参数和返回值对应了起来，由此推断出我们的意图是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Arrays.sort(personArray, <span class="keyword">new</span> Comparator() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Person a, Person b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Person.compareName(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>编译器成功地识别了程序员的意图。但是编译器的聪明程度也是有限的，假如方法引用所对应的静态方法返回值不是 <code>int</code> 而是 <code>boolean</code>，那么编译器无法将该方法引用还原为一个 <code>Comparator</code> 对象，因为它并不知道该返回什么 <code>int</code> 值。幸亏我们提供的静态方法引用有 <code>int</code> 类型的返回值，编译器还原时就可以把它返回。</p>
<h3 id="指向某个对象的实例方法的引用"><a href="#指向某个对象的实例方法的引用" class="headerlink" title="指向某个对象的实例方法的引用"></a>指向某个对象的实例方法的引用</h3><p>形式：<code>containingObject::instanceMethodName</code></p>
<p>有一个比较器，它可以比较多种对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> class <span class="title">Comparator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">comarePerson</span><span class="params">(Person a, Person b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.getName().compareTo(b.getName());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareDog</span><span class="params">(Dog a, Dog b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.getName().compareTo(b.getName());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的 <code>Dog</code> 类和 <code>Person</code> 类结构相似，所以代码就省略了。现在我们要根据一群狗的名字给它们排序，我们同样使用方法引用（当然，你依旧可以用 lambda 表达式），但是这次是 <strong>指向某个对象的实例方法的引用</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Comparator aComparator = <span class="keyword">new</span> Comparator(); <span class="comment">// 实例化一个比较器</span></span><br><span class="line"><span class="comment">// aComparator::compareDog 是指向实例对象 aComparetor 的实例方法</span></span><br><span class="line"><span class="comment">// compareDog() 的方法引用</span></span><br><span class="line">Arrays.sort(dogs, aComparator::compareDog); </span><br></pre></td></tr></table></figure>

<p><code>compareDog()</code> 方法的两个参数是 <code>Dog</code> 类型，返回值为 <code>int</code>，也就是说 <code>aComparator::compareDog</code> 有两个 <code>Dog</code> 类型的不确定量和一个 int 类型的返回值。而 <code>Comparator</code> 中的 <code>compare()</code> 方法也是接受两个 <code>Dog</code> 对象，返回一个 <code>int</code> 值。根据这些线索编译器足够推断出我们的意图：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Arrays.sort(dogs, <span class="keyword">new</span> Comparator() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Dog a, Dog b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> aComparator.compareDog(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="指向某个类型的实例方法的引用"><a href="#指向某个类型的实例方法的引用" class="headerlink" title="指向某个类型的实例方法的引用"></a>指向某个类型的实例方法的引用</h3><p>形式：<code>ContainingClass::instanceMethodName</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream.of(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;is&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;dog&quot;</span>).reduce(<span class="string">&quot;&quot;</span>, <span class="keyword">new</span> BinaryOperator() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">apply</span><span class="params">(String a, String b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.toUpperCase() + b.toUpperCase();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><code>reduce()</code> 方法是把某类型对象的集合降解为一个对象，过程是两两合并。它的第一个参数为初始值，第二个参数是一个接口，用来定义两两合并的具体策略。如果你暂时不懂 <code>Stream</code> 以及它的 <code>reduce()</code> 方法也没关系，我们只关注它的第二个参数。我们实现 <code>BinaryOperator</code> 接口的方法是把两个字符串变成大写后连接起来。代码看起来很臃肿，但是没有办法，我们没有合适的方法引用来将它简化（现有方法中没有能够将两个字符串先转换成大写然后连接的，当然你可以自己实现一个这样的方法，但没必要，因为这样会使得代码更加复杂），顶多可以转化成 lambda 表达式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream.of(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;is&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;dog&quot;</span>).reduce(<span class="string">&quot;&quot;</span>, (a, b) -&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> a.toUpperCase() + b.toUpperCase();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>但是如果两两合并的方式是直接将两个字符串连接的话，情况就不同了。我们可以用 <code>String::concat</code> 这个 <strong>指向某个类型的实例方法的引用</strong> 来使代码更简洁：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream.of(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;is&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;dog&quot;</span>).reduce(<span class="string">&quot;&quot;</span>, String::concat);</span><br></pre></td></tr></table></figure>

<p>编译器看看这行代码，愣了一下，不知道如何转化。还好，我们的编译器足够聪明，眼珠一转分析了下：我们要实现的方法有两个 <code>String</code> 的参数，一个 <code>String</code> 类型的返回值，而 <code>String::concat</code> 也有两个 <code>String</code> 类型的不确定量和一个 <code>String</code> 类型的返回值，其中一个不确定量是由于 <code>concat()</code> 这个方法是实例方法导致的，因为它必须通过一个 <code>String</code> 实例来调用；另一个不确定量为 <code>concat()</code> 方法的参数，它接受一个 <code>String</code> 类型的参数。以上信息足够编译器来推断我们的意图：程序员一定是想把两个参数和 <code>String::concat</code> 的两个不确定量对应起来，一个作为 <code>concat()</code> 方法调用的接收者，一个作为 <code>concat()</code> 方法的参数。这样一来上面的代码就转化成这样了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream.of(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;is&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;dog&quot;</span>).reduce(<span class="string">&quot;&quot;</span>, <span class="keyword">new</span> BinaryOperator() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">apply</span><span class="params">(String a, String b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.concat(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>Wonderful ！程序员正是这么想的。有心的程序员可能会发出疑问：根据编译器的推断思路，对于任意一个方法引用，是不是只要它有两个 <code>String</code> 类型的不确定量和一个 <code>String</code> 类型返回值（当然类型要为 <code>String</code>）就可以作为参数传入 <code>reduce()</code> 了呢？于是程序员想了个方法来测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream.of(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;is&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;dog&quot;</span>).reduce(<span class="string">&quot;&quot;</span>, Test::test);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">test</span><span class="params">(String a, String b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.concat(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序员在 IDE 中写下上面的代码后，编译器没有错误提示 =&gt; 编译后通过 =&gt; 猜想正确。原因是 <code>Test</code> 的 <code>test()</code> 是一个静态方法，它有两个 <code>String</code> 类型的参数，一个 <code>String</code> 类型的返回值，也就是说 <code>Test::test</code> 有两个 <code>String</code> 类型的不确定量和一个 <code>String</code> 类型的返回值，因此编译器推断出程序员的意图是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream.of(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;is&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;dog&quot;</span>).reduce(<span class="string">&quot;&quot;</span>, <span class="keyword">new</span> BinaryOperator() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">apply</span><span class="params">(String a, String b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Test.test(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="指向构造方法的引用"><a href="#指向构造方法的引用" class="headerlink" title="指向构造方法的引用"></a>指向构造方法的引用</h3><p>形式：<code>ClassName::new</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream.of(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;is&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;dog&quot;</span>).toArray(<span class="keyword">new</span> IntFunction&lt;String[]&gt;() &#123;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="keyword">public</span> String[] apply(<span class="keyword">int</span> value) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">null</span>; </span><br><span class="line">     &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><code>toArray()</code> 方法的作用是把数据流转换成一个数组，它接收的参数是一个 <code>IntFunction</code> 的接口实现对象。该接口有一个待实现的方法 <code>apply()</code>，它有一个 <code>int</code> 型的参数和一个 <code>String[]</code> 类型的返回值。我们依旧可以用方法引用来代替它，但这次我们用的是 <strong>指向构造方法的引用</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream.of(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;is&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;dog&quot;</span>).toArray(String[]::<span class="keyword">new</span>);</span><br></pre></td></tr></table></figure>

<p>指向构造方法的引用可能较其他方法引用难理解一点，但是编译器却很机智的猜测到了程序员的意图：<code>String[]::new</code> 这个 指向构造方法的引用 有一个 <code>int</code> 类型的不确定量，即数组的长度；有一个 String[] 类型的返回值（构造方法不会有返回值，但是指向构造方法的引用却返回了一个该类型的实例）。因此编译器这样还原此方法引用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream.of(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;is&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;dog&quot;</span>).toArray(<span class="keyword">new</span> IntFunction&lt;String[]&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] apply(<span class="keyword">int</span> value) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String[value];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实，JVM 本身并不支持指向方法引用，过去不支持，现在也不支持。Java 8 对方法引用的支持知识编译器层面的支持，虚拟机执行引擎并不了解方法引用。编译器遇到方法引用的时候，会像上面那样自动推断出程序员的意图，将方法引用还原成 <strong>接口实现对象</strong>，或者更形象地说，就是把方法引用设法包装成一个接口实现对象，这样虚拟机就可以无差别地执行字节码文件而不需要管什么是方法引用了。</p>
<p>需要注意的是，方法引用是用来简化接口实现代码的，并且凡是能够用方法引用来简化的接口，都有这样的特征：有且只有一个待实现的方法。这种接口在 Java 中有个专门的名称： <strong>函数式接口</strong>。当你用试图用方法引用替代一个非函数式接口时，会有这样的错误提示： <font color="red">xxx is not a functional interface</font>。</p>
<p>文章中很多地方提到过 <strong>不确定量</strong> 这个名词，这个名词并非官方的，而是我为了更好地说明问题而引入的，它的意思是： <strong>方法引用在转换成接口实现对象的过程中需要确定的变量</strong>。如 <strong>方法引用所对应方法的接受者</strong>（ <strong>指向静态方法的引用</strong> 和 <strong>指向某个对象的实例方法的引用</strong> 没有该不确定量，因为前者不需要接受者，而后者接受者已经确定），以及 <strong>方法引用所对应方法的参数</strong> 都属于 <strong>不确定量</strong>。方法引用的 <strong>不确定量</strong> 以及返回值需要和接口中的待实现方法的参数和返回值对应起来，这样编译器才能成功将其还原。</p>
<h2 id="感谢阅读"><a href="#感谢阅读" class="headerlink" title="感谢阅读"></a>感谢阅读</h2><p>写这篇文章的目的是让大家对方法引用有一个更好的理解，同时也作为个人的学习记录，但由于理解和水平有限，差错在所难免，还请大家不吝赐教。最后，感谢大家的阅读。</p>
<p><strong>参考文章:</strong><br><a href="http://docs.oracle.com/javase/tutorial/java/javaOO/methodreferences.html">Method References</a><br><a href="http://stackoverflow.com/questions/20001427/double-colon-operator-in-java-8">:: (double colon) operator in Java 8</a>  </p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>Method Reference</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统原理总结</title>
    <url>/2017/05/30/2017-05-30-operating-system-conclusion/</url>
    <content><![CDATA[<h1 id="操作系统原理总结"><a href="#操作系统原理总结" class="headerlink" title="操作系统原理总结"></a>操作系统原理总结</h1><p>对课本知识的概括和总结，来自《操作系统原理》第四版 —— 庞丽萍著</p>
<span id="more"></span>
<h2 id="用户环境"><a href="#用户环境" class="headerlink" title="用户环境"></a>用户环境</h2><p>操作系统的生成：</p>
<ul>
<li><p>系统生成</p>
</li>
<li><p>根据计算机的硬件配置选择相应的功能模块来组装成一个可利用的操作系统</p>
</li>
<li><p>硬件配置信息可通过从文件读取或者系统程序员</p>
</li>
<li><p>系统初启</p>
</li>
<li><p>引导程序 =&gt; 系统核心 =&gt; 核心初始化</p>
</li>
<li><p>核心初始化：先建立 0# 进程（永远处于核心态，换页），再建立 1# 进程（初始化进程，实现系统初始化，负责为终端建立子进程）</p>
</li>
<li><p>用户程序的运行过程</p>
</li>
<li><p>编写源程序</p>
</li>
<li><p>将源程序记录在某种介质上</p>
</li>
<li><p>控制计算机工作，加工，得到计算结果</p>
<ul>
<li>编译</li>
<li>链接<ul>
<li>静态链接：将外部调用函数链接到目标文件中形成一个完整的主存映像文件</li>
<li>动态链接：运行时将动态链接库加载并链接到目标程序中</li>
</ul>
</li>
<li>运行</li>
</ul>
</li>
<li><p>操作系统的用户界面</p>
</li>
<li><p>定义：用户和计算机打交道的外部机制。和用户上机类型和操作系统的的类型有关</p>
</li>
<li><p>系统提供的用户界面：操作命令、系统功能调用</p>
</li>
<li><p>系统功能调用</p>
</li>
<li><p>用户程序调用系统例程，由用户态进入管态</p>
</li>
<li><p>系统调用的实现：用户程序（用户态） =&gt; 发出自愿访管命令 =&gt; 访管中断程序保护现场，查找例行子程序入口地址表获取系统例程的入口地址 =&gt; 根据入口地址进行系统调用（管态） =&gt; 结果返回访管中断程序 =&gt; 恢复用户程序现场（用户态）</p>
</li>
</ul>
<h2 id="并发处理"><a href="#并发处理" class="headerlink" title="并发处理"></a>并发处理</h2><p>提高计算机的处理能力和机器的利用率，但容易造成错误。</p>
<ul>
<li><p>并发的特点</p>
</li>
<li><p>失去程序的封闭性：计算结果不再和时间无关，依赖于各程序的相对执行速率</p>
</li>
<li><p>程序和计算不再一一对应：过个计算可以公用一个程序</p>
</li>
<li><p>程序并发执行的相互制约</p>
</li>
<li><p>进程</p>
</li>
<li><p>进程的定义</p>
<ul>
<li>一个程序在给定的空间和初始环境下，在一个处理机上的执行过程</li>
<li>进程是指一个具有一定独立功能的程序关于某个数据集合的一次运行活动</li>
</ul>
</li>
<li><p>进程和程序的区别：</p>
<ul>
<li>程序是指令的有序集合，其本身没有任何运行的含义，它是一个静态的概念，可永久保存</li>
<li>进程是程序（指令）在处理机上的一次执行的过程，是动态的概念，有生命周期，动态地产生和消亡</li>
<li>进程是独立运行的单位，能与其他进程并行的活动</li>
<li>进程是竞争计算机系统有限资源的基本单位，也是进行处理机调度额基本单位</li>
<li>多任务的操作系统中，活动的最小单位是进程，进程一定包含一个程序，程序是进程应完成的功能的逻辑描述；一个程序可以多应多个进程</li>
</ul>
</li>
<li><p>进程的类型</p>
<ul>
<li>用户进程：为用户算题任务建立的进程</li>
<li>系统进程：资源管理和控制作用</li>
</ul>
</li>
<li><p>进程的状态</p>
<ul>
<li>进程的基本状态：等待状态=&gt;就绪状态&lt;=&gt;运行状态=&gt;等待状态</li>
</ul>
</li>
<li><p>进程的描述：进程控制块，是一个和进程对应的实体，记录进程的各种状态信息</p>
</li>
<li><p>线程概念及特点</p>
<ul>
<li>什么是线程<ul>
<li>线程是比进程更小的活动单位，它是进程中的一个执行路径。一个进程可以有多条的执行路径，每条路径就是一条线程</li>
<li>线程有自己的堆栈和处理机执行环境（尤其是处理器寄存器）</li>
<li>共享分配给父进程的主存</li>
<li>若系统支持线程运行，那么每个进程至少有一个执行线程</li>
</ul>
</li>
</ul>
</li>
<li><p>线程的特点及状态</p>
<ul>
<li>线程的特点<ul>
<li>开销小，共享进程的程序和全局数据</li>
<li>可以提高系统的并行处理能力</li>
<li>线程拥有私有的指令计数器、私有的栈区、私有的寄存器集合和地址区域</li>
</ul>
</li>
</ul>
</li>
<li><p>线程的状态以及变迁</p>
<ul>
<li>创建，建立一个新的线程，新生的线程处于新建状态</li>
<li>就绪，线程处于就绪队列中，等待被调度      </li>
<li>运行，一个线程正占用 CPU，执行它的程序</li>
<li>等待，一个正在执行的线程如果发生某些事件，如被挂起或者需要执行费时的输入输出操作</li>
<li>终止，线程已经退出，但该信息还没有被其他线程所收集</li>
</ul>
</li>
<li><p>用户线程和内核线程</p>
<ul>
<li>用户线程是在内核的支持下，在用户层通过线程库来实现的。线程库提供对线程的创建、调度和管理等方面的支持。用户线程对内核来说是透明的，即内核并不知道线程的存在。相当于在单线程的进程中模拟多线程，这种线程不是 CPU 调度的单位，调度单位依然是线程</li>
<li>内核线程是内核可感知的，由操作系统直接支持，在内核空间内执行线程的创建、调度和管理</li>
<li>内核线程的创建、调度以及管理要比用户线程慢</li>
</ul>
</li>
<li><p>进程控制</p>
</li>
<li><p>进程的创建（<a href="http://stackoverflow.com/questions/4856255/the-difference-between-fork-vfork-exec-and-clone">linux 中 fork，vfork，clone 的区别</a>）、撤销、阻塞、唤醒</p>
</li>
<li><p>进程的相互制约关系</p>
</li>
<li><p>进程竞争与合作</p>
<ul>
<li>竞争系统资源</li>
<li>进程间合作：信息共享；并行处理</li>
</ul>
</li>
<li><p>进程互斥的概念</p>
<ul>
<li>临界资源：共享硬件资源、共享公用变量、共享表格等</li>
<li>临界区：各个进程访问临界资源的那段程序<ul>
<li>在有限时间内进入临界区</li>
<li>至多有一个进进程处于临界区</li>
<li>进程在临界区内仅逗留有限的时间</li>
</ul>
</li>
<li>互斥：若干进程能够访问和修改的存储单元称为公共变量，公共变量或公共存储区一次只能被一个进程读写</li>
</ul>
</li>
<li><p>进程同步的概念</p>
<ul>
<li>同步的例子：病人看病，医生开化验单，病人拿化验单去化验，将化验结果交给医生</li>
</ul>
</li>
<li><p>同步机构</p>
</li>
<li><p>锁：上锁原语&amp;开锁原语</p>
</li>
<li><p>原语的概念：不可分割的一系列操作。在单处理机上，该功能由操作系统提供支持，即软件方法实现，使得某进程在执行某原语所包含的一系列指令执行时不被中断。在多核处理机上必须要由硬件支持。详见 <a href="https://stackoverflow.com/questions/6863612/atomic-operations-under-the-hood">stackoverflow</a>、<a href="http://blog.csdn.net/npy_lp/article/details/7262388">Linux内核同步原语之原子操作</a>、<a href="http://baike.baidu.com/item/%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C">百度百科-原子操作</a>、<a href="http://www.cnblogs.com/jiayy/p/3243900.html">并行编程3——内存模型之原子性</a></p>
<ul>
<li>单处理器上的原语靠操作系统实现，即使该原语由一系列的指令完成，但只要操作系统不把线程中断（如线程调度）即可保证这一系列指令的原子性；此时其他线程等待的是时间片（处于就绪态）</li>
<li>多处理器上的原语靠硬件实现，如果某原语由一系列的指令完成，即使执行该原语的线程在其运行的 CPU 上不被调度（或者说被中断），其他 CPU 上可能会有线程操作该原语对应的内存区域，此时并不能保证该 “原语” 的原子性，此时就需要 CPU 提供 LOCK 指令使得原语所操作的内存被锁上，那么其他 CPU 上在线程就不能操作该内存了，从而保证了原语的原子性，此时这些线程等待的是 UNLOCK 指令（处于阻塞状态）</li>
<li>总的来说原语就是要保证相同内存只能被一个线程所操作</li>
</ul>
</li>
<li><p>信号灯以及 P、V操作</p>
<ul>
<li>信号灯：从交通管理应用过来的一个术语，绿灯行（信号量非负），红灯停（信号量小于零）</li>
<li>P、V操作：P 操作和 V 操作都为原语<ul>
<li>P 操作使得信号量减 1，如果信号量此时大于等于 0，那么进程继续；否则进入该信号灯的等待队列中</li>
<li>V 操作使得信号量加一，如果此时信号量大于零进程继续；如果小于零，说明有进程处于等待队列中，因此需要从等待队列中唤醒一个进程（原因：该进程由于等待而挂起，并不能自己唤醒自己）</li>
</ul>
</li>
</ul>
</li>
<li><p>进程互斥与同步的实现</p>
</li>
<li><p>互斥的实现：1) 上锁原语、开锁原语； 2)信号灯</p>
</li>
<li><p>同步的实现：信号灯以及 P、V 操作</p>
<ul>
<li>生产者消费者问题</li>
<li>病人看病问题</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//病人看病</span><br><span class="line">main() &#123;</span><br><span class="line">    int s1 = 0; // 表示有无化验单的信号量，初始值为 0，表示没有</span><br><span class="line">    int s2 = 0; // 表示有无化验结果的信号量，初始值为 0，表示没有</span><br><span class="line">    cobegin             </span><br><span class="line">        labora();          </span><br><span class="line">        diagnosis();        </span><br><span class="line">    coend</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">labora() &#123;</span><br><span class="line">    while(化验为完成) &#123;</span><br><span class="line">        p(s1); // 询问有无化验单，无则等待</span><br><span class="line">        化验;</span><br><span class="line">        V(s2); // 送出化验结果</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">diagnosis() &#123;</span><br><span class="line">    while(看病工作未完成) &#123;</span><br><span class="line">        看病；</span><br><span class="line">        V(s1); // 送出化验单</span><br><span class="line">        P(s2); // 等化验结果</span><br><span class="line">        diagnosis; // 诊断</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 生产者消费者</span><br><span class="line">main() &#123;</span><br><span class="line">    int full = 0; // 满缓冲区数目</span><br><span class="line">    int empty = n; // 空缓冲区树木</span><br><span class="line">    int mutex = 1; // 对有界缓冲区进行操作的互斥信号灯</span><br><span class="line">    cobegin</span><br><span class="line">        p1();p2();...;pm(); // 生产</span><br><span class="line">        c1();c2();...;ck(); // 消费</span><br><span class="line">    coend</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">producer() &#123;</span><br><span class="line">    while(生产未完成) &#123;</span><br><span class="line">           .</span><br><span class="line">           .</span><br><span class="line">        生产一个产品；</span><br><span class="line">        P(empty);</span><br><span class="line">        P(mutex);</span><br><span class="line">        送一个产品到有界缓冲区;</span><br><span class="line">        V(mutex);</span><br><span class="line">        V(full);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">consumer() &#123;</span><br><span class="line">    while(还要继续消费) &#123;</span><br><span class="line">        P(full);</span><br><span class="line">        P(mutex);</span><br><span class="line">        从有界缓冲区中取出产品；</span><br><span class="line">        V(mutex);</span><br><span class="line">        V(empty);</span><br><span class="line">           .</span><br><span class="line">           .</span><br><span class="line">        消费一个产品;</span><br><span class="line">    &#125;       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>进程通信<ul>
<li>拷贝消息到另一个进程的地址空间</li>
<li>信箱通信，进程 A 投递消息到进程 B 的信箱中；进程 B 投递从自己的信箱中获取消息。信箱可位于 B 的空间，也可位于系统空间<ul>
<li>send 原语：可同步可异步，同步需等待对方接受；异步不关心对方是否接受</li>
<li>receive 原语：可以阻塞或非阻塞，如果阻塞，信息到来之前接收进程挂起；如果非阻塞，有消息将消息立即返回，无消息返回标志，表示没有消息可用</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="资源分配与调度"><a href="#资源分配与调度" class="headerlink" title="资源分配与调度"></a>资源分配与调度</h2><ul>
<li>资源管理概述</li>
<li>资源管理的目的和任务<ul>
<li>资源的静态分配和动态分配：运行前一次性分配为静态分配；运行时根据运行情况动态的分配为动态分配</li>
<li>资源分配的目标<ul>
<li>保证资源的高利用率</li>
<li>在合理的时间内使所用的用户有获得所需资源的机会</li>
<li>对不可共享的资源实施互斥使用</li>
<li>防止由资源分配不当而引起的死锁</li>
</ul>
</li>
<li>资源管理的任务<ul>
<li>资源数据结构的描述：资源物理名、逻辑名、类型、地址、分配状态等</li>
<li>确定请求的分配原则和调度原则：资源分给谁，何时分配，分配数量</li>
<li>资源分配的执行：按需分配资源，回收资源</li>
<li>存取控制和安全保护</li>
</ul>
</li>
</ul>
</li>
<li>资源的分类方法<ul>
<li>物理资源和程序资源：各种硬件资源为物理资源，系统服务、文件等为程序资源</li>
<li>单一访问入口资源和多访问入口资源：单访问入口资源一次只能一个进程用，多访问入口资源一次允许多个进程用</li>
<li>等同资源：多个资源的实例，如磁盘的各个扇区</li>
<li>虚拟资源：如虚拟主存，虚拟 CPU 等</li>
</ul>
</li>
<li>资源分配机制</li>
<li>资源描述器：描述资源最小分配单位的信息，如资源名、资源类型、分配标志等</li>
<li>资源信息块（rib）<ul>
<li>等待队列头指针：指向等待该资源的的进程队列</li>
<li>可利用资源队列头指针：指向资源描述器组成的队列</li>
<li>资源分配程序入口地址：执行分配任务，把对应的资源分配给请求者</li>
</ul>
</li>
<li>资源分配策略</li>
<li>先请求先服务（先进先出，FIFO）</li>
<li>优先调度（针对处理机而言）：优先照顾需要尽快处理的作业或进程</li>
<li>针对设备特性的调度：如对磁盘资源的请求会考虑移臂距离和旋转次数</li>
<li>死锁</li>
<li>同类资源的死锁：A、B 为两个进程，C 资源两个实例，A、B 各自拥有一个 C 资源的实例，它们不释放已有的资源实例，并且继续申请 C 资源，此时产生同类资源的死锁</li>
<li>非同类资源的死锁：A、B 为两个进程，C、D 两个资源各有一个实例。A 占有 C 资源，B 占有 D 资源，它们都不释放已有的资源，同时 A 申请 D 资源，B 申请 C 资源，此时产生非同类资源的死锁</li>
<li>死锁的原因和条件<ul>
<li>产生死锁的根本原因：系统提供的资源数少于申请该资源的数目</li>
<li>产生死锁的必要条件：<ul>
<li>互斥条件：资源为非共享的，或者说单一入口资源</li>
<li>不剥夺条件：资源使用完之前，其他进程不能强行剥夺其他进程的资源</li>
<li>占有并等待：进程申请其他资源时，不会释放已占有的资源</li>
<li>环路条件：A 进程需要的资源被 B 进程占有，而 B 进程需要的资源被进程 C 占有 …… * 进程需要的资源被 A 进程占有</li>
</ul>
</li>
</ul>
</li>
<li>死锁的解决策略<ul>
<li>破坏死锁的必要条件之一</li>
</ul>
</li>
<li>死锁的避免：<ul>
<li>静态预防：从根源避免死锁，作业在运行前说明所需要的所有资源，如果系统能够提供，那么投入运行，否则不能投入运行</li>
<li>动态避免<ul>
<li>有序资源分配法：给资源标序号，一个进程对于同类资源需一次性申请完，对不同类资源需要按序申请。该方法避免死锁的原因：每一时刻，总有一个进程 A 占有已分配资源中序号最高的那一个，此进程继续申请的资源的序号必定更高，这些资源必定处于空闲，因此进程 A 可以推进，在执行完后释放已有资源；进程 A 执行完后，又有一个进程 B 和进程 A 之前的状态一样，占有已分配资源中序号最高的那一个，于是 B 进程也可顺利执行结束；以此类推，所有进程都可顺利执行而不会发生死锁</li>
<li><a href="https://zh.wikipedia.org/wiki/%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95">银行家算法</a>：某个进程将来需要的各类资源当前系统能够满足，则将此进程投入运行。该方法避免死锁的原因：（1）进程 A 在运行时最多需要 5 个资源 B，此时系统拥有 B 的实例有 10 个，满足条件，将 A 投入运行，A 暂时只用到了 2 个 B 资源实例；（2）此时 C 进程想投入运行，它所需资源 B 的最大个数为 7 个，而系统此时有 8 个，故 C 投入运行，C 暂时只用了 6 个；（3）A 此时又想获取 3 个 B 实例，但是 B 资源只有 2 个不够，于是等待；（4）C 再次申请 1 个资源，成功，C 执行完毕并释放所有 B 资源实例；（4）A 获得 2 个资源，执行完毕后释放所有 B 资源实例。该算法成功避免死锁的原因在于后来的申请者一定会释放所申请资源，使得系统所拥有资源量符合对较早申请者的承诺。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="处理机调度"><a href="#处理机调度" class="headerlink" title="处理机调度"></a>处理机调度</h2><ul>
<li><p>处理机的多级调度</p>
</li>
<li><p>批处理中的处理机调度</p>
<ul>
<li>先作业调度（宏观调度）：根据一定的策略挑选作业，建作业对应的进程，使其投入运行</li>
<li>后进程调度（微观调度）：对于进入主存的进程的调度，什么时候把处理机分配给该进程</li>
</ul>
</li>
<li><p>多任务操作系统的处理机调度：处理机空闲时，选择一个就绪的进程投入运行</p>
</li>
<li><p>多线程操作系统的处理机调度：处理机空闲时，选择一个就绪的线程投入运行</p>
</li>
<li><p>作业调度</p>
</li>
<li><p>作业的状态：后备状态（进入磁盘队列），执行状态（进入主存执行），完成状态（从完成到善后处理结束并退出）。</p>
</li>
<li><p>作业调度的功能：确定数据结构，确定调度算法，资源分配，善后处理</p>
</li>
<li><p>作业控制块：记录作业的有关信息，如作业名、作业类型、作业状态、作业对资源的要求等</p>
</li>
<li><p>调度算法的衡量：平均周转时间和平均带权周转时间</p>
<ul>
<li>平均周转时间为各个作业从进入磁盘到完成作业所花时间的平均值</li>
<li>平均带权周转时间为各个作业的周转时间和运行时间（不包括在磁盘队列中的等待时间）的比值的平均值</li>
</ul>
</li>
<li><p>作业调度算法</p>
</li>
<li><p>先来先服务（FIFO）：考虑等待时间</p>
</li>
<li><p>短作业优先：运行所花时间最短的作业优先执行，考虑运行时间</p>
</li>
<li><p>相应比高者优先：（等待时间／运行时间） 最大者优先，同时考虑等待时间和运行时间</p>
</li>
<li><p>优先调度算法：给各个作业分配优先数，优先数高者优先执行，优先数 = waiting_time<sup>2</sup> - running_time - 16 * output</p>
</li>
<li><p>进程调度</p>
</li>
<li><p>进程调度的功能和准则</p>
<ul>
<li>功能</li>
</ul>
</li>
</ul>
<h2 id="主存管理"><a href="#主存管理" class="headerlink" title="主存管理"></a>主存管理</h2><p>未完待续。。。</p>
]]></content>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>Glide 之磁盘缓存</title>
    <url>/2017/08/29/2017-08-29-glide-disk-cache-strategy/</url>
    <content><![CDATA[<h1 id="Glide-之磁盘缓存"><a href="#Glide-之磁盘缓存" class="headerlink" title="Glide 之磁盘缓存"></a>Glide 之磁盘缓存</h1><p>Glide 提供了灵活的磁盘缓存策略，用户可以定义自己的缓存策略，只需要实现 DiskCache 接口即可。Glide 中已经有两个 DiskCache 实现，一个是 DiskCacheWrapper，这个类什么都没干，就是一个空壳，用来包装其他的 DiskCache 实现类；另一个类是 DiskLruCaheWrapper，它是基于 DiskLruCache 实现的。接下来从 DiskLruCahce 分析一下 Glide 的磁盘缓存。</p>
<span id="more"></span>
<h2 id="磁盘缓存核心-——-DiskLruCahce"><a href="#磁盘缓存核心-——-DiskLruCahce" class="headerlink" title="磁盘缓存核心 —— DiskLruCahce"></a>磁盘缓存核心 —— DiskLruCahce</h2><p>DiskLruCache 的分析分为两部分：分别是日志，读、写缓存。</p>
<h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><p>DiskLruCache 的日志就是一个操作记录。例如，删除一条缓存条目，就会在日志文件中记录一条 REMOVE 记录；新建一条缓存，缓存文件刚建立时会增加一条 DIRTY 记录，缓存写入成功后再增加一条 CLEAN 记录；缓存被读取，会增加 READ 记录。日志文件的格式如下：</p>
<table>
<thead>
<tr>
<th>记录类型</th>
<th>key</th>
<th>length1</th>
<th>length2</th>
</tr>
</thead>
<tbody><tr>
<td>CLEAN</td>
<td>3400330d1dfc7f3f7f4b8d4d803dfcf6</td>
<td>832</td>
<td>21054</td>
</tr>
<tr>
<td>DIRTY</td>
<td>335c4c6028171cfddfbaae1a9c313c52</td>
<td></td>
<td></td>
</tr>
<tr>
<td>CLEAN</td>
<td>335c4c6028171cfddfbaae1a9c313c52</td>
<td>3934</td>
<td>2342</td>
</tr>
<tr>
<td>REMOVE</td>
<td>335c4c6028171cfddfbaae1a9c313c52</td>
<td></td>
<td></td>
</tr>
<tr>
<td>DIRTY</td>
<td>1ab96a171faeeee38496d8b330771a7a</td>
<td></td>
<td></td>
</tr>
<tr>
<td>CLEAN</td>
<td>1ab96a171faeeee38496d8b330771a7a</td>
<td>1600</td>
<td>234</td>
</tr>
<tr>
<td>READ</td>
<td>335c4c6028171cfddfbaae1a9c313c52</td>
<td></td>
<td></td>
</tr>
<tr>
<td>READ</td>
<td>3400330d1dfc7f3f7f4b8d4d803dfcf6</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>之所以记录日志，就是为了在 DiskLruCache 初始化时建立起缓存的 LRU 结构。DiskLruCache 内部使用了 lruEntries:LinkHashMap 来存储所有的缓存项，在初始化的时候，DiskLruCache 会读日志文件上的记录，根据该日志文件的记录将所有历史操作“重做”一遍：在执行历史操作时，会根据日志记录对缓存项进行添加和删除操作。为什么这样能保证缓存项是按 LRU 的顺序排序的呢？因为构造 LinkedHashMap 的时候选择使用 Access Order（访问顺序）来保持元素的顺序，因此只需遍历日志根据日志记录向 LinkedHashMap 中放入缓存项（Entry）自然而然地就保持了 LRU 的顺序。读区日志记录的文件如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readJournalLine</span><span class="params">(String line)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> firstSpace = line.indexOf(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">  <span class="keyword">if</span> (firstSpace == -<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">&quot;unexpected journal line: &quot;</span> + line);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> keyBegin = firstSpace + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> secondSpace = line.indexOf(<span class="string">&#x27; &#x27;</span>, keyBegin);</span><br><span class="line">  <span class="keyword">final</span> String key;</span><br><span class="line">  <span class="keyword">if</span> (secondSpace == -<span class="number">1</span>) &#123;</span><br><span class="line">    key = line.substring(keyBegin);</span><br><span class="line">    <span class="keyword">if</span> (firstSpace == REMOVE.length() &amp;&amp; line.startsWith(REMOVE)) &#123;</span><br><span class="line">      lruEntries.remove(key);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    key = line.substring(keyBegin, secondSpace);</span><br><span class="line">  &#125;</span><br><span class="line">  Entry entry = lruEntries.get(key);</span><br><span class="line">  <span class="keyword">if</span> (entry == <span class="keyword">null</span>) &#123;</span><br><span class="line">    entry = <span class="keyword">new</span> Entry(key);</span><br><span class="line">    lruEntries.put(key, entry);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (secondSpace != -<span class="number">1</span> &amp;&amp; firstSpace == CLEAN.length() &amp;&amp; line.startsWith(CLEAN)) &#123;</span><br><span class="line">    String[] parts = line.substring(secondSpace + <span class="number">1</span>).split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">    entry.readable = <span class="keyword">true</span>;</span><br><span class="line">    entry.currentEditor = <span class="keyword">null</span>;</span><br><span class="line">    entry.setLengths(parts);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (secondSpace == -<span class="number">1</span> &amp;&amp; firstSpace == DIRTY.length() &amp;&amp; line.startsWith(DIRTY)) &#123;</span><br><span class="line">    entry.currentEditor = <span class="keyword">new</span> Editor(entry);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (secondSpace == -<span class="number">1</span> &amp;&amp; firstSpace == READ.length() &amp;&amp; line.startsWith(READ)) &#123;</span><br><span class="line">    <span class="comment">// This work was already done by calling lruEntries.get().</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">&quot;unexpected journal line: &quot;</span> + line);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法根据记录类型进行缓存的添加和删除：读取到 REMOVE 记录便从 lruEntries 删除对应的缓存项；然后通过 lruEntries.get() 方法尝试获取键值为 key 所对应的缓存项，如果不存在便新建一个并放入 lruEntries 中；判断记录的类型是不是 CLEAN 类型，是则对 entry 的 readable 和 currentEditor 字段进行更新，表示该缓存可供读取；如果类型是 DIRTY 类型，那么为 currentEditor 赋值；如果时 READ 记录，那么什么也不干，原因在注释里已经写明了：因为前面调用 lruEntries.get() 方法时，已经是对缓存元素进行了一次访问，因此可以保证这个被访问的元素排在最前面，即保证了元素按照 LRU 的次序排列。</p>
<p>读取完之后还会对 lruEntries 中的元素进一步处理：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processJournal</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  deleteIfExists(journalFileTmp);</span><br><span class="line">  <span class="keyword">for</span> (Iterator&lt;Entry&gt; i = lruEntries.values().iterator(); i.hasNext(); ) &#123;</span><br><span class="line">    Entry entry = i.next();</span><br><span class="line">    <span class="keyword">if</span> (entry.currentEditor == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">0</span>; t &lt; valueCount; t++) &#123;</span><br><span class="line">        size += entry.lengths[t];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      entry.currentEditor = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">0</span>; t &lt; valueCount; t++) &#123;</span><br><span class="line">        deleteIfExists(entry.getCleanFile(t));</span><br><span class="line">        deleteIfExists(entry.getDirtyFile(t));</span><br><span class="line">      &#125;</span><br><span class="line">      i.remove();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法会将其中 currentEditor 不为 null 的 entry 全部删除。原因就是这些缓存项是脏数据，是上次缓存未成功提交的结果。一般来说，一条 DIRTY 记录后会紧跟着一条 key 值相同的 CLEAN 或者 REMOVE 记录，这表明了缓存经历了从被写入到之后成功提交或者删除的过程，这样一来，lruEntries 中要么就不存在该记录对应的 Entry 对象，要么该 Entry 对象的 currentEditor 为 null，即该缓存项有效。如果不清楚这一点可以先往下读再回来理解。</p>
<p>现在，假设有如下日志记录：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DIRTY KEY1；CLEAN KEY1；DIRTY KEY2；CLEAN KEY2；DIRTY KEY3；CLEAN KEY3；</span><br><span class="line">READ KEY3；READ KEY2 ；DIRTY KEY4；CLEAN KEY4；REMOVE KEY1</span><br></pre></td></tr></table></figure>
<p>这个日志反映的历史操作是：首先依次建立了 key 分别为 KEY1，KEY2，KEY3 的三个缓存文件，然后读取了 key 为 KEY2 和 KEY3 的两个文件，之后又建立了 key 为 KEY4 的文件，最后删除了 key 为 KEY1 的那个缓存文件。这样一来读取该日志文件时 LinkHashMap 添加和删除缓存项的过程就是这样的：首先依次添加 KEY1，KEY2，KEY3 对应的缓存项，再依次分别读取一次 KEY3，KEY2 对应的缓存项，再添加 KEY4 对应的缓存项，最后删除 KEY1 对应的缓存项。最终 lruEntries 中的缓存项的顺序为：KEY3，KEY2，KEY4，其中 KEY4 排在最前面，即最不容易被淘汰。</p>
<h3 id="读写缓存"><a href="#读写缓存" class="headerlink" title="读写缓存"></a>读写缓存</h3><p>首先看 DiskLruCache 读缓存的方式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DiskLruCache cache = DiskLruCache.open(directory, appVersion, valueCount, maxSize);</span><br><span class="line">Value v = cache.get(key);</span><br><span class="line">File cacheFile = v.getFile(0);</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<p>DisLruCache 的 open() 方法有四个参数：第一个参数是缓存文件的根目录，第二个是应用版本号，第三个是一个 key 对应的缓存文件数目（一般传 1 就可以了，我们通常只需要一份缓存文件），第四个是缓存的最大值，以字节为单位。Value 被称之为“快照”，它包含了缓存项的一些信息，比如缓存项对应的缓存文件。它的 getFile() 方法就是获取该缓存文件，客户端就可以将需要缓存的信息写入该文件。</p>
<p>写缓存的方式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Editor editor = cache.edit(key);</span><br><span class="line">File cacheFile = editor.getFile(<span class="number">0</span>);</span><br><span class="line">...</span><br><span class="line">eidtor.commit();</span><br></pre></td></tr></table></figure>

<p>首先调用 edit() 方法开启了在键值为 key 的缓存项上的一次操作，它返回的是一个 Editor 对象，该对象的 getFile() （参数 0 表示的是该 key 对应的缓存项中的第一个缓存文件）方法返回缓存文件供外部执行写缓存操作。需要注意的是，对缓存文件操作完之后需要调用 editor.commit() 方法进行提交，否则这次写在日志文件中只会生成一条 DIRTY 记录与之对应（而不会生成 CLEAN 记录），使得缓存无效。</p>
<p>现在来看读写缓存的内部原理，首先要理解 DiskLruCache 的几个内部类及其角色。其中一个是 Entry，Entry 代表了一个缓存项，这个缓存项不一定就是一个缓存文件，它对应的是含有相同 key 的所有缓存文件，这些文件有 CLEAN 状态的，也有 DIRTY 状态的。其内部的数据结构大致是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Entry &#123;</span><br><span class="line">    String key; // 缓存项对应的 key</span><br><span class="line">    File[] dirtyFiles; // 临时文件，不完整，不可读取，只可写入</span><br><span class="line">    File[] cleanFiles; // 完整缓存文件，已缓存完毕，可供读取</span><br><span class="line">    long[] lengths; // 完整的缓存文件对应的大小</span><br><span class="line">    Editor currentEditor; // 当前在此 Entry 上执行操作的 Editor 对象</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其构造方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Entry</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.key = key;</span><br><span class="line">  <span class="keyword">this</span>.lengths = <span class="keyword">new</span> <span class="keyword">long</span>[valueCount];</span><br><span class="line">  cleanFiles = <span class="keyword">new</span> File[valueCount];</span><br><span class="line">  dirtyFiles = <span class="keyword">new</span> File[valueCount];</span><br><span class="line">  <span class="comment">// The names are repetitive so re-use the same builder to avoid allocations.</span></span><br><span class="line">  StringBuilder fileBuilder = <span class="keyword">new</span> StringBuilder(key).append(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">  <span class="keyword">int</span> truncateTo = fileBuilder.length();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; valueCount; i++) &#123;</span><br><span class="line">      fileBuilder.append(i);</span><br><span class="line">      cleanFiles[i] = <span class="keyword">new</span> File(directory, fileBuilder.toString());</span><br><span class="line">      fileBuilder.append(<span class="string">&quot;.tmp&quot;</span>);</span><br><span class="line">      dirtyFiles[i] = <span class="keyword">new</span> File(directory, fileBuilder.toString());</span><br><span class="line">      fileBuilder.setLength(truncateTo);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它的构造方法利用了 key 去构造那些 File 对象：key.index 就是 Clean File，key.index.tmp 就是 Dirty File。也就是说，在读取日志文件的时候，已经将所有缓存项的对应的缓存文件对象都初始化好了，需要注意的是，这里仅仅是根据文件名来构造相应的缓存文件对象而已，那些 cleanFiles 和 dirtyFiles 并不一定是磁盘上存在的文件。</p>
<p>另一个类是 Editor，它的内部字段有：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Editor &#123;</span><br><span class="line">    Entry entry; //该 Editor 操作的缓存项</span><br><span class="line">    boolean[] written; // 完整文件是否被修改</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们看看写缓存文件的过程。首先是获取 Editor 对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> Editor <span class="title">edit</span><span class="params">(String key, <span class="keyword">long</span> expectedSequenceNumber)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  checkNotClosed();</span><br><span class="line">  Entry entry = lruEntries.get(key);</span><br><span class="line">  <span class="keyword">if</span> (expectedSequenceNumber != ANY_SEQUENCE_NUMBER &amp;&amp; (entry == <span class="keyword">null</span></span><br><span class="line">      || entry.sequenceNumber != expectedSequenceNumber)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">// Value is stale.</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (entry == <span class="keyword">null</span>) &#123;</span><br><span class="line">    entry = <span class="keyword">new</span> Entry(key);</span><br><span class="line">    lruEntries.put(key, entry);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (entry.currentEditor != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">// Another edit is in progress.</span></span><br><span class="line">  &#125;</span><br><span class="line">  Editor editor = <span class="keyword">new</span> Editor(entry);</span><br><span class="line">  entry.currentEditor = editor;</span><br><span class="line">  <span class="comment">// Flush the journal before creating files to prevent file leaks.</span></span><br><span class="line">  journalWriter.append(DIRTY);</span><br><span class="line">  journalWriter.append(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">  journalWriter.append(key);</span><br><span class="line">  journalWriter.append(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">  journalWriter.flush();</span><br><span class="line">  <span class="keyword">return</span> editor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法做的事可以描述如下：先从 lruEntries:LinkedHashMap 中获取缓存项，然后对缓存的 sequenceNumber 进行验证，如果不存在该缓存项，便新建一个。然后由该缓存项构造出一个 Editor 对象，最后记录一条 DIRTY 日志并返回 Editor 对象。获取 Editor 对象后，便可通过其 getFile(0) 方法获取到对应的缓存文件对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> File <span class="title">getFile</span><span class="params">(<span class="keyword">int</span> index)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (DiskLruCache.<span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (entry.currentEditor != <span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!entry.readable) &#123;</span><br><span class="line">        written[index] = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    File dirtyFile = entry.getDirtyFile(index);</span><br><span class="line">    <span class="keyword">if</span> (!directory.exists()) &#123;</span><br><span class="line">        directory.mkdirs();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dirtyFile;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>getFile() 返回的是缓存项的第 index 个临时文件对象，客户端便可由该对象建立输出流将缓存写入文件中。因为是写文件，所以在写的时候可能出现异常中断的现象（应用崩溃、应用进程被杀），因此写完缓存之后需要调用 editor.commit() 来提交本次操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  completeEdit(<span class="keyword">this</span>, <span class="keyword">true</span>);</span><br><span class="line">  committed = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// suecess 为 true 表示提交本次操作，fale 表示放弃本次操作</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">completeEdit</span><span class="params">(Editor editor, <span class="keyword">boolean</span> success)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  Entry entry = editor.entry;</span><br><span class="line">  <span class="keyword">if</span> (entry.currentEditor != editor) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// If this edit is creating the entry for the first time, every index must have a value.</span></span><br><span class="line">  <span class="keyword">if</span> (success &amp;&amp; !entry.readable) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; valueCount; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!editor.written[i]) &#123;</span><br><span class="line">        editor.abort();</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Newly created entry didn&#x27;t create value for index &quot;</span> + i);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!entry.getDirtyFile(i).exists()) &#123;</span><br><span class="line">        editor.abort();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 对缓存重命名</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; valueCount; i++) &#123;</span><br><span class="line">    File dirty = entry.getDirtyFile(i);</span><br><span class="line">    <span class="keyword">if</span> (success) &#123;</span><br><span class="line">      <span class="keyword">if</span> (dirty.exists()) &#123;</span><br><span class="line">        File clean = entry.getCleanFile(i);</span><br><span class="line">        dirty.renameTo(clean);</span><br><span class="line">        <span class="keyword">long</span> oldLength = entry.lengths[i];</span><br><span class="line">        <span class="keyword">long</span> newLength = clean.length();</span><br><span class="line">        entry.lengths[i] = newLength;</span><br><span class="line">        size = size - oldLength + newLength;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      deleteIfExists(dirty);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  redundantOpCount++;</span><br><span class="line">  entry.currentEditor = <span class="keyword">null</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 记录日志</span></span><br><span class="line">  <span class="keyword">if</span> (entry.readable | success) &#123;</span><br><span class="line">    entry.readable = <span class="keyword">true</span>;</span><br><span class="line">    journalWriter.append(CLEAN);</span><br><span class="line">    journalWriter.append(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    journalWriter.append(entry.key);</span><br><span class="line">    journalWriter.append(entry.getLengths());</span><br><span class="line">    journalWriter.append(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (success) &#123;</span><br><span class="line">      entry.sequenceNumber = nextSequenceNumber++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    lruEntries.remove(entry.key);</span><br><span class="line">    journalWriter.append(REMOVE);</span><br><span class="line">    journalWriter.append(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    journalWriter.append(entry.key);</span><br><span class="line">    journalWriter.append(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  journalWriter.flush();</span><br><span class="line">  <span class="keyword">if</span> (size &gt; maxSize || journalRebuildRequired()) &#123;</span><br><span class="line">    executorService.submit(cleanupCallable);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法的逻辑是：先校验一下是不是只有一个 Editor 在操作该缓存项（保证同一时刻一个缓存项上只能有一个写操作），然后判断该缓存项是不是新建的，如果是，那么是不是该缓存项对应的所有的临时缓存文件都存在并且都被写过，如果不是，那么放弃这次操作。验证工作做完后就是重命名的过程了，接下来会把所有的该缓存项的所有实际存在的临时文件的名称都重命名为对应的完整文件的名称（即把后面的 .tmp 后缀去除）。最后就是记录日志，如果成功提交本次操作，那么记下一条 CLEAN 日志，如果选择放弃本次操作，那么记下 REMOVE 日志。通过这个方法可以知道，如果客户端写完缓存后没有调用 Editor#commit() CLEAN 记录是不会被记下的，因此下次读取日志文件的时候，会把该缓存项删除，原因前面已经讲了。</p>
<p>如果缓存一直持续下去，是不是日志记录越来越大呢？答案是否定的，日志文件有一个上限，如果超过该上限便会重建。同样的，lruEntries 中的缓存项也不会无限增长，它受 maxSize 参数的限制，如果容量太大，便会从 LruEntries 中删除最久未被使用的缓存项，并将结果反映到磁盘上的缓存文件上，具体的细节这里就不再讲述了。</p>
<h2 id="感谢阅读"><a href="#感谢阅读" class="headerlink" title="感谢阅读"></a>感谢阅读</h2><p>以上便是对 Glide 磁盘缓存的核心类 DiskLruCache 的分析，如有不对还请大家不吝赐教。</p>
]]></content>
      <tags>
        <tag>Android</tag>
        <tag>开源库</tag>
      </tags>
  </entry>
  <entry>
    <title>Android 进程启动原理</title>
    <url>/2017/08/29/2017-08-29-how-an-android-process-starts/</url>
    <content><![CDATA[<h1 id="Android-进程启动原理"><a href="#Android-进程启动原理" class="headerlink" title="Android 进程启动原理"></a>Android 进程启动原理</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Android 中的应用是支持多进程的，我们只要在 AndroidManifest 中给四大组件指定 android:process 属性即可让其运行在独立的进程当中。那么应用的主进程又是如何被创建的呢？一般来说，当我们的应用没有任何组件处于运行状态，此时其他应用启动我们应用的组件时，应用的主进程就会被创建，进程相当于是提供了组件运行的空间。最常见的触发应用主进程被创建的方式是应用 A 通过 startActivity 或者 startActivityForResult 启动应用 B，并且应用 B 此时没有任何组件处于运行状态，那么系统先会通过 AMS 为 B 创建一个进程，等进程创建好了再通知应用 B 创建并运行该 Activity。AMS 是运行在 system_server 进程当中的，这个进程并不会 fork 出应用进程，那么应用进程到底是哪个进程创建的呢？这就得从 Zygote 进程说起。</p>
<span id="more"></span>
<h2 id="Zygote-进程"><a href="#Zygote-进程" class="headerlink" title="Zygote 进程"></a>Zygote 进程</h2><h3 id="zygote-进程的启动"><a href="#zygote-进程的启动" class="headerlink" title="zygote 进程的启动"></a>zygote 进程的启动</h3><p>Zygote 的中文意思是“受精卵”，它的字面意思很形象的概括了 Zygote 进程在 Android 系统中的作用——“分裂”出其他进程。Zygote 进程是所有 Android 应用的父进程，并且还是 system_server 的父进程。由此看来，Zygote 进程在 Android 系统中发挥了举足轻重的作用。但是 Zygote 并不是 Android  系统中的第一个进程，它也是其他进程 fork 来的，这个进程就是 init 进程，它是用户空间的第一个进程。init 进程就是用来解析并执行 init.rc 配置文件的，这个文件位于系统根目录下，这个配置文件中会导入其他的配置文件如 init.zygote32.rc 或者 init.zygote64_32.rc，具体导入哪一个由 ro.zygote 的值决定。这两个配置文件的作用就是启动 Zygote 进程。在 init.zygote32.rc 中，启动 Zygote 的语句如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">serivce zygote /system/bin/app_process -Xzygote /system/bin --zygote --start-system-server</span><br><span class="line">	class main</span><br><span class="line">	socket zygote stream 660 root system</span><br><span class="line">	onrestart write /sys/android_power/request_state wake</span><br><span class="line">	onrestart write /sys/power/state on</span><br><span class="line">	onrestart restart media</span><br><span class="line">	onrestart restart netd</span><br></pre></td></tr></table></figure>

<p>我们主要看 service 块的第一行，这行命令的语义是：启动一个名为 zygote 的服务，这个服务的可执行文件路径是 /system/bin/app_process。后面跟的都是 app_process 这个可执行文件的参数。app_process 对应的源码文件为你 app_main.c，这个源码文件的 main() 方法中有对这些参数的解释：以 - 开头的都是虚拟机参数，这些参数会传入即将要启动的虚拟机中；接下来是运行目录，有点类似终端执行命令时的当前目录，在这里是 /system/bin；接下来是一些以 – 开头的参数，这些参数表示启动参数，“–zygote” 表示启动的是 zygote 进程，“–application”表示启动的是普通 Java 进程，“–start-system-server” 表示要启动 system_server 进程，“–nice-name”用来指定进程的名字。接下来的参数指明的是要启动的 Java 类，如果前面使用了 “–zygote“参数，那么启动的就是 zygote 进程，这里就可以不指明，因为 zygote 进程默认就是执行 ZygoteInit 类，如果使用了 “–application”，那么启动的就是普通的 Java 进程，这里需要指明要执行的 Java 主类；接下来的参数是都是传入该主类的参数，这些参数只有启动的是普通 Java 进程时才有用。</p>
<p>app_main.c 的 main() 方法的主要逻辑都是在解析相应的参数，它对参数的的解析主要分为以下几个步骤：</p>
<ul>
<li>创建 AppRuntime 并解析虚拟机参数：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* <span class="keyword">const</span> argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="function">AppRuntime <span class="title">runtime</span><span class="params">(argv[<span class="number">0</span>], computeArgBlockSize(argc, argv))</span></span>;</span><br><span class="line">    <span class="comment">// Process command line arguments</span></span><br><span class="line">    <span class="comment">// ignore argv[0]</span></span><br><span class="line">    argc--;</span><br><span class="line">    argv++;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; argc; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (argv[i][<span class="number">0</span>] != <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (argv[i][<span class="number">1</span>] == <span class="string">&#x27;-&#x27;</span> &amp;&amp; argv[i][<span class="number">2</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">            ++i; <span class="comment">// Skip --.</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        runtime.addOption(strdup(argv[i])); <span class="comment">//将有效参数加入到虚拟机参数表中</span></span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>解析启动参数</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* <span class="keyword">const</span> argv[])</span> </span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">	......</span><br><span class="line">    <span class="keyword">while</span> (i &lt; argc) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span>* arg = argv[i++];</span><br><span class="line">        <span class="keyword">if</span> (strcmp(arg, <span class="string">&quot;--zygote&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            zygote = <span class="keyword">true</span>;</span><br><span class="line">            niceName = ZYGOTE_NICE_NAME;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (strcmp(arg, <span class="string">&quot;--start-system-server&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            startSystemServer = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (strcmp(arg, <span class="string">&quot;--application&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            application = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (strncmp(arg, <span class="string">&quot;--nice-name=&quot;</span>, <span class="number">12</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            niceName.setTo(arg + <span class="number">12</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (strncmp(arg, <span class="string">&quot;--&quot;</span>, <span class="number">2</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">            className.setTo(arg); <span class="comment">// 解析到了主类名，说明启动的是普通 Java 程序</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            --i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>准备要执行的主类的参数，这里的主类只有“ZygoteInit” 和 “RuntimeInit”两种</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* <span class="keyword">const</span> argv[])</span> </span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">	......</span><br><span class="line">    Vector&lt;String8&gt; args;</span><br><span class="line">    <span class="keyword">if</span> (!className.isEmpty()) &#123;</span><br><span class="line">    	 <span class="comment">// 非 zygote 模式，我们需要将后面的参数传入 AppRuntime 中保存，而不是传入 RuntimeInit 中</span></span><br><span class="line">        args.add(application ? String8(<span class="string">&quot;application&quot;</span>) : String8(<span class="string">&quot;tool&quot;</span>));</span><br><span class="line">        runtime.setClassNameAndArgs(className, argc - i, argv + i);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// zygote 模式</span></span><br><span class="line">        maybeCreateDalvikCache();</span><br><span class="line">        <span class="keyword">if</span> (startSystemServer) &#123;</span><br><span class="line">            args.add(String8(<span class="string">&quot;start-system-server&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span> prop[PROP_VALUE_MAX];</span><br><span class="line">        <span class="keyword">if</span> (property_get(ABI_LIST_PROPERTY, prop, NULL) == <span class="number">0</span>) &#123;</span><br><span class="line">            LOG_ALWAYS_FATAL(<span class="string">&quot;app_process: Unable to determine ABI list from property %s.&quot;</span>,</span><br><span class="line">                ABI_LIST_PROPERTY);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">11</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">String8 <span class="title">abiFlag</span><span class="params">(<span class="string">&quot;--abi-list=&quot;</span>)</span></span>;</span><br><span class="line">        abiFlag.append(prop);</span><br><span class="line">        args.add(abiFlag);</span><br><span class="line">        <span class="comment">// zygote 模式中，将后面的参数全部传入 ZygoteInit 的 main() 方法中</span></span><br><span class="line">        <span class="keyword">for</span> (; i &lt; argc; ++i) &#123;</span><br><span class="line">            args.add(String8(argv[i]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>修改进程名</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* <span class="keyword">const</span> argv[])</span> </span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">	......</span><br><span class="line">    <span class="keyword">if</span> (!niceName.isEmpty()) &#123;</span><br><span class="line">        runtime.setArgv0(niceName.string());</span><br><span class="line">        set_process_name(niceName.string());</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>启动 “ZygoteInit” 或者 “RuntimeInit” 类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* <span class="keyword">const</span> argv[])</span> </span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">	......</span><br><span class="line">    <span class="keyword">if</span> (zygote) &#123; <span class="comment">// 如果启动的是 zygote 进程</span></span><br><span class="line">        runtime.start(<span class="string">&quot;com.android.internal.os.ZygoteInit&quot;</span>, args, zygote);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (className) &#123; <span class="comment">// 如果启动的是普通 Java 进程</span></span><br><span class="line">        runtime.start(<span class="string">&quot;com.android.internal.os.RuntimeInit&quot;</span>, args, zygote);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 否则报错</span></span><br><span class="line">        fprintf(stderr, <span class="string">&quot;Error: no class name or --zygote supplied.\n&quot;</span>);</span><br><span class="line">        app_usage();</span><br><span class="line">        LOG_ALWAYS_FATAL(<span class="string">&quot;app_process: no class name or --zygote supplied.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>start() 方法最终会启动虚拟机并执行上面传入的类。这里可能有点奇怪，说好的启动普通 Java 进程时启动的是指定的 Java 主类，为什么这里却是执行 RuntimeInit 呢？其实逻辑是这样的：先执行 RuntimeInit 做一些必要的设置，再回到 AppRuntime 中执行指定的 Java 主类。这也就为什么在第三步的时候普通 Java 类的类名和参数要通过 AppRuntime#setClassNameAndArgs 的成员变量中，而 ZygoteInit 的参数保存在 args:Vector<String8> 中。因为这样从 RuntimeInit 回到 AppRuntime 中时就可以根据之前保存的类名和参数去执行指定的 Java 主类了。更详细的解析需要通过阅读 AppRuntime 的源码来说明。</p>
<h3 id="AndroidRuntime"><a href="#AndroidRuntime" class="headerlink" title="AndroidRuntime"></a>AndroidRuntime</h3><p>AppRuntime 继承自 AndroidRuntime，它的大部分方法都直接继承自 AndroidRuntime，它仅仅是实现了 AndroidRuntime 定义的一些生命周期回调方法。所以我们重点来看 AndroidRuntime，首先看看它的构造方法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">AndroidRuntime::<span class="built_in">AndroidRuntime</span>(<span class="keyword">char</span>* argBlockStart, <span class="keyword">const</span> <span class="keyword">size_t</span> BlockLength) :</span><br><span class="line">        <span class="built_in">mExitWithoutCleanup</span>(<span class="literal">false</span>),</span><br><span class="line">        <span class="built_in">mArgBlockStart</span>(argBlockStart),</span><br><span class="line">        <span class="built_in">mArgBlockLength</span>(argBlockLength)</span><br><span class="line">&#123;</span><br><span class="line">    SkGraphics::<span class="built_in">Init</span>();</span><br><span class="line">    <span class="comment">// mOptions 用来存储虚拟机参数</span></span><br><span class="line">    mOptions.<span class="built_in">setCapacity</span>(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert</span>(gCurRuntime == <span class="literal">NULL</span>);        <span class="comment">// 确保只有一个实例</span></span><br><span class="line">    gCurRuntime = <span class="keyword">this</span>; <span class="comment">// 将该实例的指针保存在 gCurRuntime 这个全局指针中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 app_main.c 的 main() 方法中我们看到过 AppRuntime 的实例化过程，它是作为一个局部变量创建的，在 C++ 中，局部变量是在栈上分配的，而栈上分配的变量有一个特点，就是在方法执行完后它对应的内存就会被自动释放掉，不管是否有指向该变量的引用，所以一般不让全局的指针指向局部变量，这一点和 Java 有所不同。因此这里会有一个问题：如果 main() 方法执行完了，那么 gCurRuntime 所指向的那块内存已经被释放掉了，那么当我们引用 gCurRuntime 时程序肯定会报错。的确，如果 main() 运行完毕了我们在通过引用 gCurRuntime 去调用 AppRuntime 实例的方法肯定会报错，但关键在于，main() 方法退出了程序也就退出了，程序根本没有再引用 gCurRuntime 的机会了，这样看来，是不用担心 gCurRuntime 指向已释放内存的，在程序中可以放心使用。</p>
<p>现在来看看它的一个重要方法，也是上面用到过的方法——start()，这个方法主要做了以下几件事：</p>
<ul>
<li>启动虚拟机：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">JniInvocation jni_invocation;</span><br><span class="line">jni_invocation.<span class="built_in">Init</span>(<span class="literal">NULL</span>);</span><br><span class="line">JNIEnv* env;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">startVm</span>(&amp;mJavaVM, &amp;env, zygote) != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里创建了虚拟机并且导出了 JNIEnv 对象，这个对象可以用来和 Java 层交互。</p>
<ul>
<li>回调 onVmCreated(env) 方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">virtual <span class="keyword">void</span> <span class="title">onVmCreated</span><span class="params">(JNIEnv* env)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mClassName.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">// Zygote. Nothing to do here.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将类名中的 . 替换成 /</span></span><br><span class="line">    <span class="keyword">char</span>* slashClassName = toSlashClassName(mClassName.string());</span><br><span class="line">    mClass = env-&gt;FindClass(slashClassName); <span class="comment">// 查找指定的类</span></span><br><span class="line">    <span class="keyword">if</span> (mClass == NULL) &#123; <span class="comment">// 找不到这个类</span></span><br><span class="line">        ALOGE(<span class="string">&quot;ERROR: could not find class &#x27;%s&#x27;\n&quot;</span>, mClassName.string());</span><br><span class="line">    &#125;</span><br><span class="line">    free(slashClassName);</span><br><span class="line">    mClass = reinterpret_cast&lt;jclass&gt;(env-&gt;NewGlobalRef(mClass));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之前说了，AppRuntime 实现了 AndroidRuntime 中定义的各种生命周期回调方法，onVmCreated() 方法就是其中之一，因此这个方法的实现在 AppRuntime 中。这里对启动的是 zygote 进程还是普通的 Java 进程进行了不同的处理，如果是  zygote 进程，那么什么也不干，如果是普通的 Java 进程，那么就根据之前保存的类名来加载这个类。</p>
<ul>
<li>注册 JNI 函数</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (startReg(env) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    ALOGE(<span class="string">&quot;Unable to register all android natives\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这一步会将很多 Java 层的 native 方法和 C++ 层的方法对应起来。</p>
<ul>
<li>准备 Java 类的参数</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">jclass stringClass;</span><br><span class="line">jobjectArray strArray;</span><br><span class="line">jstring classNameStr;</span><br><span class="line"></span><br><span class="line">stringClass = env-&gt;FindClass(<span class="string">&quot;java/lang/String&quot;</span>);</span><br><span class="line"><span class="keyword">assert</span>(stringClass != NULL);</span><br><span class="line">strArray = env-&gt;NewObjectArray(options.size() + <span class="number">1</span>, stringClass, NULL);</span><br><span class="line"><span class="keyword">assert</span>(strArray != NULL);</span><br><span class="line">classNameStr = env-&gt;NewStringUTF(className);</span><br><span class="line"><span class="keyword">assert</span>(classNameStr != NULL);</span><br><span class="line">env-&gt;SetObjectArrayElement(strArray, <span class="number">0</span>, classNameStr);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (size_t i = <span class="number">0</span>; i &lt; options.size(); ++i) &#123;</span><br><span class="line">    jstring optionsStr = env-&gt;NewStringUTF(options.itemAt(i).string());</span><br><span class="line">    <span class="keyword">assert</span>(optionsStr != NULL);</span><br><span class="line">    env-&gt;SetObjectArrayElement(strArray, i + <span class="number">1</span>, optionsStr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里创建了一个 Java 字符串数组对象，然后把 C++ 字符串转换成 Java 层的字符串对象后放进该数组中。除了原本在 options 中的字符串外，这里还会把要启动的类的完整类名作为第一个元素放进字符串数组中。</p>
<ul>
<li>启动 Java 类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">  * Start VM.  This thread becomes the main thread of the VM, and will</span></span><br><span class="line"><span class="comment">  * not return until the VM exits.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">char</span>* slashClassName = toSlashClassName(className);</span><br><span class="line"> jclass startClass = env-&gt;FindClass(slashClassName);</span><br><span class="line"> <span class="keyword">if</span> (startClass == NULL) &#123;</span><br><span class="line">     ALOGE(<span class="string">&quot;JavaVM unable to locate class &#x27;%s&#x27;\n&quot;</span>, slashClassName);</span><br><span class="line">     <span class="comment">/* keep going */</span></span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="comment">// 找到 main 方法</span></span><br><span class="line">     jmethodID startMeth = env-&gt;GetStaticMethodID(startClass, <span class="string">&quot;main&quot;</span>,</span><br><span class="line">         <span class="string">&quot;([Ljava/lang/String;)V&quot;</span>);</span><br><span class="line">     <span class="keyword">if</span> (startMeth == NULL) &#123;</span><br><span class="line">         ALOGE(<span class="string">&quot;JavaVM unable to find main() in &#x27;%s&#x27;\n&quot;</span>, className);</span><br><span class="line">         <span class="comment">/* keep going */</span></span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// 执行 main() 方法</span></span><br><span class="line">         env-&gt;CallStaticVoidMethod(startClass, startMeth, strArray);</span><br><span class="line">......</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> free(slashClassName);</span><br><span class="line"> <span class="comment">// 销毁虚拟机</span></span><br><span class="line"> ALOGD(<span class="string">&quot;Shutting down VM\n&quot;</span>);</span><br><span class="line"> <span class="keyword">if</span> (mJavaVM-&gt;DetachCurrentThread() != JNI_OK)</span><br><span class="line">     ALOGW(<span class="string">&quot;Warning: unable to detach main thread\n&quot;</span>);</span><br><span class="line"> <span class="keyword">if</span> (mJavaVM-&gt;DestroyJavaVM() != <span class="number">0</span>)</span><br><span class="line">     ALOGW(<span class="string">&quot;Warning: VM did not shut down cleanly\n&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>这里就是启动 Java 类的地方了，根据前面的分析我们知道，这里的 Java 类只有 ZygoteInit 和 RuntimeInit 两种情况。我们先考虑启动的是 zygote 进程的情况，因此我们接下来分析一下 ZygoteInit 这个类。</p>
<h3 id="ZygoteInit"><a href="#ZygoteInit" class="headerlink" title="ZygoteInit"></a>ZygoteInit</h3><p>先看它的 main() 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String argv[])</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">boolean</span> startSystemServer = <span class="keyword">false</span>;</span><br><span class="line">        String socketName = <span class="string">&quot;zygote&quot;</span>;</span><br><span class="line">        String abiList = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; argv.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;start-system-server&quot;</span>.equals(argv[i])) &#123;</span><br><span class="line">                startSystemServer = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (argv[i].startsWith(ABI_LIST_ARG)) &#123;</span><br><span class="line">                abiList = argv[i].substring(ABI_LIST_ARG.length());</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (argv[i].startsWith(SOCKET_NAME_ARG)) &#123;</span><br><span class="line">                socketName = argv[i].substring(SOCKET_NAME_ARG.length());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Unknown command line argument: &quot;</span> + argv[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">        registerZygoteSocket(socketName);</span><br><span class="line">        ......</span><br><span class="line">        preload(); <span class="comment">// 预加载系统资源</span></span><br><span class="line">        ......        </span><br><span class="line">        <span class="comment">// Zygote process unmounts root storage spaces.</span></span><br><span class="line">        Zygote.nativeUnmountStorageOnInit();</span><br><span class="line">        ZygoteHooks.stopZygoteNoThreadCreation();</span><br><span class="line">        <span class="keyword">if</span> (startSystemServer) &#123;</span><br><span class="line">            startSystemServer(abiList, socketName);</span><br><span class="line">        &#125;</span><br><span class="line">        Log.i(TAG, <span class="string">&quot;Accepting command socket connections&quot;</span>);</span><br><span class="line">        runSelectLoop(abiList);</span><br><span class="line">        closeServerSocket();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (MethodAndArgsCaller caller) &#123;</span><br><span class="line">        caller.run(); <span class="comment">// 通过抛出异常的方式清理方法调用栈，从此处执行 zygote 子进程中的逻辑</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        Log.e(TAG, <span class="string">&quot;Zygote died with exception&quot;</span>, ex);</span><br><span class="line">        closeServerSocket();</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解析参数，先是判断是否要启动系统进程，然后获取 abi 列表，最后获取 socket 名称。之后根据 socket 名称注册服务端 socket。接下来就会预加载系统资源，因为应用进程都需要用到系统资源，因此 zygote 提前将这些资源加载好，到时候 fork 出应用进程的时候就可以直接把预加载的系统资源复制过去了，避免每次 fork 后子进程都要重复加载一遍系统资源，提高了效率。之后会决定是否启动 system_server 进程。启动完 system_server 之后的 zygote 进程就会进入一个死循环中，它会一直监听 Socket，看有没有客户端进程向自己发起通信。</p>
<h3 id="Zygote-Fork-子进程"><a href="#Zygote-Fork-子进程" class="headerlink" title="Zygote Fork 子进程"></a>Zygote Fork 子进程</h3><p>我们通过 startActivity() 或者 startActivityForResult() 来启动另一个应用程序时，会通过 Binder 向 AMS 发动请求，AMS 接收到请求后会构造一个 ActivityRecord 对象，这个对象包含要启动的 Activity 的各种信息。之后 AMS 会判断时候 Activity 需要运行的进程是否存在，如果不存在，那么通过 socket 请求 zygote 进程 fork 出一个子进程，再将 ActivityRecord 通过 ApplicationThread 传给那个进程，让它根据这个 ActivityRecord 去启动对应的 Activity。在 AMS 中，请求 zygote fork 进程是通过 Process#start() 方法来完成的，这个方法又会调用 startViaZygote() 方法，这个方法准备好参数后会接着调用 zygoteSendArgsAndGetResult() 方法，这个的名称很好的解释了它的作用：向 zygote 进程发送参数然后获取结果。</p>
<p>zygote 进程接收到消息后就会为本次建立连接，接着会调用 zygote.forkAndSpecialize() fork子进，这个方法是通过 native 层的 ForkAndSpecializeCommon() 方法来进行 fork 的，这里不再深入，直接看看 fork 之后 Java 层的结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// in child</span></span><br><span class="line">        IoUtils.closeQuietly(serverPipeFd);</span><br><span class="line">        serverPipeFd = <span class="keyword">null</span>;</span><br><span class="line">        handleChildProc(parsedArgs, descriptors, childPipeFd, newStderr);</span><br><span class="line">        <span class="comment">// should never get here, the child is expected to either</span></span><br><span class="line">        <span class="comment">// throw ZygoteInit.MethodAndArgsCaller or exec().</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// in parent...pid of &lt; 0 means failure</span></span><br><span class="line">        IoUtils.closeQuietly(childPipeFd);</span><br><span class="line">        childPipeFd = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> handleParentProc(pid, descriptors, serverPipeFd, parsedArgs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    IoUtils.closeQuietly(childPipeFd);</span><br><span class="line">    IoUtils.closeQuietly(serverPipeFd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里根据不同的进程做了不同的处理，如果是子进程，就会调用 handleChildProc() 方法来进行子进程的初始化工作，这个方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleChildProc</span><span class="params">(Arguments parsedArgs,</span></span></span><br><span class="line"><span class="params"><span class="function">        FileDescriptor[] descriptors, FileDescriptor pipeFd, PrintStream newStderr)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> ZygoteInit.MethodAndArgsCaller </span>&#123;</span><br><span class="line">    closeSocket();</span><br><span class="line">    ZygoteInit.closeServerSocket();</span><br><span class="line">    <span class="keyword">if</span> (descriptors != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Os.dup2(descriptors[<span class="number">0</span>], STDIN_FILENO);</span><br><span class="line">            Os.dup2(descriptors[<span class="number">1</span>], STDOUT_FILENO);</span><br><span class="line">            Os.dup2(descriptors[<span class="number">2</span>], STDERR_FILENO);</span><br><span class="line">            <span class="keyword">for</span> (FileDescriptor fd: descriptors) &#123;</span><br><span class="line">                IoUtils.closeQuietly(fd);</span><br><span class="line">            &#125;</span><br><span class="line">            newStderr = System.err;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ErrnoException ex) &#123;</span><br><span class="line">            Log.e(TAG, <span class="string">&quot;Error reopening stdio&quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (parsedArgs.niceName != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Process.setArgV0(parsedArgs.niceName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// End of the postFork event.</span></span><br><span class="line">    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">    <span class="keyword">if</span> (parsedArgs.invokeWith != <span class="keyword">null</span>) &#123;</span><br><span class="line">        WrapperInit.execApplication(parsedArgs.invokeWith,</span><br><span class="line">                parsedArgs.niceName, parsedArgs.targetSdkVersion,</span><br><span class="line">                VMRuntime.getCurrentInstructionSet(),</span><br><span class="line">                pipeFd, parsedArgs.remainingArgs);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        RuntimeInit.zygoteInit(parsedArgs.targetSdkVersion,</span><br><span class="line">                parsedArgs.remainingArgs, <span class="keyword">null</span> <span class="comment">/* classLoader */</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里关闭了 socket，因为子进程不再需要这个 socket 了。之后会通过 parseArgs.invokeWith 来判断是启动应用进程还是启动普通 Java 进程，invokeWith 对应的是 AMS 传过来的 –invoke-with 参数，invokeWith 指定的是要执行的 Java 类。由此看来，Zygote 不仅可以启动 Android 应用进程，也可以启动普通 Java 进程。</p>
<p>如果启动的是 Android 应用进程，那么 RuntimeInit.zygoteInit() 方法会得到调用，这个方法会执行一些初始化工作，如设置缺省的异常处理，设置时区以及初始化 Binder 线程池。最后会调用 invokeStaticMain() 方法调用 ActivityThread 类的 main() 方法。invokeStaticMain() 方法不会直接调用 ActivityThread 的 main() 方法，而是抛出了一个 MethodAndArgsCaller 类型的异常，这个异常和普通的异常不同，它的作用是清理栈帧，我们知道，应用程序的入口是 ActivityThread，而到目前为止，程序依旧跑在 runSelectLoop() 的循环中，在 ActivityThread.main() 方法之前已经积累了很多方法栈，应用程序正常情况下是不会退出 ActivityThread.main() 方法的，所以那些积累的方法栈除了占内存没有其他用途，因此通过抛出异常的方式将它们清理掉。invokeStaticMain() 方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeStaticMain</span><span class="params">(String className, String[] argv, ClassLoader classLoader)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> ZygoteInit.MethodAndArgsCaller </span>&#123;</span><br><span class="line">    Class&lt;?&gt; cl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        cl = Class.forName(className, <span class="keyword">true</span>, classLoader);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Missing class when invoking static main &quot;</span> + className, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Method m;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        m = cl.getMethod(<span class="string">&quot;main&quot;</span>, <span class="keyword">new</span> Class[] &#123; String[].class &#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchMethodException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Missing static main on &quot;</span> + className, ex);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SecurityException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Problem getting static main on &quot;</span> + className, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> modifiers = m.getModifiers();</span><br><span class="line">    <span class="keyword">if</span> (! (Modifier.isStatic(modifiers) &amp;&amp; Modifier.isPublic(modifiers))) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="string">&quot;Main method is not public and static on &quot;</span> + className);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ZygoteInit.MethodAndArgsCaller(m, argv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里将 main() 方法对应的 Method 对象和 argv 封装在了 MethodAndArgsCaller 对象中，然后将其抛出。异常抛出了，那么在哪里进行处理呢？在 ZygoteInit 的 main() 方法中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String argv[])</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ......</span><br><span class="line">        runSelectLoop(abiList);</span><br><span class="line">        closeServerSocket();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (MethodAndArgsCaller caller) &#123;</span><br><span class="line">        caller.run(); <span class="comment">// 通过抛出异常的方式清理方法调用栈，从此处执行 zygote 子进程中的逻辑</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        Log.e(TAG, <span class="string">&quot;Zygote died with exception&quot;</span>, ex);</span><br><span class="line">        closeServerSocket();</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们的程序之前一直在 runSelectLoop() 方法内（为什么？因为 zygote 进程就是在这个方法中无限循环，因此 fork 出来的子进程也会处于这个循环中），抛出 MethodAndArgsCaller 异常后就会在这里被 catch 住，之后便会执行 MethodAndArgsCaller#run() 方法，这个方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mMethod.invoke(<span class="keyword">null</span>, <span class="keyword">new</span> Object[] &#123; mArgs &#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(ex);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException ex) &#123;</span><br><span class="line">        Throwable cause = ex.getCause();</span><br><span class="line">        <span class="keyword">if</span> (cause <span class="keyword">instanceof</span> RuntimeException) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (RuntimeException) cause;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cause <span class="keyword">instanceof</span> Error) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (Error) cause;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法仅仅是简单的调用了 ActivityThread#main() 方法，至此，子进程才真正意义上地开始了工作。以上便是 Zygote 进程的启动原理和 Android 应用进程的启动方式，接下来会分析一下普通的 Java 进程是如何启动的。</p>
<h2 id="普通-Java-进程的启动"><a href="#普通-Java-进程的启动" class="headerlink" title="普通 Java 进程的启动"></a>普通 Java 进程的启动</h2><p>普通的 Java 进程的启动靠的也是 app_process 这个可执行文件，一般会这样启动一个普通的 Java 程序： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">app_process -Djava.class.path=classpath parentDir MainClass MainClassArgs...</span><br></pre></td></tr></table></figure>
<p>其实在分析 Zygote 进程启动过程的时候已经把一部分普通 Java 进程的逻辑也分析了，因为这两种进程有很多相似的逻辑，因此他们的代码都写在一块了。分道扬镳的地方在 AppRuntime#start() 这个方法，如果启动的是普通 Java 进程，那么便会执行 RuntimeInit#main() 方法，这个方法初始化一些东西之后便会调用 AppRuntime#onStarted() 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">virtual <span class="keyword">void</span> <span class="title">onStarted</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sp&lt;ProcessState&gt; proc = ProcessState::self();</span><br><span class="line">    ALOGV(<span class="string">&quot;App process: starting thread pool.\n&quot;</span>);</span><br><span class="line">    proc-&gt;startThreadPool();</span><br><span class="line"></span><br><span class="line">    AndroidRuntime* ar = AndroidRuntime::getRuntime();</span><br><span class="line">    ar-&gt;callMain(mClassName, mClass, mArgs);</span><br><span class="line"></span><br><span class="line">    IPCThreadState::self()-&gt;stopProcess();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法作了两件事：初始化 Binder 线程池，调用我们指定 Java 类的 main() 方法。前面讲过，如果执行的是普通的 Java 类，通过 AppRuntime#setClassNameAndArgs() 方法要启动的类的类名和参数分别保存在 mClassName 和 mArgs 字段中，mClass 是在 AppRuntime#onVmCreated() 中创建的，它对应的是该类的 Class 对象。至此，一个 Java 进程就启动了。现在我们通过实践来体会一下让 Android 系统启动我们写好的普通 Java 程序。</p>
<h3 id="在-Android-系统上运行普通的-Android-程序"><a href="#在-Android-系统上运行普通的-Android-程序" class="headerlink" title="在 Android 系统上运行普通的 Android 程序"></a>在 Android 系统上运行普通的 Android 程序</h3><p>因为只是做个试验而已，因此我们就编写个 HelloWord 类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">		System.out.println(args[<span class="number">0</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在编译它，记住要用 JDK1.7 编译，因为 Android 目前还不支持 JDK1.8 编译出来的 class 类。编译好后就是一个 HelloWorld.class 文件了，我们知道 DVM 无法运行 class 文件，因此我们需要通过 dx 工具将该 class 文件转换成 dex 文件。dx 工具在 <code>sdk/build-tools/build-tool版本号</code> 目录下。我们将 Test.class 放置在该目录下，然后打开终端，切换到这个目录并执行如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dx --dex --output=test.dex HelloWorld.class</span><br></pre></td></tr></table></figure>
<p>运行成功的话在这个目录下就能看到 test.dex 文件了，现在我们把这个文件放置在 /sdcard 下，现在通过 adb 执行以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell</span><br><span class="line">app_process -Djava.class.path=/sdcard/test.dex HelloWorld first-parameter</span><br></pre></td></tr></table></figure>
<p>接下来不出意外的话终端会出现这两行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hello world</span><br><span class="line">first-parameter</span><br></pre></td></tr></table></figure>
<p>当然，除了通过终端的方式执行 Java 程序，也可以在 Android 应用的代码里执行。前面的步骤不变，我们编写如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppcompatActivity</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">		setContentView(R.layout.main);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">		  Process proc = Runtime.getRuntime().exec(<span class="string">&quot;app_process -Djava.class.path=/sdcard/test.dex HelloWorld first-parameter&quot;</span>);</span><br><span class="line">          InputStream in = proc.getInputStream();</span><br><span class="line">          InputStreamReader isr = <span class="keyword">new</span> InputStreamReader(in);</span><br><span class="line">          BufferedReader br = <span class="keyword">new</span> BufferedReader(isr)</span><br><span class="line">          Toast.makeText(<span class="keyword">this</span>, br.readLine(), Toast.LENGTH_SHORT).show();</span><br><span class="line">          Toast.makeText(<span class="keyword">this</span>, br.readLine(), Toast.LENGTH_SHORT).show();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Android 应用一启动时就会执行启动 Java 进程的命令，接着获取该命令的输入流（可通过 Process 获取三种流，输入流、错误输入流和输出流，这分别对应着 Process 的输出流、错误输出流和输入流），接着通过 Taost 依次显示从输入流获取的两行字符串。不出意外的 Toast 会依次显示 “hello world” 和 “first-parameter”。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上是对 《深入理解 Android 5.0 系统》中第八章的总结和理解。</p>
<p>参考链接：</p>
<ul>
<li><a href="http://m.jb51.net/article/75147.htm">Android中执行java命令的方法及java代码执行并解析shell命令
</a></li>
<li><a href="https://stackoverflow.com/questions/20932102/execute-shell-command-from-android">execute shell command from android</a></li>
<li><a href="http://androidxref.com/7.1.1_r6/">AndroidXref - Android Source Code Cross Reference</a></li>
</ul>
]]></content>
      <tags>
        <tag>Android</tag>
        <tag>进程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 注解学习总结</title>
    <url>/2017/08/29/2017-08-29-java-annotation/</url>
    <content><![CDATA[<h1 id="Java-注解学习"><a href="#Java-注解学习" class="headerlink" title="Java 注解学习"></a>Java 注解学习</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>注解是在 JDk 5 时引入的，注解可以提供一些元数据，它们能为所注解的代码提供一些不属于程序本身的数据，从而可以对程序提供一些辅助功能。这些辅助功能包括编译时检查（错误和警告）、编译时和部署时的代码加工，以及运行时的代码处理。这三种注解分别被称为源码级别的注解（这些注解主要是在编辑代码时为程序员提供错误信息）；编译时注解：这种类型的注解一般需要配合注解处理器框架使用，可以在编译器编译项目时生成一些文件，包括 .java 源文件和 .xml 配置文件等；运行时注解：在程序运行的时候为程序提供一些功能，一般配合反射框架使用。</p>
<span id="more"></span>
<h2 id="注解的定义和使用"><a href="#注解的定义和使用" class="headerlink" title="注解的定义和使用"></a>注解的定义和使用</h2><p>在细讲这三种注解的区别前，先简单说下注解的定义和使用。</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>注解的使用想必大家很熟悉了，如最常见的 Override 注解，这种注解没有配置参数，被称为标记注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Overide</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>&#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>有参数的注解常见的有 SuppressWarnings 注解，这个注解用来关闭编译器的警告，如关闭 unchecked（未受检）警告和 deprecation（使用了已弃用方）警告：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">useDeprecatedMethod() &#123;</span><br><span class="line">    deprecatedMethod();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个注解带有配置参数，并且参数值可以有多个，表示需要关闭多种类型的警告，比如需要同时关闭 unchecked 和 deprecation 警告：@SuppressWarnings({“unchecked”, “deprecation”})。</p>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>Java 类库中有很多预定义好的注解，如上面那两个，用户也可以自己定义注解，注解的定义是这样的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.Type)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line">@<span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Repeatable</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Person &#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">GENDER</span> </span>&#123;MALE, FEMALE&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">id</span><span class="params">()</span> <span class="keyword">default</span> -1</span>;</span><br><span class="line">    <span class="function">GENDER <span class="title">gender</span><span class="params">()</span> <span class="keyword">default</span> GENDER.MALE</span>;</span><br><span class="line">    String[] hobit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的例子中，定义了一个名为 Person 的注解。注意 Person 前面的 @interface，它是来声明注解用的，和 class 和 enum 是一个级别的东西，所有的注解都会自动继承 Annation 接口。我们发现这个注解定义上也有多个注解，他们被称为“元注解”，作用是注解其他的注解。那么它们含义是什么呢？首先看 Target 注解，它用来说明我们定义的注解的总用范围，它含有一个枚举类型的参数，可以取以下值：</p>
<ul>
<li>ElementType.ANNOTATION_TYPE 作用于注解类型上（元注解就是这种类型，而且这种类型的注解可以自注解，即自己作用在自己身上）。</li>
<li>ElementType.CONSTRUCTOR 作用于构造器。</li>
<li>ElementType.FIELD 作用于类属性。</li>
<li>ElementType.LOCAL_VARIABLE 作用于局部变量。</li>
<li>ElementType.METHOD 作用于方法。</li>
<li>ElementType.PACKAGE 作用于包的声明。</li>
<li>ElementType.PARAMETER 作用于方法参数。</li>
<li>ElementType.TYPE 作用于接口，类和枚举。</li>
</ul>
<p>@Documented 注解用来说明 javadoc 工具是否为该注解生成文档，因为注解默认是不生成文档的。@Inherited 注解表示的是该注解可从父类传给子类，比如用 Person 去注解一个类，那么这个类的子类即使没有 Person 所注解，但是由于 Person 的可继承性，子类也同样被隐式的被 Person 注解了。@Repeatable 表示该注解可以重复注解在某一个元素上，这个注解是在 java8 引入的。@Retention 注解用来说明该注解的级别，是源码级别的（编辑时注解），还是类级别的（编译时注解，这种注解会被编译器保留，但会被 JVM 忽略），运行时级别的（被 JVM 保留，并且在运行时被使用）。</p>
<p>@Person 含有四个配置参数，它们的声明看起来像是方法。需要注意的是注解的配置参数的类型只可以是基本数据类型、枚举、Class、String 和以上类型的数组类型。当注解只含有一个配置参数时，一般参数名直接用 “value”，因为注解本身的名称就很好的解释了 value 的意义。现在看看如何用 @Person 注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Person(name=&quot;Chance&quot;, id=16, gender=GENDER.MALE&quot;, hobit=&#123;&quot;music&quot;, &quot;movie&quot;, &quot;game&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Chance</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相信大家一目了然，就不细讲了。需要说明的是，这里使用名值对的形式表示注解。如果只有一个配置参数，那么写配置参数的时候可以将参数名称省略掉，就像 @SupperssWarnings 一样。并且要注意的是，注解的某些参数的配置参数后可以通过 default 关键字指定默认值，如果没有指定，那么使用该注解时一定要填写该参数值，否则编译器会报错。也就是说，没有默认值的参数是必填项。</p>
<h2 id="源码级别的注解"><a href="#源码级别的注解" class="headerlink" title="源码级别的注解"></a>源码级别的注解</h2><p>之所以称之为源码级别的注解，就是注解信息仅仅会在源码中保留，不会编译到 class 文件中。这和它的作用相符：因为它仅仅是为编辑器提供信息而已。这种注解常见的如 @Override、@SuppressWarnings、@Deprecated 等。这种注解比较简单，就不细说了。</p>
<h2 id="编译时注解"><a href="#编译时注解" class="headerlink" title="编译时注解"></a>编译时注解</h2><p>这种类型的注解要配合注解处理器来使用，什么是注解处理器？为什么要注解处理器？注解处理器顾名思义就是对注解进行处理的工具，为什么需要注解处理器呢？前面说了，注解其实对被注解的代码不会有任何影响，也就是说它们不会被项目中的代码识别，那么要想它们发挥作用，必定是需要能够识别它们的东西。编辑时注解器靠的就是编辑器来识别，而编译时处理器靠的便是注解处理器了，下面要说的运行时注解靠的就是反射框架了。如何定义注解处理器呢？</p>
<h2 id="运行时注解"><a href="#运行时注解" class="headerlink" title="运行时注解"></a>运行时注解</h2><p>运行时注解可以反射框架来实现，比如对于上面那个例子，假设 @Person 注解是运行时注解，那么可以定义一个注解的运行时解析类在运行时获取注解的信息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationUtil</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inject</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">       Class cls = target.getClass();</span><br><span class="line">       <span class="keyword">if</span> (cls.isAnnotationPresent(Person.class)) &#123;</span><br><span class="line">       	Person personAnnotation = cls.getAnnotation(Person.class);</span><br><span class="line">       	System.out.print(personAnnotation.toString());</span><br><span class="line">        <span class="comment">//  System.out.print(personAnnotation.gender());</span></span><br><span class="line">        <span class="comment">//  System.out.print(personAnnotation.hobit());</span></span><br><span class="line">        <span class="comment">//  System.out.print(personAnnotation.id());</span></span><br><span class="line">        <span class="comment">//  System.out.print(personAnnotation.name());</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后这样定义 Chance：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Person(name=&quot;Chance&quot;, id=16, gender=GENDER.MALE&quot;, hobit=&#123;&quot;music&quot;, &quot;movie&quot;, &quot;game&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Chance</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Chanece</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		AnnotationUtil.inject(<span class="keyword">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Chance c = <span class="keyword">new</span> Chance();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后打印出来的结果是这样的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@com</span>.company.MyAnnotation(gender=MALE, id=<span class="number">16</span>, name=Chance, hobit=[music, movie, game])</span><br></pre></td></tr></table></figure>
<p>通过反射就可以拿到注解信息。如果注解作用在字段或者方法上，也是通过同样的方法获取注解的信息的，这里就不再说了。拿到注解信息后想干什么那就看自己的喜好了，很多第三方框架就是通过这种方法来获取注解信息然后实现一些看似很炫酷的功能。比如 Retrofit，刚接触的时候很疑惑，为什么在接口方法上使用注解就可以 “实现” 该接口呢？其实它就是在运行时获取注解信息然后根据这些信息通过动态代理的方式实现该接口。</p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Android 事件分发规律总结</title>
    <url>/2017/09/05/2017-09-05-android-how-motion-event-dispatched/</url>
    <content><![CDATA[<h1 id="Android-事件分发规律总结"><a href="#Android-事件分发规律总结" class="headerlink" title="Android 事件分发规律总结"></a>Android 事件分发规律总结</h1><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>事件序列：手指接触屏幕开始到离开屏幕为止产生的事件为一次事件序列。</p>
<h2 id="规律一"><a href="#规律一" class="headerlink" title="规律一"></a>规律一</h2><p>从父视图的角度来看，无论他的子视图是 View 还是 ViewGroup，对父视图来说都是透明的。它只知道如果当 ACTION_DOWN 事件传给子视图后子视图的 dispatchTouchEvent () 返回 true，说明子视图想要处理这个事件，那么以后的事件就都交给它，不管以后子视图的 dispatchTouchEvent() 返回的是 true 还是 false; 如果 ACTION_DOWN 事件传给子视图后子视图返回的是 false，那么以后的事件再也不会传给子视图（子视图没有处理 ACTION_DOWN 就视作它不想处理该事件序列）。如果一个子视图的 dispatchTouchEvent() 在处理 ACTION_DOWN 时返回 true ，只要父视图没有拦截事件, 那么该事件序列中的后续事件都会传入该视图中，也就是传入该视图的 dispatchTouchEvent() 方法中，就算手指的触摸区域已经超出了该视图的范围。并且对于该事件序列的之后所有事件，即使该视图的 dispatchTouchEvent() 返回 false 事件也同样会继续传入该视图，唯一的影响是会将该事件原路返回，最终落到 activity.onTouchEvent() 中。因此建议如果消耗了该事件，除非有特殊情况需要处理，最好不要返回 false，否则上级视图以为下面的视图没有处理事件从而自己处理。</p>
<span id="more"></span>
<h2 id="规律二"><a href="#规律二" class="headerlink" title="规律二"></a>规律二</h2><p>父视图有两种角色，一种是 ViewGroup , 另一种是 View。当父视图的角色是 ViewGroup 时，父视图的主要任务就是分派事件给子视图；当父视图的角色为 View 时，它和普通的 View 一样处理事件。<br>父视图在两种情况下会将事件拿给自己处理：<br>1）如果没有子视图能够处理事件，那么只能由父视图自己处理，此时会把事件传给 super.dispatchTouchEvent()，也就是父类方法来处理（注意是父类，不是父视图）。<br>2）假如本来整个事件序列都是要传给子视图的，但是中途父视图想要拦截的话，从父视图决定拦截开始之后的所以事件都不会再交给子视图处理了，但是决定拦截时的那一次的事件会还是会交给子视图的，只不过是事件的类型是 ACTION_CANCEL，这样做的原因我认为可能是通知一下子视图父视图拦截了你的事件，免得子视图事件被拦截了还蒙在鼓里（其实就是让开发者可以对这种情况加以处理）。从开始拦截的那一次开始，之后的所有事件（不包括拦截的那一次）都不会传给子视图了，都传入 super.dispatchOnToucnEvent() 中，即交给父视图给自己处理。</p>
<h2 id="规律三"><a href="#规律三" class="headerlink" title="规律三"></a>规律三</h2><p>如果事件是交给自己处理，不管是子视图还是父视图，只要事件交给了自己处理，那么事件的处理流程都是一样的（这个流程在 View 中定义），下面来分析是如它们何处理事件的：<br>如果视图将事件交给自己处理，那么事件首先都是从 dispatchTouchEvent() 传入的（父视图是 super.dispatchTouchEvent()），这个方法的逻辑是：如果该视图注册了OnTouchListener 监听器，并且监听器不为 null，那么就把事件交给监听器中的 onTouch() 方法。下一步就是看 onTouch() 的返回值了，如果返回值为 true，那么说明 onTouch() 消费了该事件，事件的传递到此为止， dispatchTouchEvent() 返回 true；如果返回值为 false，那么说明 onTouch() 方法并没有消耗该事件，那么进行下一步的事件分发。下一步事件会传给 onTouchEvent 方法，这个方法是最常见也最常用的方法，对于一个 自定义 View 来说，这个方法是根据事件来更改 View 的行为的主要场所。dispatchTouchEvent() 同样需要根据 onTouchEvent() 的返回值来决定下一步的事件转发流程。如果 onTouchEvent() 返回 false，那么 dispatchTouchEvent() 返回的就是 false，否则返回的就是 true。这个过程可以用如下代码表示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (onTouchListener != <span class="keyword">null</span>) ? (onTouchListener.onTouch(e) ? <span class="keyword">true</span> : onTouchEvent(ev)) : onTouchEvent(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之前已经说到，如果当父视图接收到 ACTION_DOWN 事件时，如果没有子视图能够处理该事件，那么后续的事件就不会给该子视图了，并且该事件会交给父视图处理，即传入父视图的 super.dispatchTouchEvent() 方法中。子视图有没有处理该事件就是根据 dispatchTouchEvent() 的返回值来看的。返回 true 表示处理，false 表示未处理。如果子视图对于 ACTION_DOWN 事件进行了处理（dispatchTouchEvent() 返回true），那么之后的事件都会给它处理，不管子视图之后 dispatchTouchEvent() 是否返回 true，也就是说，父视图会忽略子视图接下来的 dispatchTouchEvent() 的返回值，只要事件继续发生就都传给该子视图。但是，返回 false 会导致事件从该子视图返回给上级视图，上级视图也不会处理该事件，该事件会一直上传，直至传到 Activity 中的 onTouchEvent() 方法中。 </p>
<h2 id="规律四"><a href="#规律四" class="headerlink" title="规律四"></a>规律四</h2><p>关于事件的拦截：<br>父视图可以在任何时候拦截本应该传递子视图的事件，拦截的依据就是 onInterceptTouchEvent() 的返回值，true 表示拦截，false 表示不拦截，父视图每次分发事件时会根据这个方法的返回值决定是否开始拦截：如果返回 false，即不拦截该事件，父视图下次分发事件时依然会调用这个方法来判断是否开始拦截事件；如果返回 true，说明该事件需要拦截，那么以后的事件，包括该事件都会直接交由父视图的 super.dispatchTouchEvent() 方法处理，而不会再传入子视图的 dispatchTouchEvent() 方法中 。但是开始拦截的那个事件还是会交给那个子视图，只是事件的类型变为了 ACTION_CANCEL。</p>
<h2 id="规律五"><a href="#规律五" class="headerlink" title="规律五"></a>规律五</h2><p>事件在系统中的传递流程：ViewRootImpl =&gt; DecorView(调用的方法是 dispatchTouchEvent()) =&gt; WindowCallback(即Activity) =&gt; PhoneWindow =&gt; DecorView(调用的方法是 super.dispatchTouchEvent)</p>
<h2 id="规律六"><a href="#规律六" class="headerlink" title="规律六"></a>规律六</h2><p>子视图可以调用父视图的 requestDisallowInterceptTouchEvent() 方法来向父视图请求不拦截事件。但是这个方法只对除 ACTION_DOWN 之外的其他事件有效，如果父视图选择拦截 ACTION_DOWN，子视图即使在此之前调用此方法也是没有任何用的。并且需要注意，如果父视图在此方法调用之前就已经对事件进行了拦截，那么这个方法也同样无效。</p>
<h2 id="规律七"><a href="#规律七" class="headerlink" title="规律七"></a>规律七</h2><p>父视图如何找到能够接受某个事件的子视图？</p>
<p>假设在父视图中的事件坐标是 (x, y)</p>
<p>1）首先要转换成相对子视图的坐标，转换的步骤如下：</p>
<p>首先要考虑父视图是否发生滚动，其次需要考虑子视图是否发生平移，如果用（x’, y’）表示转换后的坐标，那么有：</p>
<p>x’ = x + scrollX - child.left - child.translationX;<br><br>y’ = y + scrollY - child.top - child.translationY;</p>
<p>其实在源码中上述变换过程分为两步进行：</p>
<ol>
<li>第一步不考虑平移：x’ = x + scrollX - child.left; </li>
<li>第二步通过 TransformationInfo（内含变换矩阵） 将平移考虑进去：x’ = x + scrollX - child.left - child.translationX;</li>
</ol>
<p>2）然后根据相对子视图的坐标判断该点是否落在子视图的范围内。判断的依据是：x’ &lt; width &amp;&amp; y’ &lt; height &amp;&amp; x’ &gt;= 0 &amp;&amp; y’ &gt;= 0（width 和 height 是子视图的宽高）。</p>
]]></content>
      <tags>
        <tag>Android</tag>
        <tag>View</tag>
        <tag>事件分发</tag>
      </tags>
  </entry>
  <entry>
    <title>Android LaunchMode 总结</title>
    <url>/2017/11/07/2017-11-07-android-launch-mode/</url>
    <content><![CDATA[<h1 id="Android-LaunchMode-总结"><a href="#Android-LaunchMode-总结" class="headerlink" title="Android LaunchMode 总结"></a>Android LaunchMode 总结</h1><p>Android 中的 LaunchMode 是一个比较基础的知识点，关于这块之前每次都是先用现学，然后学了之后又忘了，现在把 LaunchMode 的规律记录下来以备后用。</p>
<h2 id="需要了解的知识点"><a href="#需要了解的知识点" class="headerlink" title="需要了解的知识点"></a>需要了解的知识点</h2><p>在讲 LaunchMode 之前，需要了解一下几点知识：</p>
<ol>
<li>task 有属性 affinity，Activity 有属性 taskAffinity</li>
<li>可以存在两个 affinity 一样的 task；</li>
<li>一个 Activity 的 taskAffnity 默认值为 package name，如果有指定值就会设为指定值<span id="more"></span>
<h2 id="LuanchMode-规律总结"><a href="#LuanchMode-规律总结" class="headerlink" title="LuanchMode 规律总结"></a>LuanchMode 规律总结</h2></li>
</ol>
<p>Manifest 中注册了两个 Activity，它们的类型分别为 AActivity 和 BActivity。假设 AActivity 的 taskAffinity 为 a，现在通过 BActivity 的一个实例 B 启动 AActivity：</p>
<h4 id="如果此时-AActivity-的实例不存在于任何-task-中，那么："><a href="#如果此时-AActivity-的实例不存在于任何-task-中，那么：" class="headerlink" title="如果此时 AActivity 的实例不存在于任何 task 中，那么："></a>如果此时 AActivity 的实例不存在于任何 task 中，那么：</h4><ul>
<li>如果  AActivity 的启动模式为 singleTask， 那么先会找是否存在 affinity 为 a 的 task，如果存在并且这个 task 中的 Activity 不是 singleInstance，那么就在那个 task 中创建并启动一个 AActivity 的实例 ；如果不存在，那么新建一个 affinity 为 a  的 task，然后在新建的 task 中创建并启动一个 AActivity 的实例；</li>
<li>如果 AActivity 的启动模式为 singleInstance，那么无论是否存在 affinity 为 a 的 task ，总会新建一个 affinity 也为 a 的 task，并在这个新建的 task 中创建并启动一个 AActivity 的实例；</li>
<li>如果 Activity 的启动模式为 standard （默认值) 或者 singleTop，那么就要看 BActivity 的启动模式了：<ul>
<li>如果 BActivity 的启动模式不为 singleInstance 的话，那么  AActivity  的 taskAffinity 属性会被忽略，然后就在 B 所在的 task 中创建并启动一个 AActivity 的实例；</li>
<li>如果  BActivity 的启动模式为 singleInstance 的话，那么 AActivity 的 taskAffinity 属性不会被忽略，此时系统就会去找一个 affinity 为 a 的 task：如果能找到并且这个 task 中的 Activity 不为 singleInstance，那么就会在那个 task 中创建并启动一个 AActivity 的实例；否则新建一个 affinity 为 a 的 task，然后在这个新建的 task 中创建并启动启动一个 AActivity 的实例。</li>
</ul>
</li>
</ul>
<h4 id="如果-AActivity-的实例已经存在于某个任务栈中，那么："><a href="#如果-AActivity-的实例已经存在于某个任务栈中，那么：" class="headerlink" title="如果 AActivity 的实例已经存在于某个任务栈中，那么："></a>如果 AActivity 的实例已经存在于某个任务栈中，那么：</h4><ul>
<li>如果 AActivity 的启动模式为 standard ，那么就要看 BActivity 的启动模式了：<ul>
<li>如果 BActivity 的启动模式不为 singleInstance 的话，那么  AActivity  的 taskAffinity 属性会被忽略，然后就会在 B 所在的 task 中启动；</li>
<li>如果  BActivity 的启动模式为 singleInstance 的话，那么 AActivity 的 taskAffinity 属性不会被忽略，系统会去找一个 affinity 为 a 的 task：如果能找到并且这个 task 中的 Activity 不为 singleInstance，那么就会在那个 task 中创建并启动一个 AActivity 的实例；否则新建一个 affinity 为 a 的 task，然后在这个新建的 task 中创建并启动一个  AActivity 的实例。</li>
</ul>
</li>
<li>如果 AActivity 的启动模式为 singleTop 的话 ，同样要看 BActivity 的启动模式：<ul>
<li>如果 BActivity 的启动模式不为 singleInstance 的话，那么  AActivity  的 taskAffinity 属性会被忽略，然后就会在  B 所在的 task 中启动；但是，如果 BActivity = AActivity，那么就不会创建并启动一个 AActivity 的实例了，此时只会调用 B 的 onNewIntent 方法；</li>
<li>如果 BActivity 的启动模式为 singleInstance 的话，那么 AActivity 的 taskAffinity 属性不会被忽略，此时系统就会去找一个 affinity 为 a 的 task：如果能找到并且这个 task 中的 Activity 不为 singleInstance，那么就会在那个 task 中启动；但是如果这个 task 的栈顶已经有一个 AActivity 的实例 A，就不会再次创建并启动另一个 AActivity 的实例了，此时只会调用栈顶的这个 A 的 onNewIntent() 方法；</li>
</ul>
</li>
<li>如果 AActivity 的启动模式为 singleInstance，那么一定会找到一个 affinity 为 a 的 task（为什么？因为我们假设 AActivity 的实例已经存在于某个 task 中，而根据 singleInstance 的特点，这个 task 的 affinity 一定为 a），并且该 task 中只有一个 AActivity 的实例 A，此时不会再次创建并启动另一个 AActivity 的实例，此时只会调用  A 的 onNewIntent() 方法；</li>
<li>如果  AActivity 的启动模式为 singleTask， 那么先一定会找到 affinity 为 a 的 task（为什么？因为我们已经假设 AActivity 的实例已经存在于某个 task 中，而根据 singleTask 的特点，这个 task 的 affinity 一定为 a），并且该栈中已经存在一个 AActivity 的实例 A，此时会把该 task 中位于 A 上方的所有 Activity 清理出栈，然后调用 A  的 onNewIntent() 方法。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>关于 LaunchMode，光靠阅读文章是不能深刻理解其中规律的。大家可以尝试自己写一些各种启动模式的 Activity，让他们相互启动，再通过 adb shell dumpsys 这个命令查看任务栈以及其中的 Activity，这样应该能很快理解 LaunchMode 的规律的，也能记得更牢。</p>
]]></content>
      <tags>
        <tag>Android</tag>
        <tag>LaunchMode</tag>
      </tags>
  </entry>
  <entry>
    <title>Glide 源码探究</title>
    <url>/2017/07/20/2017-7-20-android-open-source-library-glide/</url>
    <content><![CDATA[<h1 id="Glide-源码探究"><a href="#Glide-源码探究" class="headerlink" title="Glide 源码探究"></a>Glide 源码探究</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Glide 是安卓平台上媒体管理和图片加载框架，它内部封装了媒体解码工具、内存和磁盘缓存以及资源池等，并向用户暴露简单易用的接口。我们可以用它来获取、解码、并展示视频、图片和 GIF 动画。如果大家有用过 Picasso 应该知道，Glide 的使用方式和 Picasso 非常相似，甚至很多 API 的名称都一样。但是相比 Picasso，Glide 的功能更加强大，内部实现也更加复杂。接下来我们就从源码的角度来探究一下 Glide 的内部原理。</p>
<span id="more"></span>

<h2 id="Glide-的简单使用"><a href="#Glide-的简单使用" class="headerlink" title="Glide 的简单使用"></a>Glide 的简单使用</h2><p>在探究 Glide 的原理之前，我们先熟悉一下它的常见 API，这样有助于我们后面的分析。Glide 的 API 使用了流式 API 风格，加载图片一行代码就能搞定：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Glide.with(context).load(url).into(imageView);</span><br></pre></td></tr></table></figure>
<p>当然，以上只是 Glide 最基础、最常见的用法，它的功能远不止于此，基本上关于图片加载的需求它都能满足。上面这行代码调用了三次方法，经历了三个不同的过程：with() 方法用来获取 RequestManager；load() 方法根据传入的 url 返回了一个 RequestBuilder 对象；into() 方法创建了图片加载请求对象 Request 并开启了加载工作。现在，我们就来分析这三个过程。</p>
<h2 id="Glide-原理"><a href="#Glide-原理" class="headerlink" title="Glide 原理"></a>Glide 原理</h2><h3 id="获取-RequestManager"><a href="#获取-RequestManager" class="headerlink" title="获取 RequestManager"></a>获取 RequestManager</h3><p>Glide 的 with(Context) 方法返回的不是 Glide 实例，而是一个 RequestManager 对象，顾名思义，它用来管理图片加载请求。with() 方法有多个重载，除了接受 Context，它还可以接受 Activity，Fragment，View 等对象，这些重载方法如下：</p>
<p>[-&gt;Glide.java]</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RequestManager <span class="title">with</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getRetriever(context).get(context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RequestManager <span class="title">with</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getRetriever(activity).get(activity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RequestManager <span class="title">with</span><span class="params">(android.app.Fragment fragment)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getRetriever(fragment.getActivity()).get(fragment);   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RequestManager <span class="title">with</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getRetriever(view.getContext()).get(view);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这几个重载方法长得都差不多，结果都是返回一个 RequestManager 对象。这个过程分为两步：先通过 getRetriver() 获取一个 RequestManagerRetriever 对象，再通过这个对象的 get() 方法来获取 RequestManager。先看下 getRetriver() 方法：</p>
<p>[-&gt;Glide.java]</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> RequestManagerRetriever <span class="title">getRetriever</span><span class="params">(<span class="meta">@Nullable</span> Context context)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> Glide.get(context).getRequestManagerRetriever();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>静态方法 Glide#get() 创建了 Glide 单例，然后通过它的 getRequestManagerRetriever() 返回一个 RequesetManagerRetriever 对象。RequestManagerRetriever 顾名思义，是用来获取 ReqeustManager 的，那么它是怎样得到 RequestManager 对象的呢？我们先来分析下它的一个参数类型为 Context 的 get() 重载方法 ：</p>
<p>[-&gt;RequestManagerRetriever.java]</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> RequestManager <span class="title">get</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (context == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;You cannot start a load on a null Context&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Util.isOnMainThread() &amp;&amp; !(context <span class="keyword">instanceof</span> Application)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (context <span class="keyword">instanceof</span> FragmentActivity) &#123;</span><br><span class="line">      <span class="keyword">return</span> get((FragmentActivity) context);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (context <span class="keyword">instanceof</span> Activity) &#123;</span><br><span class="line">      <span class="keyword">return</span> get((Activity) context);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (context <span class="keyword">instanceof</span> ContextWrapper) &#123;</span><br><span class="line">      <span class="keyword">return</span> get(((ContextWrapper) context).getBaseContext());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> getApplicationManager(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法最终会转调两类方法：一是 get() 重载方法，二是 getApplicationManager()。调用 get() 方法的时机是：当前线程在主线程，并且 Context 的实际类型为 FragmentActivity，Activity 和 ContextWrapper 其中之一。其他情况下都会调用 getApplicationManager()。我们看看 get(Activity)：</p>
<p>[-&gt;RequestManagerRetriever.java]</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> RequestManager <span class="title">get</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (Util.isOnBackgroundThread()) &#123;</span><br><span class="line">    <span class="keyword">return</span> get(activity.getApplicationContext());</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    assertNotDestroyed(activity);</span><br><span class="line">    android.app.FragmentManager fm = activity.getFragmentManager();</span><br><span class="line">    <span class="keyword">return</span> fragmentGet(activity, fm, <span class="keyword">null</span> <span class="comment">/*parentHint*/</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果当前线程是后台线程，会再次调用 get(Context) 方法，因为传入的 Context 是 ApplicationContext，因此这个方法最终会调用 getApplicationManager(Context)；如果不是后台线程，在 Activity 还没销毁的前提下，会调用 fragmentGet()。get(FragmentActivity) 的逻辑和 get(Activity) 类似，这里就不赘述了，有兴趣可以自行查看源码。</p>
<p>假设加载动作发生在主线程，fragmentGet() 会得到调用，其源码如下：</p>
<p>[-&gt;RequestManagerRetriever.java]</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> RequestManager <span class="title">fragmentGet</span><span class="params">(Context context, android.app.FragmentManager fm,</span></span></span><br><span class="line"><span class="params"><span class="function">    android.app.Fragment parentHint)</span> </span>&#123;</span><br><span class="line">  RequestManagerFragment current = getRequestManagerFragment(fm, parentHint);</span><br><span class="line">  RequestManager requestManager = current.getRequestManager();</span><br><span class="line">  <span class="keyword">if</span> (requestManager == <span class="keyword">null</span>) &#123;</span><br><span class="line">    Glide glide = Glide.get(context);</span><br><span class="line">    requestManager =</span><br><span class="line">        factory.build(glide, current.getGlideLifecycle(), current.getRequestManagerTreeNode());</span><br><span class="line">    current.setRequestManager(requestManager);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> requestManager;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前 FragmentManager 中的 RequestManagerFragment</span></span><br><span class="line"><span class="function">RequestManagerFragment <span class="title">getRequestManagerFragment</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">final</span> android.app.FragmentManager fm, android.app.Fragment parentHint)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 根据 TAG 查找</span></span><br><span class="line">  RequestManagerFragment current = (RequestManagerFragment) fm.findFragmentByTag(FRAGMENT_TAG);</span><br><span class="line">  <span class="keyword">if</span> (current == <span class="keyword">null</span>) &#123;</span><br><span class="line">    current = pendingRequestManagerFragments.get(fm);</span><br><span class="line">    <span class="keyword">if</span> (current == <span class="keyword">null</span>) &#123;</span><br><span class="line">      current = <span class="keyword">new</span> RequestManagerFragment();</span><br><span class="line">      current.setParentFragmentHint(parentHint);</span><br><span class="line">      pendingRequestManagerFragments.put(fm, current);</span><br><span class="line">      <span class="comment">// 将创建的 RequestManagerFragment 添加到 FragmentManager 中</span></span><br><span class="line">      fm.beginTransaction().add(current, FRAGMENT_TAG).commitAllowingStateLoss();</span><br><span class="line">      handler.obtainMessage(ID_REMOVE_FRAGMENT_MANAGER, fm).sendToTarget();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> current;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上面的代码可以知道，get(Activity) 方法的逻辑是从当前 Activity 中找 RequestManagerFragment，有则从其中取出 RequestManager，无则创建一个ReqeustManagerFragment 和 RequestManager，将 RequestManagerFragment 和 RequestManager 关联之后把 RequestManager 对象返回。这里有一个比较奇怪的地方：为什么要创建 RequestManagerFragment？我们看下 RequestManagerFragment 的文档说明：</p>
<blockquote>
<p>A view-less {@link android.app.Fragment} used to safely store an {@link<br> com.bumptech.glide.RequestManager} that can be used to start, stop and manage Glide requests<br> started for targets the fragment or activity this fragment is a child of.</p>
</blockquote>
<p>通过文档可知，其实 Glide 在这里使用了 “奇技淫巧”，它借助 RequestManagerFragment 来跟踪 Activity 或者 Fragment 的生命周期。为什么要这么做呢？这要从图片加载的场景来理解。本着减少网络请求及各种资源消耗的目的，通常我们会希望如果当前界面被覆盖或者被销毁，图片是不进行加载的。而图片加载库如何能感知界面被覆盖和被销毁呢？我们知道 Activity 或者 Fragment 的生命周期其实和交互界面的变化是相关联的，因此可以利用 Activity 或者 Fragment 的生命周期来驱动图片的加载过程，比如可以在 onStart() 方法中开始图片加载，在 onStop() 方法中暂停图片的加载。然而，如果要在客户端代码中的每一个 Activity 或者 Fragment 中加入这些逻辑，首先代码显得混乱、冗余；其次将图片的加载管理交给开发者实现，增加了开发者的工作，开发者必须实现一套行之有效的图片加载管理方案，这显然不是一个优秀的图片加载库应该做的事。那怎么办呢？这时候 RequestManagerFragment 就派上用场了，如果将 RequestManagerFragment 动态添加入当前的 Activity 或者 Fragment 中，那么 RequestManagerFragment 也将获得生命周期，就可以用 RequestManagerFragment 生命周期来驱动 Glide 的加载。RequestManagerRetriever 的所有 get() 方法，其实都在做同一件事情：根据传入的参数找到当前加载环境关联的 Activity 或者 Fragment，然后设法将 RequesManagerFragment 嵌入其中，最后返回具备生命周期的 RequestManager。我们可以通过 get(View) 来进一步验证：</p>
<p>[-&gt;RequestManagerRetriever.java]</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> RequestManager <span class="title">get</span><span class="params">(<span class="meta">@NonNull</span> View view)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (Util.isOnBackgroundThread()) &#123;</span><br><span class="line">    <span class="comment">// 最终会调用 get(Context)，最终调用 getApplicationManager()</span></span><br><span class="line">    <span class="keyword">return</span> get(view.getContext().getApplicationContext());</span><br><span class="line">  &#125;</span><br><span class="line">  Preconditions.checkNotNull(view);</span><br><span class="line">  Preconditions.checkNotNull(view.getContext(),</span><br><span class="line">      <span class="string">&quot;Unable to obtain a request manager for a view without a Context&quot;</span>);</span><br><span class="line">  Activity activity = findActivity(view.getContext());</span><br><span class="line">  <span class="comment">// The view might be somewhere else, like a service.</span></span><br><span class="line">  <span class="keyword">if</span> (activity == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> get(view.getContext().getApplicationContext());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (activity <span class="keyword">instanceof</span> FragmentActivity) &#123;</span><br><span class="line">    Fragment fragment = findSupportFragment(view, (FragmentActivity) activity);</span><br><span class="line">    <span class="keyword">return</span> fragment != <span class="keyword">null</span> ? get(fragment) : get(activity);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Standard Fragments.</span></span><br><span class="line">  android.app.Fragment fragment = findFragment(view, activity);</span><br><span class="line">  <span class="keyword">if</span> (fragment == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> get(activity);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> get(fragment);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>get(View) 会取出 View 中的 Context 进行判断，如果 Context 没有关联到 Activity 或 Fragment 或者图片加载动作发生在后台，那么会调用 get(Context)，因为传入的是 Context 是 ApplicationContext，因此最终会调用 getApplicationManager()。如果 View 直接关联到 Activity，那么会调用 get(Activity) 或者 get(FragmentActivity) ，如果是直接关联到 Fragment 便会调用 get(Fragment)。</p>
<p>这样看来，每个 Activity 和 Fragment 都会有一个 RequestManagerFragment（前提是有图片加载动作），而每一个 RequestManagerFragment 都关联着一个 RequestManager。也就是说，每一个 Activity 或者 Fragment 都对应着一个 RequestManager。那么 RequestManager 是如何获取生命周期的呢？上面的 fragmentGet() 中有这样一行代码：</p>
<p>[-&gt;RequestManagerRetriever.java]</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">requestManager =</span><br><span class="line">        factory.build(glide, current.getGlideLifecycle(), current.getRequestManagerTreeNode());</span><br></pre></td></tr></table></figure>

<p>这行代码是赋予 RequestManager 生命周期的核心方法。factory 的实际类型是 GeneratedRequestManagerFactory，current 是 RequestManagerFragment 对象，getGlideLifecycle() 方法返回的是 ActivityFragmentLifecycle 对象，它实现了 Lifecycle 接口。</p>
<p>[-&gt;RequestManagerFragment.java]</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">ActivityFragmentLifecycle <span class="title">getGlideLifecycle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> lifecycle;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ActivityFragmentLifecycle</span> <span class="keyword">implements</span> <span class="title">Lifecycle</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;LifecycleListener&gt; lifecycleListeners =</span><br><span class="line">      Collections.newSetFromMap(<span class="keyword">new</span> WeakHashMap&lt;LifecycleListener, Boolean&gt;());</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> isStarted;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> isDestroyed;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addListener</span><span class="params">(LifecycleListener listener)</span> </span>&#123;</span><br><span class="line">    lifecycleListeners.add(listener);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isDestroyed) &#123;</span><br><span class="line">      listener.onDestroy();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isStarted) &#123;</span><br><span class="line">      listener.onStart();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      listener.onStop();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeListener</span><span class="params">(LifecycleListener listener)</span> </span>&#123;</span><br><span class="line">    lifecycleListeners.remove(listener);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    isStarted = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (LifecycleListener lifecycleListener : Util.getSnapshot(lifecycleListeners)) &#123;</span><br><span class="line">      lifecycleListener.onStart();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">onStop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    isStarted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (LifecycleListener lifecycleListener : Util.getSnapshot(lifecycleListeners)) &#123;</span><br><span class="line">      lifecycleListener.onStop();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    isDestroyed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (LifecycleListener lifecycleListener : Util.getSnapshot(lifecycleListeners)) &#123;</span><br><span class="line">      lifecycleListener.onDestroy();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Lifecycle 是一个管理生命周期监听器的接口。ActivityFragmentLifecycle 在实现接口的基础上增加了三个生命周期方法，它们会遍历所有的 LifecycleListener，调用其相应的生命周期方法。这三个方法主要是用来和 RequestManagerFragment 的生命周期对接：</p>
<p>[-&gt;RequestManagerFragment.java]</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">super</span>.onStart();</span><br><span class="line">  lifecycle.onStart();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">super</span>.onStop();</span><br><span class="line">  lifecycle.onStop();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">super</span>.onDestroy();</span><br><span class="line">  lifecycle.onDestroy();</span><br><span class="line">  unregisterFragmentWithRoot();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此，任何实现 LifecycleListener 的类可通过 addListener() 添加到 ActivityFragmentLifecycle 中从而获得生命周期。那么我们可以猜测 RequestManager 一定实现了 LifecycleListener 接口，事实也的确如此。那么 RequestManager 是如何添加进 ActivityFragmentLifecycle 中的呢？ 答案就在 RequestManager 的构造方法中：</p>
<p>[-&gt;RequestManager.java]</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">RequestManager(</span><br><span class="line">    Glide glide,</span><br><span class="line">    Lifecycle lifecycle,</span><br><span class="line">    RequestManagerTreeNode treeNode,</span><br><span class="line">    RequestTracker requestTracker,</span><br><span class="line">    ConnectivityMonitorFactory factory,</span><br><span class="line">    Context context) &#123;</span><br><span class="line">  <span class="keyword">this</span>.glide = glide;</span><br><span class="line">  <span class="keyword">this</span>.lifecycle = lifecycle;</span><br><span class="line">  <span class="keyword">this</span>.treeNode = treeNode;</span><br><span class="line">  <span class="keyword">this</span>.requestTracker = requestTracker;</span><br><span class="line">  <span class="keyword">this</span>.context = context;</span><br><span class="line">  connectivityMonitor =</span><br><span class="line">      factory.build(</span><br><span class="line">          context.getApplicationContext(),</span><br><span class="line">          <span class="keyword">new</span> RequestManagerConnectivityListener(requestTracker));</span><br><span class="line">  <span class="comment">// If we&#x27;re the application level request manager, we may be created on a background thread.</span></span><br><span class="line">  <span class="comment">// In that case we cannot risk synchronously pausing or resuming requests, so we hack around the</span></span><br><span class="line">  <span class="comment">// issue by delaying adding ourselves as a lifecycle listener by posting to the main thread.</span></span><br><span class="line">  <span class="comment">// This should be entirely safe.</span></span><br><span class="line">  <span class="keyword">if</span> (Util.isOnBackgroundThread()) &#123;</span><br><span class="line">    mainHandler.post(addSelfToLifecycle);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    lifecycle.addListener(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  lifecycle.addListener(connectivityMonitor);</span><br><span class="line">  setRequestOptions(glide.getGlideContext().getDefaultRequestOptions());</span><br><span class="line">  glide.registerRequestManager(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里根据当前线程决定如何将 RequestManager 添加至 Lifecycle 中。如果子线程，通过 post 添加；如果 UI 线程，就直接添加。原因注释里说的很清楚了，如果是 Application 级别的 RequestManager，也就是通过 getApplicationManager() 得到的那个 RequestMangaer，它可能创建于子线程中，那么就有可能冒同步停止和继续请求的风险。其实这段话我也没理解：），等以后上网查资料解决吧。</p>
<p>get() 方法之间的调用关系可能有点复杂，贴上一张图便于理解：</p>
<p><img src="/img/in-post/post_android_open_source_library_glide/post-1.png" alt="get 调用关系"></p>
<p>从上图可以看出几乎在所有的 get() 重载方法中，都会根据特殊情况直接或间接调用 getApplicationManager() 方法，这种特殊情况就是加载动作发生在后台线程或者无法找到关联的 Activity 或者 Fragment，此方法返回的 RequestManager 是没有生命周期的。这样做的目的是什么呢？我们知道生命周期是在 UI 线程接受回调的，让子线程也接受生命周期回调也不是不可以，但是子线程在加载，UI 线程通过生命周期也介入加载过程，相当于两个线程同时操作数据，这会带来线程安全问题，如果做同步，需要同步的地方很多，那么会带来严重的性能问题；而如果没有关联到 Activity 或者 Fragment，无法接受生命周期回调。对于这两种情况，Glide 没有办法，只能任其加载而不受生命周期控制，算是一种折中了吧。getApplicationManager() 的定义如下： </p>
<p>[-&gt;RequestManagerRetriever.java]</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> RequestManager <span class="title">getApplicationManager</span><span class="params">(<span class="meta">@NonNull</span> Context context)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Either an application context or we&#x27;re on a background thread.</span></span><br><span class="line">  <span class="keyword">if</span> (applicationManager == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (applicationManager == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Normally pause/resume is taken care of by the fragment we add to the fragment or</span></span><br><span class="line">        <span class="comment">// activity. However, in this case since the manager attached to the application will not</span></span><br><span class="line">        <span class="comment">// receive lifecycle events, we must force the manager to start resumed using</span></span><br><span class="line">        <span class="comment">// ApplicationLifecycle.</span></span><br><span class="line">        <span class="comment">// TODO(b/27524013): Factor out this Glide.get() call.</span></span><br><span class="line">        Glide glide = Glide.get(context.getApplicationContext());</span><br><span class="line">        applicationManager = factory.build(glide, <span class="keyword">new</span> ApplicationLifecycle(),</span><br><span class="line">                <span class="keyword">new</span> EmptyRequestManagerTreeNode(),</span><br><span class="line">                context.getApplicationContext());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> applicationManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法也有这样一行代码：</p>
<p>[-&gt;RequestManagerRetriever.java]</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">applicationManager = factory.build(glide, <span class="keyword">new</span> ApplicationLifecycle(),</span><br><span class="line">                <span class="keyword">new</span> EmptyRequestManagerTreeNode(),</span><br><span class="line">                context.getApplicationContext());</span><br></pre></td></tr></table></figure>

<p>applicationManager 也是通过 GeneratedRequestManagerFactory#build() 来创建的，但第二个参数和之前的有所不同，这里直接 new 了一个 ApplicationLifecycle() 传进去。ApplicationLifecycle 的定义如下：</p>
<p>[-&gt; ApplicationLifecycle.java]</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ApplicationLifecycle</span> <span class="keyword">implements</span> <span class="title">Lifecycle</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addListener</span><span class="params">(LifecycleListener listener)</span> </span>&#123;</span><br><span class="line">    listener.onStart();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeListener</span><span class="params">(LifecycleListener listener)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Do nothing.</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，这个 ApplicationLifecycle 其实是个假 Lifecycle，因为他根本没有将 LifecycleListener 添加进去，仅仅是立马调用了其 onStart() 方法。由此可见，getApplicationManager() 获取的是没有生命周期的 RequestManager。最后用一张图来总结 RequestManager 的获取过程：</p>
<p><img src="/img/in-post/post_android_open_source_library_glide/post-2.png" alt="RequestManager 的获取过程"></p>
<h3 id="创建-RequestBuilder"><a href="#创建-RequestBuilder" class="headerlink" title="创建 RequestBuilder"></a>创建 RequestBuilder</h3><p>前面我们分析了 Request 的获取过程，既然请求管理器建好了，那么下一步肯定是构建请求了。Glide 使用建造者模式来构建 Request，这个构建者就是 RequestBuilder。建造者模式通常是这样的，通过构建器收集参数，最后调用其 build() 或 create() 方法构建目标对象。那么 RequestBuilder 为了构造一个 Request 会收集哪些参数呢？我们看看它的声明的字段：  </p>
<p>[-&gt;RequestBuilder.java]</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Context context;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> RequestManager requestManager; <span class="comment">// 关联的 RequestManager</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Class&lt;TranscodeType&gt; transcodeClass; <span class="comment">// 图片资源最终要转换成的对象类型</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> RequestOptions defaultRequestOptions; <span class="comment">// 默认的请求选项</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Glide glide;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> GlideContext glideContext; <span class="comment">// Glide 上下文，精简版的 Glide</span></span><br><span class="line"><span class="meta">@NonNull</span> <span class="keyword">protected</span> RequestOptions requestOptions; <span class="comment">// 请求选项</span></span><br><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">private</span> TransitionOptions&lt;?, ? <span class="keyword">super</span> TranscodeType&gt; transitionOptions; <span class="comment">// 渐变动画选项</span></span><br><span class="line"><span class="meta">@Nullable</span> <span class="keyword">private</span> Object model;</span><br><span class="line"><span class="comment">// model may occasionally be null, so to enforce that load() was called, put a boolean rather</span></span><br><span class="line"><span class="comment">// than relying on model not to be null.</span></span><br><span class="line"><span class="meta">@Nullable</span> <span class="keyword">private</span> RequestListener&lt;TranscodeType&gt; requestListener; <span class="comment">// 请求监听器</span></span><br><span class="line"><span class="meta">@Nullable</span> <span class="keyword">private</span> RequestBuilder&lt;TranscodeType&gt; thumbnailBuilder; <span class="comment">// 缩略图</span></span><br><span class="line"><span class="meta">@Nullable</span> <span class="keyword">private</span> RequestBuilder&lt;TranscodeType&gt; errorBuilder; <span class="comment">// 错误图</span></span><br><span class="line"><span class="meta">@Nullable</span> <span class="keyword">private</span> Float thumbSizeMultiplier;<span class="comment">// 缩略图的缩放因子</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> isDefaultTransitionOptionsSet = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> isModelSet;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> isThumbnailBuilt;</span><br></pre></td></tr></table></figure>
<p>我们看下 RequestOptions 这个类，它是请求的附加选项，在发起一个图片请求时，我们可能对它会有一些特殊的要求，此时就可以通过 RequestOptions 来添加这些要求，ReqeustOptions 的定义：</p>
<p>[-&gt;RequestOptions.java]</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestOptions</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNSET = -<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIZE_MULTIPLIER = <span class="number">1</span> &lt;&lt; <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DISK_CACHE_STRATEGY = <span class="number">1</span> &lt;&lt; <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PRIORITY = <span class="number">1</span> &lt;&lt; <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ERROR_PLACEHOLDER = <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ERROR_ID = <span class="number">1</span> &lt;&lt; <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PLACEHOLDER = <span class="number">1</span> &lt;&lt; <span class="number">6</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PLACEHOLDER_ID = <span class="number">1</span> &lt;&lt; <span class="number">7</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> IS_CACHEABLE = <span class="number">1</span> &lt;&lt; <span class="number">8</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OVERRIDE = <span class="number">1</span> &lt;&lt; <span class="number">9</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNATURE = <span class="number">1</span> &lt;&lt; <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TRANSFORMATION = <span class="number">1</span> &lt;&lt; <span class="number">11</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RESOURCE_CLASS = <span class="number">1</span> &lt;&lt; <span class="number">12</span>;</span><br><span class="line">  ......</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> fields;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">float</span> sizeMultiplier = <span class="number">1f</span>;</span><br><span class="line">  <span class="keyword">private</span> DiskCacheStrategy diskCacheStrategy = DiskCacheStrategy.AUTOMATIC;</span><br><span class="line">  <span class="keyword">private</span> Priority priority = Priority.NORMAL;</span><br><span class="line">  <span class="keyword">private</span> Drawable errorPlaceholder;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> errorId;</span><br><span class="line">  <span class="keyword">private</span> Drawable placeholderDrawable;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> placeholderId;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> isCacheable = <span class="keyword">true</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> overrideHeight = RequestOptions.UNSET;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> overrideWidth = RequestOptions.UNSET;</span><br><span class="line">  <span class="keyword">private</span> Key signature = EmptySignature.obtain();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> isTransformationRequired;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> isTransformationAllowed = <span class="keyword">true</span>;</span><br><span class="line">  <span class="keyword">private</span> Drawable fallbackDrawable;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> fallbackId;</span><br><span class="line">  <span class="keyword">private</span> Options options = <span class="keyword">new</span> Options();</span><br><span class="line">  <span class="keyword">private</span> Map&lt;Class&lt;?&gt;, Transformation&lt;?&gt;&gt; transformations = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">  <span class="keyword">private</span> Class&lt;?&gt; resourceClass = Object.class;</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，请求的附加选项包括底盘缓存策略，请求优先级，占位图，兜底图等常见选项，这些选项全部通过标志位来标识是否设立新值，为什么通过标志位来表示？因为很多选项都有默认值，通过判空来判断它们是否设定了新值是行不通的。RequestOptions 是可以合并的，两个 RequestOptions 可以合并成一个 RequestOptions，这个功能由 RequestOptions#apply(RequestOptions) 来实现。例如 A 想合并 B，可以这样： C = A.apply(B) ，结果是 B 中的新值会覆盖 A 中的值，B 中的默认值不会覆盖 A 中的值。</p>
<p>现在我们回头再看看 RequestManager 的 load() 方法：</p>
<p>[-&gt;RequestManager.java]</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> RequestBuilder&lt;Drawable&gt; <span class="title">load</span><span class="params">(<span class="meta">@Nullable</span> Drawable drawable)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> asDrawable().load(drawable);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> RequestBuilder&lt;Drawable&gt; <span class="title">load</span><span class="params">(<span class="meta">@Nullable</span> Bitmap bitmap)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> asDrawable().load(bitmap);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> RequestBuilder&lt;Drawable&gt; <span class="title">load</span><span class="params">(<span class="meta">@Nullable</span> Object model)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> asDrawable().load(model);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> RequestBuilder&lt;Drawable&gt; <span class="title">asDrawable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> as(Drawable.class).transition(<span class="keyword">new</span> DrawableTransitionOptions());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;ResourceType&gt; <span class="function">RequestBuilder&lt;ResourceType&gt; <span class="title">as</span><span class="params">(Class&lt;ResourceType&gt; resourceClass)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> RequestBuilder&lt;&gt;(glide, <span class="keyword">this</span>, resourceClass, context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>as() 方法构建了一个 RequestBuilder 并指明了 resourceClass，这个 resourceClass 就是 RequestBuilder 中的  transcodeClass，表明图片资源最终转换成的对象。 asDrawable() 方法创建了一个 transcodeClass 为 Drawable 的 RequestBuilder，并且指定了 transitionOptions 的值。而 load() 方法最为最外层的方法，首先调用了 asDrawable()，然后调用 RequestBuilder#load() 将 model 传进去。</p>
<p>[-&gt;ReuqestBuilder.java]</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> RequestBuilder&lt;TranscodeType&gt; <span class="title">load</span><span class="params">(<span class="meta">@Nullable</span> Uri uri)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> loadGeneric(uri);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> RequestBuilder&lt;TranscodeType&gt; <span class="title">load</span><span class="params">(<span class="meta">@Nullable</span> File file)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> loadGeneric(file);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> RequestBuilder&lt;TranscodeType&gt; <span class="title">load</span><span class="params">(<span class="meta">@Nullable</span> Drawable drawable)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> loadGeneric(drawable)</span><br><span class="line">      .apply(diskCacheStrategyOf(DiskCacheStrategy.NONE));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> RequestBuilder&lt;TranscodeType&gt; <span class="title">apply</span><span class="params">(<span class="meta">@NonNull</span> RequestOptions requestOptions)</span> </span>&#123;</span><br><span class="line">  Preconditions.checkNotNull(requestOptions);</span><br><span class="line">  <span class="keyword">this</span>.requestOptions = getMutableOptions().apply(requestOptions);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> RequestBuilder&lt;TranscodeType&gt; <span class="title">loadGeneric</span><span class="params">(<span class="meta">@Nullable</span> Object model)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.model = model;</span><br><span class="line">  isModelSet = <span class="keyword">true</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>[-&gt;RequestOptions.java]</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RequestOptions <span class="title">diskCacheStrategyOf</span><span class="params">(<span class="meta">@NonNull</span> DiskCacheStrategy diskCacheStrategy)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> RequestOptions().diskCacheStrategy(diskCacheStrategy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>RequestBuilder 中有很多 load() 方法，上面只列举了一部分。以上三个 load() 方法都会转调 loadGeneric() 方法，第三个 load() 还会合并一个指定了磁盘缓存策略的 RequestOptions。loadGeneric() 做的事很简单，就是给 model 赋值。由此我们可以看出，model 的实际类型有很多种，可以是 Uri，也可以是 Bitmap，还可以是 File 等。</p>
<p>RequestBuilder 的参数收集过程讲完了，下一步就是 Request 的构建过程了。从上面的分析可知，RequestManager#load() 方法返回的既然是 RequestBuilder，那 Request 的构建和执行一定都是在 into() 的调用栈中进行的。</p>
<h3 id="Request-的构建和执行"><a href="#Request-的构建和执行" class="headerlink" title="Request 的构建和执行"></a>Request 的构建和执行</h3><p>万事俱备，只欠东风。现在我们以 into() 为切入点，看看 Request 是如何构建和执行的。into() 定义在 RequestBuilder 中：</p>
<p>[-&gt;RequestBuilder.java]</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;Y extends Target&lt;TranscodeType&gt;&gt; <span class="function">Y <span class="title">into</span><span class="params">(<span class="meta">@NonNull</span> Y target)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> into(target, <span class="comment">/*targetListener=*/</span> <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Synthetic</span> &lt;Y extends Target&lt;TranscodeType&gt;&gt; <span class="function">Y <span class="title">into</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="meta">@NonNull</span> Y target,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="meta">@Nullable</span> RequestListener&lt;TranscodeType&gt; targetListener)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> into(target, targetListener, getMutableOptions());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Target&lt;TranscodeType&gt; <span class="title">into</span><span class="params">(ImageView view)</span> </span>&#123;</span><br><span class="line">  ......</span><br><span class="line">  <span class="keyword">return</span> into(context.buildImageViewTarget(view, transcodeClass), <span class="keyword">null</span>,</span><br><span class="line">        requestOptions);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>into() 有多个重载，但是最终都会调用一个含三个参数的重载方法。第三个 into() 我们很熟悉，我们经常使用它来将加载好的图片资源设置给 ImageView，这个 ImageView 在方法中会被包装成一个 Target 对象，然后传入含三个参数的 into() 重载方法中。Glide 把所有图片资源的目的用途抽象成 Target，这一点很巧妙，因为图片加载库的使用场景有很多，除了可以将它设置给 ImageView，还可以存入磁盘文件，内存，或者其他用途。我们可以看看 Target 的定义：</p>
<p>[-&gt;Target.java]</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Target</span>&lt;<span class="title">R</span>&gt; <span class="keyword">extends</span> <span class="title">LifecycleListener</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">onLoadStarted</span><span class="params">(<span class="meta">@Nullable</span> Drawable placeholder)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">onLoadFailed</span><span class="params">(<span class="meta">@Nullable</span> Drawable errorDrawable)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">onResourceReady</span><span class="params">(<span class="meta">@NonNull</span> R resource, <span class="meta">@Nullable</span> Transition&lt;? <span class="keyword">super</span> R&gt; transition)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">getSize</span><span class="params">(<span class="meta">@NonNull</span> SizeReadyCallback cb)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">removeCallback</span><span class="params">(<span class="meta">@NonNull</span> SizeReadyCallback cb)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setRequest</span><span class="params">(<span class="meta">@Nullable</span> Request request)</span></span>;</span><br><span class="line">  <span class="meta">@Nullable</span></span><br><span class="line">  <span class="function">Request <span class="title">getRequest</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以根据自己的需要实现 Target 接口，从而自定义图片资源的用途。buildImageViewTarget() 返回的是一个 ImageViewTarget 对象，它是一个抽象类，继承自 ViewTarget，有两个子类 BitmapImageViewTarget 和 DrawableImageViewTarget，前者的接收的图片资源类型是 Bitmap，后者是 Drawable。</p>
<p>[-&gt;ImageViewTarget.java]</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLoadStarted</span><span class="params">(<span class="meta">@Nullable</span> Drawable placeholder)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">super</span>.onLoadStarted(placeholder);</span><br><span class="line">  setResourceInternal(<span class="keyword">null</span>);</span><br><span class="line">  setDrawable(placeholder);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLoadFailed</span><span class="params">(<span class="meta">@Nullable</span> Drawable errorDrawable)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">super</span>.onLoadFailed(errorDrawable);</span><br><span class="line">  setResourceInternal(<span class="keyword">null</span>);</span><br><span class="line">  setDrawable(errorDrawable);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLoadCleared</span><span class="params">(<span class="meta">@Nullable</span> Drawable placeholder)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">super</span>.onLoadCleared(placeholder);</span><br><span class="line">  <span class="keyword">if</span> (animatable != <span class="keyword">null</span>) &#123;</span><br><span class="line">    animatable.stop();</span><br><span class="line">  &#125;</span><br><span class="line">  setResourceInternal(<span class="keyword">null</span>);</span><br><span class="line">  setDrawable(placeholder);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResourceReady</span><span class="params">(<span class="meta">@NonNull</span> Z resource, <span class="meta">@Nullable</span> Transition&lt;? <span class="keyword">super</span> Z&gt; transition)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (transition == <span class="keyword">null</span> || !transition.transition(resource, <span class="keyword">this</span>)) &#123;</span><br><span class="line">    setResourceInternal(resource);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    maybeUpdateAnimatable(resource);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setResourceInternal</span><span class="params">(<span class="meta">@Nullable</span> Z resource)</span> </span>&#123;</span><br><span class="line">  setResource(resource);</span><br><span class="line">  maybeUpdateAnimatable(resource);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 因为 ImageView 可接受 Bitmap 和 Drawable 这两种图片资源类型，因此抽象出这个方法供子类实现</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">setResource</span><span class="params">(<span class="meta">@Nullable</span> Z resource)</span></span>;</span><br></pre></td></tr></table></figure>

<p>现在看下 RequestBuilder 含三个参数的 into() 方法：</p>
<p>[-&gt;RequestBuilder.java]</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;Y extends Target&lt;TranscodeType&gt;&gt; <span class="function">Y <span class="title">into</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="meta">@NonNull</span> Y target,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="meta">@Nullable</span> RequestListener&lt;TranscodeType&gt; targetListener,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="meta">@NonNull</span> RequestOptions options)</span> </span>&#123;</span><br><span class="line">  Util.assertMainThread();</span><br><span class="line">  Preconditions.checkNotNull(target);</span><br><span class="line">  <span class="keyword">if</span> (!isModelSet) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;You must call #load() before calling #into()&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  options = options.autoClone();</span><br><span class="line">  Request request = buildRequest(target, targetListener, options);</span><br><span class="line">  Request previous = target.getRequest();</span><br><span class="line">  <span class="keyword">if</span> (request.isEquivalentTo(previous)</span><br><span class="line">      &amp;&amp; !isSkipMemoryCacheWithCompletePreviousRequest(options, previous)) &#123;</span><br><span class="line">    request.recycle();</span><br><span class="line">    <span class="comment">// If the request is completed, beginning again will ensure the result is re-delivered,</span></span><br><span class="line">    <span class="comment">// triggering RequestListeners and Targets. If the request is failed, beginning again will</span></span><br><span class="line">    <span class="comment">// restart the request, giving it another chance to complete. If the request is already</span></span><br><span class="line">    <span class="comment">// running, we can let it continue running without interruption.</span></span><br><span class="line">    <span class="keyword">if</span> (!Preconditions.checkNotNull(previous).isRunning()) &#123;</span><br><span class="line">      <span class="comment">// Use the previous request rather than the new one to allow for optimizations like skipping</span></span><br><span class="line">      <span class="comment">// setting placeholders, tracking and un-tracking Targets, and obtaining View dimensions</span></span><br><span class="line">      <span class="comment">// that are done in the individual Request.</span></span><br><span class="line">      previous.begin();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br><span class="line">  requestManager.clear(target);</span><br><span class="line">  target.setRequest(request); <span class="comment">// 将 target 和 request 关联起来</span></span><br><span class="line">  requestManager.track(target, request); <span class="comment">// 将 target 和 request 添加进 requestManager 进行管理</span></span><br><span class="line">  <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>buildRequest() 创建了一个 Request，之后会判断这个 target 当前关联的 Request 是不是和这个新的 Request 是不是等效的，如果是，并且 isSkipMemoryCacheWithCompletePreviousRequest() 返回 false，便将这个新的 Request 回收掉，避免一个目标上有多个请求。然后判断之前的那个 Request 是不是还在跑，如果没有，那么就启动它，为什么这样做？注释里已经说的很清楚了，就是为了将当前绑定在 target 上的请求再执行一遍，这样请求完成后会将结果重新传递一遍；如果正在跑，没必要重启这个请求，因为请求完成之后会将结果传递回去。对于 isSkipMemoryCacheWithCompletePreviousRequest() 这个方法，其实有必要分析一下，为什么它返回 false 的时候才能将新的 Request 取消，不过目前为止我还没有完全理解，但还是先贴上这个方法供大家自行理解：</p>
<p>[-&gt;RequestBuilder.java]</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// If the caller is using skipMemoryCache and the previous request is finished, calling begin on</span></span><br><span class="line"><span class="comment">// the previous request will complete from memory because it will just use the resource that had</span></span><br><span class="line"><span class="comment">// already been loaded. If the previous request isn&#x27;t complete, we can wait for it to finish</span></span><br><span class="line"><span class="comment">// because the previous request must also be using skipMemoryCache for the requests to be</span></span><br><span class="line"><span class="comment">// equivalent. See #2663 for additional context.</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isSkipMemoryCacheWithCompletePreviousRequest</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    RequestOptions options, Request previous)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> !options.isMemoryCacheable() &amp;&amp; previous.isComplete();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>回到 into() 方法，真正处理加载请求的方法是 RequestManager#track() 方法：</p>
<p>[-&gt;RequestManager.java]</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">track</span><span class="params">(Target&lt;?&gt; target, Request request)</span> </span>&#123;</span><br><span class="line">  targetTracker.track(target);</span><br><span class="line">  requestTracker.runRequest(request);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>RequestManager 中有两个 “追踪器”，一个是 TargetTracker，另一个是 RequestTracker，前者用来管理 target，后者管理 request。由于 TargetTracker 和 Target 都实现了 LifecycleListener 接口，这样生命周期就能从 RequestManager 传到 Target。真正启动请求的方法是 RequestTracker#runRequest() ：</p>
<p>[-&gt;RequestTracker.java]</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runRequest</span><span class="params">(Request request)</span> </span>&#123;</span><br><span class="line">  requests.add(request);</span><br><span class="line">  <span class="keyword">if</span> (!isPaused) &#123;</span><br><span class="line">    request.begin(); <span class="comment">// 执行请求</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    pendingRequests.add(request);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>RequestTracker 首先将 request 加入请求列表 requests 中，这个列表保存的是所有请求；然后判断是否需要暂停加载（受生命周期的控制），如果是，则开始请求，否则将这个请求放入待处理队列 pendingRequests 中。为什么要用一个 pendingRequest 来管理这些待处理请求呢？其实并不是为了将他们储存起来待以后执行，而仅仅是为了让他们不被回收。requests 持有的是 Request 的弱引用，如果请求没有马上执行，这些 Request 仅仅被弱引用持有，那么就有被回收的可能，将他们放入 pendingRequests 中就是为了让他们被强引用持有防止被回收。更详细的解释可以看看这个 <a href="https://github.com/bumptech/glide/issues/346">issue</a>。</p>
<p>Request 是一个接口，它包含多了很多控制方法和状态查询方法。Request 在当前 Glide 版本中只有一个实现者：SingleRequest。SingleRequest 的 begin() 方法如下：</p>
<p>[-&gt;SingleRequest.java]</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">begin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ......</span><br><span class="line">  <span class="keyword">if</span> (Util.isValidDimensions(overrideWidth, overrideHeight)) &#123;</span><br><span class="line">    onSizeReady(overrideWidth, overrideHeight);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    target.getSize(<span class="keyword">this</span>); </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ((status == Status.RUNNING || status == Status.WAITING_FOR_SIZE)</span><br><span class="line">      &amp;&amp; canNotifyStatusChanged()) &#123;</span><br><span class="line">    target.onLoadStarted(getPlaceholderDrawable());</span><br><span class="line">  &#125;</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>begin() 是 Request 的入口方法，它开启了图片请求的处理流程，而整个流程的第一步就是获取期望的图片宽高。第一个 if 语句块，它会判断用户是否显式要求了图片宽高，如果指明了，那么立马执行 onSizeReady()，否则执行 Target#getSize()。onSizeReady() 是 SingleRequest 实现的 SizeReadyCallback 接口中的方法。 </p>
<p>[-&gt;Target.java]</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getSize</span><span class="params">(<span class="meta">@NonNull</span> SizeReadyCallback cb)</span></span>;</span><br></pre></td></tr></table></figure>

<p>getSize() 的作用就是用来获取图片的宽高，获取成功之后就通过 SizeReadyCallback#onSizeRady() 将结果返回。Target 是目标用途的抽象，所以图片的宽高理应由它来指定。比如，对于 ViewTarget 来说，它的 getSize() 返回的就是 View 的宽高。这里我们可能就有疑问了，为什么 getSize() 要设计成异步的？其实答案很简单，对于 View 来说，它的宽高只有在 Activity#onResume() 之后才能获取到，严格来说是 View#layout() 之后才能获取到。请求发起时可能 View 的宽高还获取不到，因此将 getSize() 设计成异步的是理所应当的。现在重点是 onSizeReady() ：</p>
<p>[-&gt;SingleRequest.java]</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">loadStatus = engine.load(</span><br><span class="line">    glideContext,</span><br><span class="line">    model,</span><br><span class="line">    requestOptions.getSignature(),</span><br><span class="line">    <span class="keyword">this</span>.width,</span><br><span class="line">    <span class="keyword">this</span>.height,</span><br><span class="line">    requestOptions.getResourceClass(),</span><br><span class="line">    transcodeClass,</span><br><span class="line">    priority,</span><br><span class="line">    requestOptions.getDiskCacheStrategy(),</span><br><span class="line">    requestOptions.getTransformations(),</span><br><span class="line">    requestOptions.isTransformationRequired(),</span><br><span class="line">    requestOptions.isScaleOnlyOrNoTransform(),</span><br><span class="line">    requestOptions.getOptions(),</span><br><span class="line">    requestOptions.isMemoryCacheable(),</span><br><span class="line">    requestOptions.getUseUnlimitedSourceGeneratorsPool(),</span><br><span class="line">    requestOptions.getUseAnimationPool(),</span><br><span class="line">    requestOptions.getOnlyRetrieveFromCache(),</span><br><span class="line">    <span class="keyword">this</span>);</span><br></pre></td></tr></table></figure>
<p>上面这段代码是 onSizeReady() 的主要逻辑，它调用了 Engine#load()，传入了一些和请求相关的各种参数，这个方法返回的是一个 LoadStatus 对象，关于它我们待会儿再分析。</p>
<p>[-&gt;Engine.java]</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">EngineKey key = keyFactory.buildKey(model, signature, width, height, transformations,</span><br><span class="line">    resourceClass, transcodeClass, options);</span><br><span class="line">EngineResource&lt;?&gt; active = loadFromActiveResources(key, isMemoryCacheable);</span><br><span class="line"><span class="keyword">if</span> (active != <span class="keyword">null</span>) &#123;</span><br><span class="line">  cb.onResourceReady(active, DataSource.MEMORY_CACHE);</span><br><span class="line">  ......</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">EngineResource&lt;?&gt; cached = loadFromCache(key, isMemoryCacheable);</span><br><span class="line"><span class="keyword">if</span> (cached != <span class="keyword">null</span>) &#123;</span><br><span class="line">  cb.onResourceReady(cached, DataSource.MEMORY_CACHE);</span><br><span class="line">  ......</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">EngineJob&lt;?&gt; current = jobs.get(key, onlyRetrieveFromCache);</span><br><span class="line"><span class="keyword">if</span> (current != <span class="keyword">null</span>) &#123;</span><br><span class="line">  current.addCallback(cb);</span><br><span class="line">  ......</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> LoadStatus(cb, current);</span><br><span class="line">&#125;</span><br><span class="line">EngineJob&lt;R&gt; engineJob = engineJobFactory.build(key, isMemoryCacheable,</span><br><span class="line">        useUnlimitedSourceExecutorPool, useAnimationPool, onlyRetrieveFromCache);</span><br><span class="line">DecodeJob&lt;R&gt; decodeJob = decodeJobFactory.build(glideContext, model, key,</span><br><span class="line">        signature, width, height, resourceClass, transcodeClass, priority,</span><br><span class="line">        diskCacheStrategy, transformations, isTransformationRequired,</span><br><span class="line">        isScaleOnlyOrNoTransform, onlyRetrieveFromCache, options, engineJob);</span><br><span class="line">jobs.put(key, engineJob);</span><br><span class="line">engineJob.addCallback(cb);</span><br><span class="line">engineJob.start(decodeJob);</span><br><span class="line">......</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> LoadStatus(cb, engineJob);</span><br></pre></td></tr></table></figure>

<p>Engine#load() 方法的逻辑是：</p>
<ul>
<li>首先构建出标识这个请求的 Key，这个 Key 用来标识一个请求，Key 相同的 Request 是等效的。可以看出这个 Key 有多个参数组成，只要其中一个参数不同，Key 就不同，那么这个 Request 也就是与众不同的；</li>
<li>然后根据 Key 从 activy resource 中取出 EngineResource，EngineResource 是图片资源在内存中对应的对象，如果能找到，就调用 ResourceCallback#onResourceReady() 将获取的资源传回给 SingleRequest；</li>
<li>如果上个步骤获取的 EngineResource 为 null，那么就从根据 Key 从 cache 中获取，如果能获取到，同样将结果回传；</li>
<li>如果上个步骤获取的还是 null，那么在 jobs 中根据 Key 查找对应的 EngineJob。EngineJob 的作用文档中是这样说的：通过添加和移除回调、在加载任务完成时通知回调来管理一次加载。简单点说就是一次加载任务的回调管理器。如果能找到，便将 ResourceCallback 添加进去，然后返回一个 LoadStatus。这样做的目的就是避免重复请求，因为如果多个请求如果是等效的，没有必要为它们去加载多次，而只需要加载结果到来时逐个通知它们一遍就好。</li>
<li>如果找不到对应的 EngineJob，没办法，只能开个的 EngineJob 了。通过 EngineJobFactory#build() 新建一个 EngineJob 紧接着又通过 DecodeJobFactory#build() 新建了一个 DecodeJob 并将 EngineJob 传进去。DecodeJob 对应的是一个加载任务，当完成加载后会通过 EngineJob 这个回调管理器将结果送回到 SingleRequest 中。</li>
</ul>
<p>DecodeJob 承包了真正的加载任务，现在我们就从 Engine#start() 开始来分析一下 DecodeJob：</p>
<p>[-&gt;EngineJob.java]</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(DecodeJob&lt;R&gt; decodeJob)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.decodeJob = decodeJob;</span><br><span class="line">  GlideExecutor executor = decodeJob.willDecodeFromCache()</span><br><span class="line">      ? diskCacheExecutor</span><br><span class="line">      : getActiveSourceExecutor();</span><br><span class="line">  executor.execute(decodeJob);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据需不需要从磁盘中获取资源，选择不同的线程池来执行资源加载任务。从这里可以看出 DecodeJob 实现了 Runnable 接口，因此资源加载逻辑应该全部在它的 run() 方法中：</p>
<p>[-&gt;DecodeJob.java]</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ......</span><br><span class="line">  DataFetcher&lt;?&gt; localFetcher = currentFetcher;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isCancelled) &#123;</span><br><span class="line">      notifyFailed();</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    runWrapped();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// When we&#x27;re encoding we&#x27;ve already notified our callback and it isn&#x27;t safe to do so again.</span></span><br><span class="line">    <span class="keyword">if</span> (stage != Stage.ENCODE) &#123;</span><br><span class="line">      throwables.add(t);</span><br><span class="line">      notifyFailed();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!isCancelled) &#123;</span><br><span class="line">      <span class="keyword">throw</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// Keeping track of the fetcher here and calling cleanup is excessively paranoid, we call</span></span><br><span class="line">    <span class="comment">// close in all cases anyway.</span></span><br><span class="line">    <span class="keyword">if</span> (localFetcher != <span class="keyword">null</span>) &#123;</span><br><span class="line">      localFetcher.cleanup();</span><br><span class="line">    &#125;</span><br><span class="line">    TraceCompat.endSection();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>其执行逻辑是：如果状态为 cancelled，或者任务执行时出现异常，那么就发出任务失败的通知；否则执行 runWrapper() 方法。</p>
<p>[-&gt;DecodeJob.java]</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">runWrapped</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">switch</span> (runReason) &#123;</span><br><span class="line">    <span class="keyword">case</span> INITIALIZE:</span><br><span class="line">      stage = getNextStage(Stage.INITIALIZE);</span><br><span class="line">      currentGenerator = getNextGenerator();</span><br><span class="line">      runGenerators();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SWITCH_TO_SOURCE_SERVICE:</span><br><span class="line">      runGenerators();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> DECODE_DATA:</span><br><span class="line">      decodeFromRetrievedData();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Unrecognized run reason: &quot;</span> + runReason);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>runWrapper() 方法会根据 runReason 的值执行不同的分支。runReason 的初始值是 INITIALIZE，INITIALIZE 这条分支做的事是：</p>
<ul>
<li>通过 getNextStage() 获取下一个 Stage，Stage 用来表明当前的工作阶段；</li>
<li>通过 getNextGenerator() 获取下一个 DataFetcherGenerator，DataFetcherGenerator 顾名思义使用来产生 DataFethcer 的，关于 DataFetcher 及其作用之后会详细分析；</li>
<li>执行 runGenerators()。</li>
</ul>
<p>getNextStage() 的定义如下：</p>
<p>[-&gt;DecodeJob.java]</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Stage <span class="title">getNextStage</span><span class="params">(Stage current)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (current) &#123;</span><br><span class="line">    <span class="keyword">case</span> INITIALIZE:</span><br><span class="line">      <span class="keyword">return</span> diskCacheStrategy.decodeCachedResource()</span><br><span class="line">          ? Stage.RESOURCE_CACHE : getNextStage(Stage.RESOURCE_CACHE);</span><br><span class="line">    <span class="keyword">case</span> RESOURCE_CACHE:</span><br><span class="line">      <span class="keyword">return</span> diskCacheStrategy.decodeCachedData()</span><br><span class="line">          ? Stage.DATA_CACHE : getNextStage(Stage.DATA_CACHE);</span><br><span class="line">    <span class="keyword">case</span> DATA_CACHE:</span><br><span class="line">      <span class="comment">// Skip loading from source if the user opted to only retrieve the resource from cache.</span></span><br><span class="line">      <span class="keyword">return</span> onlyRetrieveFromCache ? Stage.FINISHED : Stage.SOURCE;</span><br><span class="line">    <span class="keyword">case</span> SOURCE:</span><br><span class="line">    <span class="keyword">case</span> FINISHED:</span><br><span class="line">      <span class="keyword">return</span> Stage.FINISHED;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Unrecognized stage: &quot;</span> + current);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法根据当前的 Stage 返回下一个 Stage，它的状态变迁可以用下图来表示:</p>
<p><img src="/img/in-post/post_android_open_source_library_glide/post-3.png" alt="Stage 状态变迁图"></p>
<p>getNextGenerator() 的定义如下：</p>
<p>[-&gt;DecodeJob.java]</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> DataFetcherGenerator <span class="title">getNextGenerator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (stage) &#123;</span><br><span class="line">    <span class="keyword">case</span> RESOURCE_CACHE:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> ResourceCacheGenerator(decodeHelper, <span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">case</span> DATA_CACHE:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> DataCacheGenerator(decodeHelper, <span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">case</span> SOURCE:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> SourceGenerator(decodeHelper, <span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">case</span> FINISHED:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Unrecognized stage: &quot;</span> + stage);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法根据当期的 Stage 返回不同的 DataFetcherGenerator，DataFetcherGenerator 的作用是用注册的 ModelLoader 和 Model 产生 DataFetcher 来加载数据。读到这里大家可能有点难理解，因此，在继续深入下去之前，我们有必要了解下 DecodeJob 加载图片资源的整个过程以及 Model，ModelLoader，DataFetcher 等类的的角色和作用，这样有助于后面的分析和理解。</p>
<p>首先我们了解一下 DecodeJob 加载资源的流程，DecodeJob 加载资源的过程中资源类型的变化可以这样来表示：</p>
<p><strong>Model</strong> =&gt; <strong>Data</strong> =&gt; <strong>Decoded Resource</strong> =&gt; <strong>Transcoded Resource</strong>。 </p>
<ul>
<li>Model 一开始是通过 RequestManager#load() 穿过来的，它的类型可以有很多种，它可以是 String，Uri，Drawable，Bitmap，byte[]等。我们可以把它理解成图片加载过程的初始对象；</li>
<li>Data 是原始的数据流，它一般以二进制的形式存在，例如 InputStream，ByteBuffer，byte[]。但也不绝对是二进制流，它也可以是 Bitmap，Drawble 等资源对象，这样看 Model 传入的初始对象是什么；</li>
<li>Decode Resource 是解码好的图片对象，例如 Bitmap，GitDrawable 等；</li>
<li>Transcoded Resource 是最终期望的图片资源类型，它的类型和 RequestBuilder#as() 接受的类型以及 Target 可接受的类型是保持一致的，也就是说这个类型就是“目标类型”，它的类型可以有很多，比如 Bitmap，Drawable，byte[] 等。</li>
</ul>
<p>如果我们传入的 model 为一个 Uri，而我们的目标类型为 Bitmap 时，Glide 是如何处理的呢？首先，Glide 会将 String（Model） 转换成 InputStream（Data)，再将 InputStream（Data）转换成 Bitmap（Decoded Resource），最后再由 Bitmap（Decoded Resource）到 Bitmap（Transcoded Resource）。其实 Decode Resource 到 Transcoded Resource 资源的类型是一样的，因此 Glide 其实不会做任何事。</p>
<p>同理，如果我们传入的 model 是一个 Bitmap，目标类型也是 Bitmap 类型时，由于资源类型至始至终都没有发生变化，那么 Data，Decoded Resource，Transocded Resource 的类型都是 Bitmap。你会说这有什么意义呢？我们知道整个加载流程发生变化的不仅仅是资源类型，还有资源的尺寸等。我们的确可以直接通过 ImageView#setImageBitmap() 方法将一张 Bitmap 设置给 ImageView，但是忽略 ImageView 的大小而将 Bitmap 以原始尺寸显示是很浪费内存的。通常我们会对 Bitmap 进行压缩，必要的话还需要将压缩后的图片进行缓存，如果不利用 Glide，这将是一件很麻烦的是事，而 Glide 使得这个过程的工作量大大减少。</p>
<p>在加载过程中，资源的类型的变化是由 Glide 中特定的对象来完成的，例如 Model 到 Data 的转化就是 ModelLoader 来完成的，Data 到 Decoded Resource 的转换是由 ResourceDecoder 完成的，Decoded Resource 到 Transcoded Resource 的过程是由 ResourceTranscoder 来完成的。以上三者都只是接口，它们在 Glide 由许许多多的实现类，每个实现类都完成特定的两种资源类型的转换，比如 HttpUrlLoader 是一个 ModelLoader，它完成 Uri（Model） 到 InputStream（Data） 的转换过程。</p>
<p>现在我们来看下 ModelLoader 的定义吧：</p>
<p>[-&gt;ModelLoader.java]</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ModelLoader</span>&lt;<span class="title">Model</span>, <span class="title">Data</span>&gt; </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">LoadData</span>&lt;<span class="title">Data</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Key sourceKey;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> List&lt;Key&gt; alternateKeys;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> DataFetcher&lt;Data&gt; fetcher;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LoadData</span><span class="params">(<span class="meta">@NonNull</span> Key sourceKey, <span class="meta">@NonNull</span> DataFetcher&lt;Data&gt; fetcher)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>(sourceKey, Collections.&lt;Key&gt;emptyList(), fetcher);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LoadData</span><span class="params">(<span class="meta">@NonNull</span> Key sourceKey, <span class="meta">@NonNull</span> List&lt;Key&gt; alternateKeys,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="meta">@NonNull</span> DataFetcher&lt;Data&gt; fetcher)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.sourceKey = Preconditions.checkNotNull(sourceKey);</span><br><span class="line">      <span class="keyword">this</span>.alternateKeys = Preconditions.checkNotNull(alternateKeys);</span><br><span class="line">      <span class="keyword">this</span>.fetcher = Preconditions.checkNotNull(fetcher);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 构造一个 LoadData 对象</span></span><br><span class="line">  <span class="meta">@Nullable</span></span><br><span class="line">  <span class="function">LoadData&lt;Data&gt; <span class="title">buildLoadData</span><span class="params">(<span class="meta">@NonNull</span> Model model, <span class="keyword">int</span> width, <span class="keyword">int</span> height,</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="meta">@NonNull</span> Options options)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 该 ModelLoader 能否处理此 model</span></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">handles</span><span class="params">(<span class="meta">@NonNull</span> Model model)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ModelLoader 有两个方法，它们的作用在代码中已经说明了。LoadData 是 ModelLaoder 的内部类，它的内部有一个 DataFetcher 对象，从名字就能知道它的作用是数据的携带者，它用来对数据实行懒加载。我们看下 DataFetcher 的定义：</p>
<p>[-&gt;DataFetcher.java]</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DataFetcher</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">interface</span> <span class="title">DataCallback</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onDataReady</span><span class="params">(<span class="meta">@Nullable</span> T data)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onLoadFailed</span><span class="params">(<span class="meta">@NonNull</span> Exception e)</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">loadData</span><span class="params">(<span class="meta">@NonNull</span> Priority priority, <span class="meta">@NonNull</span> DataCallback&lt;? <span class="keyword">super</span> T&gt; callback)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">cleanup</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@NonNull</span></span><br><span class="line">  <span class="function">Class&lt;T&gt; <span class="title">getDataClass</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@NonNull</span></span><br><span class="line">  <span class="function">DataSource <span class="title">getDataSource</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>容易知道，它的 loadData() 方法就是用来加载数据的，当数据加载完成后它通过 DataCallback 将结果返回给调用者。现在我们可以理解为什么它对数据的加载被称为懒加载了，因为 ModelLoader 构建出 LoadData 这个过程根本没有发生数据的加载，数据的真正加载是调用 DataFetcher#load() 实现的。</p>
<p>现在我们回到 DecodeJob 中，我们接着分析它的 runGenerators() 方法：</p>
<p>[-&gt;DecodeJob.java]</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">runGenerators</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  currentThread = Thread.currentThread();</span><br><span class="line">  startFetchTime = LogTime.getLogTime();</span><br><span class="line">  <span class="keyword">boolean</span> isStarted = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">while</span> (!isCancelled &amp;&amp; currentGenerator != <span class="keyword">null</span></span><br><span class="line">      &amp;&amp; !(isStarted = currentGenerator.startNext())) &#123;</span><br><span class="line">    stage = getNextStage(stage);</span><br><span class="line">    currentGenerator = getNextGenerator();</span><br><span class="line">    <span class="keyword">if</span> (stage == Stage.SOURCE) &#123;</span><br><span class="line">      reschedule();</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// We&#x27;ve run out of stages and generators, give up.</span></span><br><span class="line">  <span class="keyword">if</span> ((stage == Stage.FINISHED || isCancelled) &amp;&amp; !isStarted) &#123;</span><br><span class="line">    notifyFailed();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Otherwise a generator started a new load and we expect to be called back in</span></span><br><span class="line">  <span class="comment">// onDataFetcherReady.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法的核心逻辑是取出一个 Stage，根据该 Stage 返回相应的 DataFetcherGenerator 并执行其 startNext() 方法，然后再取出下一个 Stage……如此循环。</p>
<p>其中 ResourceCacheGenerator 和 DataCacheGenerator 的资源获取方式都是从磁盘缓存中获取，不同的是，前者是从压缩和变换后的图片缓存中获取，后者是从原始图片数据缓存中获取。而 SourceGenerator 获取资源的方式则是从资源的原始位置获取，比如网络。这三者的工作原理大同小异，这里我们只分析 SourceGenerator#startNext() 方法：</p>
<p>[-&gt;SourceGenerator.java]</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ......</span><br><span class="line">  loadData = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">boolean</span> started = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">while</span> (!started &amp;&amp; hasNextModelLoader()) &#123;</span><br><span class="line">    loadData = helper.getLoadData().get(loadDataListIndex++);</span><br><span class="line">    <span class="keyword">if</span> (loadData != <span class="keyword">null</span></span><br><span class="line">        &amp;&amp; (helper.getDiskCacheStrategy().isDataCacheable(loadData.fetcher.getDataSource())</span><br><span class="line">        || helper.hasLoadPath(loadData.fetcher.getDataClass()))) &#123;</span><br><span class="line">      started = <span class="keyword">true</span>;</span><br><span class="line">      loadData.fetcher.loadData(helper.getPriority(), <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> started;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>helper 是 DecodeHelper 对象，DecodeHelper 是一个帮助类，其实就是把原本属于 DecodeJob 的某些属性和方法抽离出去得到的类，估计是作者重构时新添的类，用来减轻 DecodeJob 的工作。它的 getLoadData() 是什么意思呢？我们根据代码来分析下：</p>
<p>[-&gt;DecodeHelper.java]</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;LoadData&lt;?&gt;&gt; getLoadData() &#123;</span><br><span class="line">  <span class="keyword">if</span> (!isLoadDataSet) &#123;</span><br><span class="line">    isLoadDataSet = <span class="keyword">true</span>;</span><br><span class="line">    loadData.clear();</span><br><span class="line">    List&lt;ModelLoader&lt;Object, ?&gt;&gt; modelLoaders = glideContext.getRegistry().getModelLoaders(model);</span><br><span class="line">    <span class="comment">//noinspection ForLoopReplaceableByForEach to improve perf</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, size = modelLoaders.size(); i &lt; size; i++) &#123;</span><br><span class="line">      ModelLoader&lt;Object, ?&gt; modelLoader = modelLoaders.get(i);</span><br><span class="line">      LoadData&lt;?&gt; current =</span><br><span class="line">          modelLoader.buildLoadData(model, width, height, options);</span><br><span class="line">      <span class="keyword">if</span> (current != <span class="keyword">null</span>) &#123;</span><br><span class="line">        loadData.add(current);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> loadData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法返回的是一个 LoadData 集合，这个集合是如何得到的呢？在 for 循环中，遍历上一步得到的 ModelLoader 列表，逐个调用其 buildLoadData() 方法，将得到的 LoadData 添加到结果中。这些 ModelLoader 是通过 Register#getModelLoader() 得到的，这个方法的内部实现虽然繁琐但是很简单：从 Register 中筛选所有能够处理该 Model 的 ModelLoader。筛选的依据就是 ModelLoader#handles() 的返回值，这点之前已经讲过了。Register 是一个注册中心，它会将所有的 ModelLoader，ResourceDecoder 和 ResourceTranscoder 在 Glide 初始化时注册进去。我们摘取部分代码来看：</p>
<p>[-&gt;Glide.java]</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">registry</span><br><span class="line">        .append(ByteBuffer.class, <span class="keyword">new</span> ByteBufferEncoder())</span><br><span class="line">        .append(InputStream.class, <span class="keyword">new</span> StreamEncoder(arrayPool))</span><br><span class="line">        <span class="comment">/* Bitmaps */</span></span><br><span class="line">        .append(Registry.BUCKET_BITMAP, InputStream.class, Bitmap.class, streamBitmapDecoder)</span><br><span class="line">        .append(Bitmap.class, Bitmap.class, UnitModelLoader.Factory.&lt;Bitmap&gt;getInstance())</span><br><span class="line">        .append(</span><br><span class="line">            Registry.BUCKET_BITMAP, Bitmap.class, Bitmap.class, <span class="keyword">new</span> UnitBitmapDecoder())</span><br><span class="line">        <span class="comment">/* BitmapDrawables */</span></span><br><span class="line">        .append(</span><br><span class="line">            Registry.BUCKET_BITMAP_DRAWABLE,</span><br><span class="line">            ByteBuffer.class,</span><br><span class="line">            BitmapDrawable.class,</span><br><span class="line">            <span class="keyword">new</span> BitmapDrawableDecoder&lt;&gt;(resources, byteBufferBitmapDecoder))</span><br><span class="line">        .append(BitmapDrawable.class, <span class="keyword">new</span> BitmapDrawableEncoder(bitmapPool, bitmapEncoder))</span><br><span class="line">        <span class="comment">/* GIFs */</span></span><br><span class="line">        .append(</span><br><span class="line">            Registry.BUCKET_GIF,</span><br><span class="line">            InputStream.class,</span><br><span class="line">            GifDrawable.class,</span><br><span class="line">            <span class="keyword">new</span> StreamGifDecoder(registry.getImageHeaderParsers(), byteBufferGifDecoder, arrayPool))</span><br><span class="line">        <span class="comment">/* GIF Frames */</span></span><br><span class="line">        .append(</span><br><span class="line">            GifDecoder.class, GifDecoder.class, UnitModelLoader.Factory.&lt;GifDecoder&gt;getInstance())</span><br><span class="line">        <span class="comment">/* Drawables */</span></span><br><span class="line">        .append(Uri.class, Drawable.class, resourceDrawableDecoder)</span><br><span class="line">        .append(</span><br><span class="line">            Uri.class, Bitmap.class, <span class="keyword">new</span> ResourceBitmapDecoder(resourceDrawableDecoder, bitmapPool))</span><br><span class="line">        <span class="comment">/* Files */</span></span><br><span class="line">        .append(File.class, InputStream.class, <span class="keyword">new</span> FileLoader.StreamFactory())</span><br><span class="line">        .append(File.class, File.class, <span class="keyword">new</span> FileDecoder())</span><br><span class="line">        .append(File.class, File.class, UnitModelLoader.Factory.&lt;File&gt;getInstance())</span><br><span class="line">        <span class="comment">/* Models */</span></span><br><span class="line">        .register(<span class="keyword">new</span> InputStreamRewinder.Factory(arrayPool))</span><br><span class="line">        .append(<span class="keyword">int</span>.class, InputStream.class, resourceLoaderStreamFactory)</span><br><span class="line">        .append(<span class="keyword">int</span>.class, Uri.class, resourceLoaderUriFactory)</span><br><span class="line">        .append(String.class, InputStream.class, <span class="keyword">new</span> StringLoader.StreamFactory())</span><br><span class="line">        .append(Uri.class, InputStream.class, <span class="keyword">new</span> HttpUriLoader.Factory())</span><br><span class="line">        .append(Uri.class, File.class, <span class="keyword">new</span> MediaStoreFileLoader.Factory(context))</span><br><span class="line">        .append(<span class="keyword">byte</span>[].class, ByteBuffer.class, <span class="keyword">new</span> ByteArrayLoader.ByteBufferFactory())</span><br><span class="line">        .append(<span class="keyword">byte</span>[].class, InputStream.class, <span class="keyword">new</span> ByteArrayLoader.StreamFactory())</span><br><span class="line">        .append(Uri.class, Uri.class, UnitModelLoader.Factory.&lt;Uri&gt;getInstance())</span><br><span class="line">        .append(Drawable.class, Drawable.class, UnitModelLoader.Factory.&lt;Drawable&gt;getInstance())</span><br><span class="line">        .append(Drawable.class, Drawable.class, <span class="keyword">new</span> UnitDrawableDecoder())</span><br><span class="line">        <span class="comment">/* Transcoders */</span></span><br><span class="line">        .register(</span><br><span class="line">            Bitmap.class,</span><br><span class="line">            BitmapDrawable.class,</span><br><span class="line">            <span class="keyword">new</span> BitmapDrawableTranscoder(resources))</span><br><span class="line">        .register(Bitmap.class, <span class="keyword">byte</span>[].class, bitmapBytesTranscoder)</span><br><span class="line">        .register(</span><br><span class="line">            Drawable.class,</span><br><span class="line">            <span class="keyword">byte</span>[].class,</span><br><span class="line">            <span class="keyword">new</span> DrawableBytesTranscoder(</span><br><span class="line">                bitmapPool, bitmapBytesTranscoder, gifDrawableBytesTranscoder))</span><br><span class="line">        .register(GifDrawable.class, <span class="keyword">byte</span>[].class, gifDrawableBytesTranscoder);</span><br></pre></td></tr></table></figure>

<p>由于代码太长，我只贴了部分注册内容。上面这些代码应该很容易看懂，几乎每个注册方法都会接受两个 Class 类型的对象和一个 ModelLoader 或者 ResourceDecoder 或者 ResourceTranscoder 对象，表示该 ModelLoader 或者 ResourceDecoder 或者 ResourceTranscoder 对象能够实现哪两种资源类型的转换。可以用下图来表示资源的类型变化过程：</p>
<p><img src="/img/in-post/post_android_open_source_library_glide/post-4.png" alt="资源的类型变化过程"></p>
<p>由上图可知，如果无法找到一组 (ModelLoader, ResourceDecoder, ResourceTranscoder)，使得资源类型由 Model 转换到 Transcoded Resource，那么加载便会失败。反之，可能有多组 (ModelLoader, ResourceDecoder, ResourceTranscoder) 能够实现 Model 到 Transcoded Resource 的转换。</p>
<p>现在回到 SourceGenerator#startNext()：</p>
<p>[-&gt;SourceGenerator.java]</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ......</span><br><span class="line">  loadData = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">boolean</span> started = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">while</span> (!started &amp;&amp; hasNextModelLoader()) &#123;</span><br><span class="line">    loadData = helper.getLoadData().get(loadDataListIndex++);</span><br><span class="line">    <span class="keyword">if</span> (loadData != <span class="keyword">null</span></span><br><span class="line">        &amp;&amp; (helper.getDiskCacheStrategy().isDataCacheable(loadData.fetcher.getDataSource())</span><br><span class="line">        || helper.hasLoadPath(loadData.fetcher.getDataClass()))) &#123;</span><br><span class="line">      started = <span class="keyword">true</span>;</span><br><span class="line">      loadData.fetcher.loadData(helper.getPriority(), <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> started;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过前面的分析我们知道，DecodeHelper#getLoadData() 返回的是所有能够处理 Model 对象的 ModelLoader 构建出的 LoadData 的集合。循环体中做的事就是选择第一个满足条件的 LoadData，用它内部的 DataFetcher 对象来加载出 Data。之前在分析 DataFetcher 的时候讲过，它的 loadData() 方法会通过 DataCallback 将 Data 传回调用者。在这里调用者就是 SourceGenerator，它实现了 DataCallback 中的方法：</p>
<p>[-&gt;SourceGenerator.java]</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDataReady</span><span class="params">(Object data)</span> </span>&#123;</span><br><span class="line">  DiskCacheStrategy diskCacheStrategy = helper.getDiskCacheStrategy();</span><br><span class="line">  <span class="keyword">if</span> (data != <span class="keyword">null</span> &amp;&amp; diskCacheStrategy.isDataCacheable(loadData.fetcher.getDataSource())) &#123;</span><br><span class="line">    dataToCache = data;</span><br><span class="line">    <span class="comment">// We might be being called back on someone else&#x27;s thread. Before doing anything, we should</span></span><br><span class="line">    <span class="comment">// reschedule to get back onto Glide&#x27;s thread.</span></span><br><span class="line">    cb.reschedule();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    cb.onDataFetcherReady(loadData.sourceKey, data, loadData.fetcher,</span><br><span class="line">        loadData.fetcher.getDataSource(), originalKey);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLoadFailed</span><span class="params">(<span class="meta">@NonNull</span> Exception e)</span> </span>&#123;</span><br><span class="line">  cb.onDataFetcherFailed(originalKey, e, loadData.fetcher, loadData.fetcher.getDataSource());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们重点分析 onDataReady() 方法，这个方法会根据回调所在的线程选择不同的执行路径，这里我们假设走到了 else 块中，那么 FetcherReadyCallback#onDataFetcherReady() 会得到调用。FetcherReadyCallback 也是一个回调接口，它的是实现者是 DecodeJob。这样一来，Data 便从 SourceGenerator 传到了 DecodeJob 中，我们现在看看 DecodeJob#onDataFethcerReady()：</p>
<p>[-&gt;DecodeJob.java]</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDataFetcherReady</span><span class="params">(Key sourceKey, Object data, DataFetcher&lt;?&gt; fetcher,</span></span></span><br><span class="line"><span class="params"><span class="function">    DataSource dataSource, Key attemptedKey)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.currentSourceKey = sourceKey;</span><br><span class="line">  <span class="keyword">this</span>.currentData = data;</span><br><span class="line">  <span class="keyword">this</span>.currentFetcher = fetcher;</span><br><span class="line">  <span class="keyword">this</span>.currentDataSource = dataSource;</span><br><span class="line">  <span class="keyword">this</span>.currentAttemptingKey = attemptedKey;</span><br><span class="line">  <span class="keyword">if</span> (Thread.currentThread() != currentThread) &#123;</span><br><span class="line">    runReason = RunReason.DECODE_DATA;</span><br><span class="line">    callback.reschedule(<span class="keyword">this</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    TraceCompat.beginSection(<span class="string">&quot;DecodeJob.decodeFromRetrievedData&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      decodeFromRetrievedData();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      TraceCompat.endSection();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里同样会根据回调所在线程的不同执行不同的操作，但是最终都会调用到 decodeFromRetrievedData 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">decodeFromRetrievedData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class="line">    logWithTimeAndKey(<span class="string">&quot;Retrieved data&quot;</span>, startFetchTime,</span><br><span class="line">        <span class="string">&quot;data: &quot;</span> + currentData</span><br><span class="line">        + <span class="string">&quot;, cache key: &quot;</span> + currentSourceKey</span><br><span class="line">        + <span class="string">&quot;, fetcher: &quot;</span> + currentFetcher);</span><br><span class="line">  &#125;</span><br><span class="line">  Resource&lt;R&gt; resource = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    resource = decodeFromData(currentFetcher, currentData, currentDataSource);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (GlideException e) &#123;</span><br><span class="line">    e.setLoggingDetails(currentAttemptingKey, currentDataSource);</span><br><span class="line">    throwables.add(e);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (resource != <span class="keyword">null</span>) &#123;</span><br><span class="line">    notifyEncodeAndRelease(resource, currentDataSource);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    runGenerators();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>decodeFromData() 返回了 Transcoded Resource 类型的的图片资源。这个方法的内部细节即使不去分析我们也能略知一二，无非就是对 Data 使用合适的 ResourceDocoder 和 ResourceTranscoder 进行解码和转码。这个方法的最后调用了 notifyEncodeAndRelease()，这个方法最终会调用 DecodeJob.Callback#onResourceReady() 将最终的资源回传。EncodeJob 实现了该接口并且在构造 DecodeJob 时曾将自身作为参数传入，因此资源会被传入 EncodeJob#onResourceReady() 中。类似的 EncodeJob 又会通过回调将资源进一步传给 SingleRequest 中，SingleRequest 最后通过 Target#onResourceReady() 结果传给了 Target。</p>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>前面我们仅仅是沿着加载这条主线讲解了 Glide 内部原理，为了不使逻辑混乱，很多细节我们都带过了。为了加深对 Glide 的理解，我觉得有些问题还是有必要分析一下。</p>
<h3 id="Glide-是如何暂停加载任务的"><a href="#Glide-是如何暂停加载任务的" class="headerlink" title="Glide 是如何暂停加载任务的"></a>Glide 是如何暂停加载任务的</h3><p>我们知道 Glide 会借助 Activity 或者 Fragment 的生命周期来管理加载，那么具体它是如何再暂停和继续一个正在线程池中运行的加载任务呢？之前在分析 Engine#load() 的时候，对于它的返回值我暂时没讲，现在我们回到 Engine#load() 方法：</p>
<p>[-&gt;Engine.java]</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">EngineKey key = keyFactory.buildKey(model, signature, width, height, transformations,</span><br><span class="line">    resourceClass, transcodeClass, options);</span><br><span class="line">EngineResource&lt;?&gt; active = loadFromActiveResources(key, isMemoryCacheable);</span><br><span class="line"><span class="keyword">if</span> (active != <span class="keyword">null</span>) &#123;</span><br><span class="line">  cb.onResourceReady(active, DataSource.MEMORY_CACHE);</span><br><span class="line">  ......</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">EngineResource&lt;?&gt; cached = loadFromCache(key, isMemoryCacheable);</span><br><span class="line"><span class="keyword">if</span> (cached != <span class="keyword">null</span>) &#123;</span><br><span class="line">  cb.onResourceReady(cached, DataSource.MEMORY_CACHE);</span><br><span class="line">  ......</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">EngineJob&lt;?&gt; current = jobs.get(key, onlyRetrieveFromCache);</span><br><span class="line"><span class="keyword">if</span> (current != <span class="keyword">null</span>) &#123;</span><br><span class="line">  current.addCallback(cb);</span><br><span class="line">  ......</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> LoadStatus(cb, current);</span><br><span class="line">&#125;</span><br><span class="line">EngineJob&lt;R&gt; engineJob = engineJobFactory.build(key, isMemoryCacheable,</span><br><span class="line">        useUnlimitedSourceExecutorPool, useAnimationPool, onlyRetrieveFromCache);</span><br><span class="line">DecodeJob&lt;R&gt; decodeJob = decodeJobFactory.build(glideContext, model, key,</span><br><span class="line">        signature, width, height, resourceClass, transcodeClass, priority,</span><br><span class="line">        diskCacheStrategy, transformations, isTransformationRequired,</span><br><span class="line">        isScaleOnlyOrNoTransform, onlyRetrieveFromCache, options, engineJob);</span><br><span class="line">jobs.put(key, engineJob);</span><br><span class="line">engineJob.addCallback(cb);</span><br><span class="line">engineJob.start(decodeJob);</span><br><span class="line">......</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> LoadStatus(cb, engineJob);</span><br></pre></td></tr></table></figure>
<p>我们知道它的返回值是 LoadStatus 对象，这个类的定义如下：</p>
<p>[-&gt;Engine.java]</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LoadStatus</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> EngineJob&lt;?&gt; engineJob;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ResourceCallback cb;</span><br><span class="line">  LoadStatus(ResourceCallback cb, EngineJob&lt;?&gt; engineJob) &#123;</span><br><span class="line">    <span class="keyword">this</span>.cb = cb;</span><br><span class="line">    <span class="keyword">this</span>.engineJob = engineJob;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    engineJob.removeCallback(cb);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很简单，仅仅是封装了 EngineJob 和 ResourceCallback 两个对象。注意到他还有一个 cancel() 方法，这个方法的作用我想大家猜也能猜到，它是用来取消加载的。那么这个方法什么时候会调用呢？我们得回到 SingleRequest 中去寻找答案，因为 Engine#load() 是在 SingleRequest 中调用的，LoadStatus 对象肯定是要返回给 SingleRequest 的。</p>
<p>[-&gt;SingleRequest.java]</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">loadStatus = engine.load(...);</span><br></pre></td></tr></table></figure>

<p>SingleRequest 将返回的 LoadStatus 保存在了 loadStatus 中，现在我们看看 SingleRequest 的 pause() 方法，这个方法会在 RequestTracker#pauseRequests() 中调用，而 RequestTracker#pauseRequests() 会被 RequestManager#onStop() 触发：</p>
<p>[-&gt;SingleRequest.java]</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  clear();</span><br><span class="line">  status = Status.PAUSED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ......</span><br><span class="line">  <span class="keyword">if</span> (status == Status.CLEARED) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  cancel();</span><br><span class="line">  ......</span><br><span class="line">  status = Status.CLEARED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  assertNotCallingCallbacks();</span><br><span class="line">  stateVerifier.throwIfRecycled();</span><br><span class="line">  target.removeCallback(<span class="keyword">this</span>);</span><br><span class="line">  status = Status.CANCELLED;</span><br><span class="line">  <span class="keyword">if</span> (loadStatus != <span class="keyword">null</span>) &#123;</span><br><span class="line">    loadStatus.cancel();</span><br><span class="line">    loadStatus = <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>pause() 方法最后会导致 loadStatus 的 cancel() 方法被调用，现在我们从 LoadStatus#cancel() 方法往下看，为什么 cancel() 就能将一个正在运行的加载任务给取消掉呢？LoadStatus#cancel() 只是简单调用了 EngineJob#removeCallback()：</p>
<p>[-&gt;EngineJob.java]</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">removeCallback</span><span class="params">(ResourceCallback cb)</span> </span>&#123;</span><br><span class="line">  Util.assertMainThread();</span><br><span class="line">  stateVerifier.throwIfRecycled();</span><br><span class="line">  <span class="keyword">if</span> (hasResource || hasLoadFailed) &#123;</span><br><span class="line">    addIgnoredCallback(cb);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    cbs.remove(cb);</span><br><span class="line">    <span class="keyword">if</span> (cbs.isEmpty()) &#123;</span><br><span class="line">      cancel();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法的意图很明了，假设加载还未完成的时候取消了加载，那么便会执行 else 中的代码块，从回调列表中删除该 ResourceCallback，但是移除还不够，因为移除回调仅仅是让 SingleRequest 接收不到最终的结果，我们还必须停止加载任务以节省资源。接下来会继续判断回调列表是否为空，如果为空就调用 cancel() 方法，这个方法就是用来取消加载任务的。这样看来，单单取消一个加载请求并不一定会导致这个加载任务的取消，这很容易理解，因为可能还有其他的请求依赖这个任务的执行。现在看看 EngineJob#cancel() 方法：</p>
<p>[-&gt;Engine.java]</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (hasLoadFailed || hasResource || isCancelled) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  isCancelled = <span class="keyword">true</span>;</span><br><span class="line">  decodeJob.cancel();</span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> Consider trying to remove jobs that have never been run before from executor queues.</span></span><br><span class="line">  <span class="comment">// Removing jobs that have run before can break things. See #1996.</span></span><br><span class="line">  listener.onEngineJobCancelled(<span class="keyword">this</span>, key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  isCancelled = <span class="keyword">true</span>;</span><br><span class="line">  DataFetcherGenerator local = currentGenerator;</span><br><span class="line">  <span class="keyword">if</span> (local != <span class="keyword">null</span>) &#123;</span><br><span class="line">    local.cancel();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法调用了 DecodeJob#cancel()，DecodeJob#cancel() 做了两件事，一是设置 isCancelled 为 true，二是停止当前 DataFetcherGenerator 中的任务。isCancelled 是一个标志，那么它对加载任务有什么影响呢？影响主要有两处，一个 DecodeJob#run()，另一个是 DecodeJob#runGenerators()。isCancelled==true 会导致前者发出加载失败的通知，导致后者停止运行后续的 DataFetcherGenerator 并发出加载失败的通知。加载失败的通知最终会传到 EngineJob 中，使得 EngineJob 执行资源的释放工作。</p>
<p>有一个细节不知大家发现没有，DecodeJob 是被投入线程中运行的，也就是说 SingleRequest 和 DecodeJob 是在不同的线程中运行的。isCancelled 的改变是在 SingleRequest 的线程中进行的，而 DecodeJob 读取 isCancelled 的值是在 DecodeJob 的线程中发生的。那么这很容易发生一个问题，就是线程感知问题。那么 Glide 是如何解决这一问题的呢？我们看看 isCancelled 在 DecodeJob 中的定义：</p>
<p>[-&gt;DecodeJob.java]</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> isCancelled;</span><br></pre></td></tr></table></figure>
<p>Glide 给 isCancelled 加了 volatile 关键字，这样保证了，SingleRequest 线程对 isCancelled 的改变能够及时被 DecodeJob 线程感知。同样的，currentGenerator 在定义时也使用了这个关键字，目的都是一样的。如果大家对于 volatile 关键字还不理解，可以到网上查阅相关资料，因为一时半会儿是解释不清的，我当初为了理解这个关键字花了不少时间。</p>
<h3 id="ModelLoader-的内部细节"><a href="#ModelLoader-的内部细节" class="headerlink" title="ModelLoader 的内部细节"></a>ModelLoader 的内部细节</h3><p>ModelLoader 的子类有很多，Glide 会根据 model 的类型决定使用哪种 ModelLoader。现假设 model 为 http 协议的 url 的话，Glide 最终就会用到 HttpGlideUrlLoader 实现 Model 到 Data 的转换。</p>
<p>[-&gt;HttpGlideUrlLoader]</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpGlideUrlLoader</span> <span class="keyword">implements</span> <span class="title">ModelLoader</span>&lt;<span class="title">GlideUrl</span>, <span class="title">InputStream</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Option&lt;Integer&gt; TIMEOUT = Option.memory(</span><br><span class="line">      <span class="string">&quot;com.bumptech.glide.load.model.stream.HttpGlideUrlLoader.Timeout&quot;</span>, <span class="number">2500</span>);</span><br><span class="line">  <span class="meta">@Nullable</span> <span class="keyword">private</span> <span class="keyword">final</span> ModelCache&lt;GlideUrl, GlideUrl&gt; modelCache;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">HttpGlideUrlLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">HttpGlideUrlLoader</span><span class="params">(<span class="meta">@Nullable</span> ModelCache&lt;GlideUrl, GlideUrl&gt; modelCache)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.modelCache = modelCache;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> LoadData&lt;InputStream&gt; <span class="title">buildLoadData</span><span class="params">(<span class="meta">@NonNull</span> GlideUrl model, <span class="keyword">int</span> width, <span class="keyword">int</span> height,</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="meta">@NonNull</span> Options options)</span> </span>&#123;</span><br><span class="line">    GlideUrl url = model;</span><br><span class="line">    <span class="keyword">if</span> (modelCache != <span class="keyword">null</span>) &#123;</span><br><span class="line">      url = modelCache.get(model, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">      <span class="keyword">if</span> (url == <span class="keyword">null</span>) &#123;</span><br><span class="line">        modelCache.put(model, <span class="number">0</span>, <span class="number">0</span>, model);</span><br><span class="line">        url = model;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> timeout = options.get(TIMEOUT);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> LoadData&lt;&gt;(url, <span class="keyword">new</span> HttpUrlFetcher(url, timeout));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">handles</span><span class="params">(<span class="meta">@NonNull</span> GlideUrl model)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span> <span class="keyword">implements</span> <span class="title">ModelLoaderFactory</span>&lt;<span class="title">GlideUrl</span>, <span class="title">InputStream</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ModelCache&lt;GlideUrl, GlideUrl&gt; modelCache = <span class="keyword">new</span> ModelCache&lt;&gt;(<span class="number">500</span>);</span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelLoader&lt;GlideUrl, InputStream&gt; <span class="title">build</span><span class="params">(MultiModelLoaderFactory multiFactory)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> HttpGlideUrlLoader(modelCache);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">teardown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// Do nothing.</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重点是 HttpUrlFethcer，它的 loadData() 方法会调用 loadDataWithRedirects()：</p>
<p>[-&gt;HttpUrlFetcher.java]</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> InputStream <span class="title">loadDataWithRedirects</span><span class="params">(URL url, <span class="keyword">int</span> redirects, URL lastUrl,</span></span></span><br><span class="line"><span class="params"><span class="function">    Map&lt;String, String&gt; headers)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  .....</span><br><span class="line">  urlConnection = connectionFactory.build(url);</span><br><span class="line">  <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; headerEntry : headers.entrySet()) &#123;</span><br><span class="line">    urlConnection.addRequestProperty(headerEntry.getKey(), headerEntry.getValue());</span><br><span class="line">  &#125;</span><br><span class="line">  urlConnection.setConnectTimeout(timeout);</span><br><span class="line">  urlConnection.setReadTimeout(timeout);</span><br><span class="line">  urlConnection.setUseCaches(<span class="keyword">false</span>);</span><br><span class="line">  urlConnection.setDoInput(<span class="keyword">true</span>);</span><br><span class="line">  ......</span><br><span class="line">  urlConnection.setInstanceFollowRedirects(<span class="keyword">false</span>);</span><br><span class="line">  <span class="comment">// Connect explicitly to avoid errors in decoders if connection fails.</span></span><br><span class="line">  urlConnection.connect();</span><br><span class="line">  <span class="keyword">if</span> (isCancelled) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">int</span> statusCode = urlConnection.getResponseCode();</span><br><span class="line">  <span class="keyword">if</span> (statusCode / <span class="number">100</span> == <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> getStreamForSuccessfulRequest(urlConnection);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (statusCode / <span class="number">100</span> == <span class="number">3</span>) &#123;</span><br><span class="line">    String redirectUrlString = urlConnection.getHeaderField(<span class="string">&quot;Location&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (TextUtils.isEmpty(redirectUrlString)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> HttpException(<span class="string">&quot;Received empty or null redirect url&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    URL redirectUrl = <span class="keyword">new</span> URL(url, redirectUrlString);</span><br><span class="line">    <span class="keyword">return</span> loadDataWithRedirects(redirectUrl, redirects + <span class="number">1</span>, url, headers);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (statusCode == -<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> HttpException(statusCode);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> HttpException(urlConnection.getResponseMessage(), statusCode);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里就是 Glide 和网络交互的地方，Glide 通过 HttpUrlConnection 进行网络连接，并且对可能存在的重定向情况进行了处理，HttpUrlFetcher 最终会将获取到的 InputStream 作为 Data 返回。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上便是 Glide 的加载流程，它内部的运作实在是太复杂了，但正是这种复杂的内部实现使得 Glide 的可扩展型得到增强。比如我们可以自定义磁盘缓存策略，自定义 ModelLoader 以实现 Model 到 Data 的转换，也可以自定义 ResourceDecoder 和 ResourceTranscoder 来实现资源的解码和转码。最后，我们用一张图来总结整个加载过程：</p>
<p><img src="/img/in-post/post_android_open_source_library_glide/post-5.png" alt="Glide 数据转换流程图"></p>
]]></content>
      <tags>
        <tag>Android</tag>
        <tag>开源库</tag>
        <tag>Glide</tag>
      </tags>
  </entry>
  <entry>
    <title>View 的焦点机制</title>
    <url>/2018/04/06/2018-04-06-android-focus/</url>
    <content><![CDATA[<h1 id="View-的焦点机制"><a href="#View-的焦点机制" class="headerlink" title="View 的焦点机制"></a>View 的焦点机制</h1><p><strong>约定：文章中的 View 有时是指狭义的 View.class，有时指的是 View.class 和 ViewGruop.class 的统称，具体含义根据上下文而定</strong>。</p>
<h2 id="和焦点相关的-xml-属性"><a href="#和焦点相关的-xml-属性" class="headerlink" title="和焦点相关的 xml 属性"></a>和焦点相关的 xml 属性</h2><p>在 xml 中，有两个比较重要的属性和焦点有关，它们是 focusable 和 focusableInTouchMode。前者决定这个 View 是否可获取焦点，如果它的值为 false，那么它就和焦点无缘了；后者决定这个 View 在触屏模式下是否可获取焦点，如果它的值为 false，那么即使 focusable 的值为 true，在触屏模式下它也无法获取焦点。比如 Button，如果我们通过外接键盘进行操作，我们会发现 Button 是可以获得焦点的，但是在触屏模式下，Button 是不可获取焦点的。所以我们可以知道 Button 的 focusable 属性默认为 true，而 focusableInTouchMode 属性为 false。</p>
<span id="more"></span>

<p>一个 View 能够获取焦点不代表它拥有焦点，因此，即使你在 xml 中指定这两个属性为 true，在窗口显示时这个 View 也不一定能立马获取焦点。因为窗口上还存在其他能够获取焦点的 View，例如 EditText，它的这两个属性的默认值都为 true。虽然一个界面上可以有多个 View 拥有获得焦点的能力，但是每个时刻只有一个 View 能够真正的获取焦点。</p>
<p>除了上面两个属性外，还有一些和焦点转移相关的属性，比如 nextFocusUp，nextFocusDown，nextFocusFoward 等。当我们通过外接键盘进行操作时，我们有时需要通过上下左右来控制焦点，nextFocusUp，nextFocusDown 等就是用来指明下一个焦点将转移到哪个视图上。当我们填写表单时，点击回车键可以将焦点转移到下一个 EditText 上，这时候我们就可以通过 nextFocusFoward 来指定这个 EditText。你会发现就算我们不指明这些属性系统都能够将焦点转移到合适的视图上，这是因为系统会通过计算帮你找到下一个能够获取焦点的最佳视图。关于系统的焦点转移算法可以参考 FocusFinder 这个类。</p>
<h2 id="和焦点相关的方法"><a href="#和焦点相关的方法" class="headerlink" title="和焦点相关的方法"></a>和焦点相关的方法</h2><p>和焦点相关的方法主要有 hasFocus()，isFocused()，requestFocus()，unFocused()，clearFocus()，setFocusable() 和 setFocusableInTouchMode()。最后两个方法对应的就是 xml 中的那两个属性，我们主要讲下前面几个方法。</p>
<h3 id="hasFocus"><a href="#hasFocus" class="headerlink" title="hasFocus"></a>hasFocus</h3><p>首先是 hasFocus() 方法，它在 View 和 ViewGroup 中的定义分别如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// View.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasFocus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (mPrivateFlags &amp; PFLAG_FOCUSED) != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ViewGroup.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasFocus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (mPrivateFlags &amp; PFLAG_FOCUSED) != <span class="number">0</span> || mFocused != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>PFLAG_FOCUSED 这个标志位用来标识这个 View 是否具有焦点，mFocused 是 ViewGroup 特有的变量，它用记录自身具有焦点或者后代具有焦点的子 View，如果不存在这样的子 View， mFocus 的值就为 null。通过对比可以发现，hasFocus() 在 View 中的含义是这个 View 是否具有焦点，在 ViewGroup 中的含义是该 ViewGroup 是否具有焦点或者它的后代是否有焦点。</p>
<h3 id="isFocused"><a href="#isFocused" class="headerlink" title="isFocused"></a>isFocused</h3><p>isFocused() 只在 View 中有定义，其定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFocused</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (mPrivateFlags &amp; PFLAG_FOCUSED) != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法的和 hasFocus() 有点相似，不过它在 View 和 ViewGroup 中的含义都是一样的，表示这个 View 本身是否具有焦点。</p>
<h3 id="requestFocus"><a href="#requestFocus" class="headerlink" title="requestFocus"></a>requestFocus</h3><p>requestFocus() 在 View 中的定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">requestFocus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> requestFocus(View.FOCUS_DOWN);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">requestFocus</span><span class="params">(<span class="keyword">int</span> direction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> requestFocus(direction, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">requestFocus</span><span class="params">(<span class="keyword">int</span> direction, Rect previouslyFocusedRect)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> requestFocusNoSearch(direction, previouslyFocusedRect);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">requestFocusNoSearch</span><span class="params">(<span class="keyword">int</span> direction, Rect previouslyFocusedRect)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// need to be focusable</span></span><br><span class="line">    <span class="keyword">if</span> ((mViewFlags &amp; FOCUSABLE) != FOCUSABLE</span><br><span class="line">            || (mViewFlags &amp; VISIBILITY_MASK) != VISIBLE) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// need to be focusable in touch mode if in touch mode</span></span><br><span class="line">    <span class="keyword">if</span> (isInTouchMode() &amp;&amp;</span><br><span class="line">        (FOCUSABLE_IN_TOUCH_MODE != (mViewFlags &amp; FOCUSABLE_IN_TOUCH_MODE))) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// need to not have any parents blocking us</span></span><br><span class="line">    <span class="keyword">if</span> (hasAncestorThatBlocksDescendantFocus()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    handleFocusGainInternal(direction, previouslyFocusedRect);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>对于 View 来说，requestFocus() 的返回值的含义是这个 View 是否成功获取了焦点。从上面的代码可知，如果这个 View 不可获取焦点，或者这个 View 不可见，或者这个 View 在触屏模式下不可获取焦点，那么这个方法返回 false，也就是说这个 View 获取不了焦点；否则调用 handleFocusGainInternal() 方法之后返回 true。由此在可见 handleFocusGainInternal() 方法中，View 成功获取了焦点。</p>
<p>requestFocus() 方法在 ViewGroup 中的定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">requestFocus</span><span class="params">(<span class="keyword">int</span> direction, Rect previouslyFocusedRect)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (DBG) &#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span> + <span class="string">&quot; ViewGroup.requestFocus direction=&quot;</span></span><br><span class="line">                + direction);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> descendantFocusability = getDescendantFocusability();</span><br><span class="line">    <span class="keyword">switch</span> (descendantFocusability) &#123;</span><br><span class="line">        <span class="keyword">case</span> FOCUS_BLOCK_DESCENDANTS:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.requestFocus(direction, previouslyFocusedRect);</span><br><span class="line">        <span class="keyword">case</span> FOCUS_BEFORE_DESCENDANTS: &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> took = <span class="keyword">super</span>.requestFocus(direction, previouslyFocusedRect);</span><br><span class="line">            <span class="keyword">return</span> took ? took : onRequestFocusInDescendants(direction, previouslyFocusedRect);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> FOCUS_AFTER_DESCENDANTS: &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> took = onRequestFocusInDescendants(direction, previouslyFocusedRect);</span><br><span class="line">            <span class="keyword">return</span> took ? took : <span class="keyword">super</span>.requestFocus(direction, previouslyFocusedRect);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;descendant focusability must be &quot;</span></span><br><span class="line">                    + <span class="string">&quot;one of FOCUS_BEFORE_DESCENDANTS, FOCUS_AFTER_DESCENDANTS, FOCUS_BLOCK_DESCENDANTS &quot;</span></span><br><span class="line">                    + <span class="string">&quot;but is &quot;</span> + descendantFocusability);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ViewGroup 覆盖了 View 的 requestFocus() 方法，它会根据 descendantFocusability 的值的不同进行不同的处理，descendantFocusability 有三个可能的值：第一个是 FOCUS_BLOCK_DESCENDANTS，它的意思是对焦点进行拦截，不给子 View 进行请求焦点的机会，而是自己请求；第二个是 FOCUS_BEFORE_DESCENDANTS，让自己先去请求焦点，如果没能成功获得焦点才让子 View 去请求焦点；第三个是 FOCUS_AFTER_DESCENDANTS，让子 View 先去请求焦点，如果子 View 没能成功请求到焦点才由自己请求。ViewGruop 的这个属性的默认值为 FOCUS_BEFORE_DESCENDANTS。</p>
<p>当 descendantFocusability 为 FOCUS_BLOCK_DESCENDANTS 时，通过调用父类 View 的 requestFocus() 方法执行为自己请求焦点的逻辑；当值为 FOCUS_BEFORE_DESCENDANTS 时，先为自己请求焦点，如果未能成功，那么再调用 onRequestFocusInDescendants() 方法，这个方法从名字就能知道是为子 View 请求焦点，或者说是把请求焦点的任务交给了后代。因此，对于 ViewGroup 来说，这个方法的返回值和 View 有点不同：如果返回 true，说明这个 ViewGroup 获取了焦点或者它的某个后代成功地获取了焦点；否则，这个 ViewGroup 未能成功获取焦点并且它的子 View 也未能成功获取焦点。</p>
<p>现在我们看下 onRequestFocusInDescendants() 的定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">onRequestFocusInDescendants</span><span class="params">(<span class="keyword">int</span> direction,</span></span></span><br><span class="line"><span class="params"><span class="function">        Rect previouslyFocusedRect)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index;</span><br><span class="line">    <span class="keyword">int</span> increment;</span><br><span class="line">    <span class="keyword">int</span> end;</span><br><span class="line">    <span class="keyword">int</span> count = mChildrenCount;</span><br><span class="line">    <span class="keyword">if</span> ((direction &amp; FOCUS_FORWARD) != <span class="number">0</span>) &#123;</span><br><span class="line">        index = <span class="number">0</span>;</span><br><span class="line">        increment = <span class="number">1</span>;</span><br><span class="line">        end = count;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        index = count - <span class="number">1</span>;</span><br><span class="line">        increment = -<span class="number">1</span>;</span><br><span class="line">        end = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> View[] children = mChildren;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i != end; i += increment) &#123;</span><br><span class="line">        View child = children[i];</span><br><span class="line">        <span class="keyword">if</span> ((child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE) &#123;</span><br><span class="line">            <span class="keyword">if</span> (child.requestFocus(direction, previouslyFocusedRect)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法会遍历所有的子 View，寻找第一个自身或者后代能够成功获取焦点的 View，如果找到了，停止后续的遍历并返回 true；如果不存在这样的 View，返回 false。</p>
<p>从上面的分析可知，requestFocus() 方法不保证一定能获取焦点，还要看该 View 或者 ViewGroup 是否具有获取焦点的能力。对于 View 来说，要想在触屏模式下拥有获取焦点的能力，首先要可见，其次要保证自己的 focusable 和 focusableInTouchMode 这两个属性的值为 true；而对于 ViewGroup 来说，这种能力除了上面说的这些点之外，还要保证在 FOCUS_AFTER_DESCENDANTS 模式下，后代没有成功获取焦点。</p>
<h3 id="unFocus"><a href="#unFocus" class="headerlink" title="unFocus"></a>unFocus</h3><p>这个方法是内部方法，应用程序不能直接调用，它在 View 和 ViewGroup 中有不同的定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// View.java</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unFocus</span><span class="params">(View focused)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (DBG) &#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span> + <span class="string">&quot; unFocus()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    clearFocusInternal(focused, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clearFocusInternal</span><span class="params">(View focused, <span class="keyword">boolean</span> propagate, <span class="keyword">boolean</span> refocus)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((mPrivateFlags &amp; PFLAG_FOCUSED) != <span class="number">0</span>) &#123;</span><br><span class="line">        mPrivateFlags &amp;= ~PFLAG_FOCUSED;</span><br><span class="line">        <span class="keyword">if</span> (propagate &amp;&amp; mParent != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mParent.clearChildFocus(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        onFocusChanged(<span class="keyword">false</span>, <span class="number">0</span>, <span class="keyword">null</span>);</span><br><span class="line">        refreshDrawableState();</span><br><span class="line">        <span class="keyword">if</span> (propagate &amp;&amp; (!refocus || !rootViewRequestFocus())) &#123;</span><br><span class="line">            notifyGlobalFocusCleared(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ViewGroup.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unFocus</span><span class="params">(View focused)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (DBG) &#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span> + <span class="string">&quot; unFocus()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mFocused == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>.unFocus(focused);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mFocused.unFocus(focused);</span><br><span class="line">        mFocused = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于 View 来说，这个方法仅仅是调用了 clearFocusInternal() 方法，最终达到的效果是清除了 PFLAG_FOCUSED 这个标志位，也就是清除了自身的焦点。而对于 ViewGroup 来说，如果自己的 mFocused  变量为 null 的话，就调用父类 View 的 unFoucs() 方法，执行取消自身焦点的逻辑；否则，调用 mFocused 指向的那个 View 的 unFocus() 方法，并且将 mFocused 置为 null。结合 mFocused 的含义来看，对于 ViewGroup 来说，这个方法达到的效果就是：如果自身有焦点（自身具有焦点的 ViewGroup 的 mFocused 值为 nul），那么将自身的焦点清除；否则通过递归调用将焦点路径（关于焦点路径在后面会有介绍）上从该节点开始的所有后续中间节点的 mFocused 置为 null，并将焦点路径的终止节点（即具有焦点的那个 View）的焦点清除。</p>
<h3 id="clearFocus"><a href="#clearFocus" class="headerlink" title="clearFocus"></a>clearFocus</h3><p>这个方法只在 View 中有定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clearFocus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (DBG) &#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span> + <span class="string">&quot; clearFocus()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    clearFocusInternal(<span class="keyword">null</span>, <span class="keyword">true</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它也会调用 clearFocusInternal() 方法，只不过传入的参数和 unFocus() 中的不同。其作用是如果此 View 有焦点的话，清除自身的焦点并将焦点路径删除。</p>
<h2 id="焦点路径"><a href="#焦点路径" class="headerlink" title="焦点路径"></a>焦点路径</h2><p>我们知道，对于一个窗口来说，其内部所有的 View 都是通过树的形式来组织的。每一个 View 都是这棵树的一个节点，DecorView 是这棵树的根节点，其他 ViewGroup 是这棵树的中间节点，View 是这棵树的子节点。前面说了，一个窗口中只能有一个 View 获取焦点，我们可以把从根节点到这个获取焦点的节点路径称之为焦点路径。很显然，焦点路径的起始节点是根节点，中间节点是各种类型的 ViewGroup，终止节点是那个拥有焦点的 View。</p>
<p>在每次重新确定焦点视图后，系统都会建立一条这样一条焦点路径。系统是怎样标识这条路径的呢？就是前面讲到的 mFocused 变量。mFocused  的含义之前说了，指向的是这个 ViewGroup 的自身具有焦点或者后代具有焦点的子 View。而中间节点和根节点都是 ViewGroup 的子类，它们都持有 mFocused 变量，因此从根节点开始，通过 mFocused 变量可以到达最终拥有焦点的那个节点。因为一个窗口中只有一个焦点视图，因此焦路径也只有一条，而焦点视图是会发生变化的，所以可以推测，系统在建立新的焦点路径时，会将原来的那条焦点路径删除。</p>
<p>现在我们来分析系统建立和删除焦点路径的过程。我们知道，View 成功获取焦点是在 handleFocusGainInternal() 中进行的，因此我们可以以这个方法为切入点追踪系统建立焦点路径的过程。handleFocusGainInternal() 定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handleFocusGainInternal</span><span class="params">(<span class="meta">@FocusRealDirection</span> <span class="keyword">int</span> direction, Rect previouslyFocusedRect)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (DBG) &#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span> + <span class="string">&quot; requestFocus()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((mPrivateFlags &amp; PFLAG_FOCUSED) == <span class="number">0</span>) &#123;</span><br><span class="line">        mPrivateFlags |= PFLAG_FOCUSED;</span><br><span class="line">        View oldFocus = (mAttachInfo != <span class="keyword">null</span>) ? getRootView().findFocus() : <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (mParent != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mParent.requestChildFocus(<span class="keyword">this</span>, <span class="keyword">this</span>);</span><br><span class="line">            updateFocusedInCluster(oldFocus, direction);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mAttachInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mAttachInfo.mTreeObserver.dispatchOnGlobalFocusChange(oldFocus, <span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        onFocusChanged(<span class="keyword">true</span>, direction, previouslyFocusedRect);</span><br><span class="line">        refreshDrawableState();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法做的事很简单：将这个 View 的 PFLAG_FOCUSED 标志位设为 1，也就是让其成功地获取了焦点；然后调用其父 View 的 requestChildFocus() 方法。这个方法有两个参数，第一个参数传入的是调用父 View 该方法的那个子 View；后面那个参数传入的是具有焦点的那个 View。因为此 View 既是调用父 View 方法的 View，又是具有焦点的 View，所以两个参数传入的都是自身。这个方法的定义在 ViewGroup 中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestChildFocus</span><span class="params">(View child, View focused)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (DBG) &#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span> + <span class="string">&quot; requestChildFocus()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (getDescendantFocusability() == FOCUS_BLOCK_DESCENDANTS) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Unfocus us, if necessary</span></span><br><span class="line">    <span class="keyword">super</span>.unFocus(focused);</span><br><span class="line">    <span class="comment">// We had a previous notion of who had focus. Clear it.</span></span><br><span class="line">    <span class="keyword">if</span> (mFocused != child) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mFocused != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mFocused.unFocus(focused);</span><br><span class="line">        &#125;</span><br><span class="line">        mFocused = child;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mParent != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mParent.requestChildFocus(<span class="keyword">this</span>, focused);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法的逻辑很清晰：先是调用父类 View 的 unFoucs() 方法执行清除自身焦点的逻辑，<br>当然，可能这个 ViewGroup 可能本来就不具有焦点；再判断这个 ViewGroup 的 mFocused 变量和调用此方法的子 View 是不是同一个，如果不是，那么就在 mFocused 不为空的前提下调用其 unFocus() 方法，再将子 View 的值赋给 mFocused；最后，如果这个 ViewGroup 的 mParent 不为空，递归调用其 requestChildFocus() 方法，并分别将自身和具有焦点的那个 View 作为参数传入。</p>
<p>结合之前对 unFocus() 的分析可知：如果不考虑递归，requestChildFocus() 的效果是：将该 ViewGroup 的 mFocused 变量置为调用此方法的子 View，并清除自身可能拥有的焦点；如果考虑递归，这个方法的效果是，清除自身可能拥有的焦点，并将上一条焦点路径上从该 ViewGroup 节点开始的所有后续中间节点的 mFocused 变量置为 null，将上一条焦点路径的终止节点的焦点清除，且将从根节点开始一直到此节点的这条路径上的所有节点的 mFocused 值赋为该节点在此路径上的后继节点。因为最开始调用 requestChildFocus() 方法的 View 是那个具有焦点的 View，因此，最终的效果便是：清除上一次的焦点路径，并建立一条从根节点到具有焦点的 View 的焦点路径。</p>
<h2 id="确定焦点的过程"><a href="#确定焦点的过程" class="headerlink" title="确定焦点的过程"></a>确定焦点的过程</h2><p>我们知道，如果我们新建一个只有一个 EditText 的 Activity，这个 EditText 在 Activity 启动时会自动获取焦点，那么系统是如何让这个 EditText 获取焦点的呢？现在我们来分析下。</p>
<p>由之前的分析可知，View 通过是否设置标志位 PFLAG_FOCUSED 来标志自己是否拥有焦点，而在 View 的源码中发现只有 handleFocusGainInternal() 方法给 View 设置了这个标志位，因此可以认为 handleFocusGainInternal() 就是给 View 设置焦点的方法。我们可以通过 Android Studio 调试器的调用栈来分析这个方法的调用过程。我们在 Activity 中新建一个 EditText，因为当 Activity 启动时这个 EditText 会获取焦点，因此它的 handleFocusGainInternal() 方法会被调用。我们在 handleFocusGainInternal() 方法处设置断点，以调试模式启动这个 app。我们会发现程序一启动，就在断点处终止了，我们看看此时调试器中的方法栈：</p>
<p><img src="/img/in-post/post_android_view_focus/post-1.png"></p>
<p>根据方法栈我们可以一直追踪到 ViewRootImpl#focusableViewAvailable()，是这个方法触发了焦点的确定过程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">focusableViewAvailable</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">    checkThread();</span><br><span class="line">    <span class="keyword">if</span> (mView != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mView.hasFocus()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sAlwaysAssignFocus) &#123;</span><br><span class="line">                v.requestFocus();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// the one case where will transfer focus away from the current one</span></span><br><span class="line">            <span class="comment">// is if the current view is a view group that prefers to give focus</span></span><br><span class="line">            <span class="comment">// to its children first AND the view is a descendant of it.</span></span><br><span class="line">            View focused = mView.findFocus();</span><br><span class="line">            <span class="keyword">if</span> (focused <span class="keyword">instanceof</span> ViewGroup) &#123;</span><br><span class="line">                ViewGroup group = (ViewGroup) focused;</span><br><span class="line">                <span class="keyword">if</span> (group.getDescendantFocusability() == ViewGroup.FOCUS_AFTER_DESCENDANTS</span><br><span class="line">                        &amp;&amp; isViewDescendantOf(v, focused)) &#123;</span><br><span class="line">                    v.requestFocus();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法调用了参数 v 的 requestFocus() 方法，v 的实际类型是 DecorView，它就是根布局。因此，系统确定焦点的过程其实就是简单的调用了根部局的 requestFocus() 方法。因此，结合前面对 requestFocus() 和 onRequestFocusInDescendants() 方法的分析可知，根部局的这个方法会通过深度优先的方式调用视图树中各节点的 requestFocus() 方法。在时间顺序上，第一个该方法返回 true 的节点在成功地获取了焦点的同时会遍历终止，然后走建立新焦点路径和删除旧焦点路径的流程。在此节点之后 requestFocus() 方法返回 true 的节点将成为焦点路径上的中间节点，最后一个返回 true 的节点便是焦点路径的起始节点，也就是根节点。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对于 View 来说，是否具有焦点将影响它的绘制，如果这个 View 是 EditText，是否具有焦点还会决定它能否获取键盘输入。如果我们想通过代码在某个没有焦点的 EditText 上弹出键盘，仅仅通过 InputMethodManager#showSoftInput() 是不够的，还需在此之前调用其 requestFocus() 方法让其获取焦点。而对于 ViewGroup 来说，焦点通常不会对绘制和输入带来影响，但是它需要根据自身特点处理后代的焦点问题，比如，对于 ViewPager，在换页的时候，如果不重新分配焦点的话，焦点可能还会停留在上一个页面中，因此需要调用下一个页面的根部局的 requestFocus() 让它或者它的后代拥有获取焦点的机会，我们可以在 ViewPager 的源码中看到这种处理。</p>
]]></content>
      <tags>
        <tag>Android</tag>
        <tag>View</tag>
      </tags>
  </entry>
  <entry>
    <title>移动魔百盒 CM201 CH(长虹代工) 破解方法分享</title>
    <url>/2022/11/04/2022-11-04-CM201-crack/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这两天为了破解到期魔百盒看了好多帖子，最终成功破解了。为了让大家少走弯路，只看一篇帖子就能完成破解，我汇总了一下这两天学习到的东西，并分享下我的破解经历，希望对大家有所帮助。</p>
<h1 id="盒子型号"><a href="#盒子型号" class="headerlink" title="盒子型号"></a>盒子型号</h1><p>首先说下盒子型号是 CM201-2 长虹代工 (CH)，具体信息见图片：<br><img src="/img/in-post/cm201_crack/box-info.jpg" alt="盒子信息"><br>板子上的硬件信息是：CPU 型号是 HI3890MV300，闪存是 emmc。机型编码和牌照方不同应该没太大关系，因为网上那些教程和我的都不一样，但我也刷机成功了。大家可以先尝试一下，如果不行再说。</p>
<span id="more"></span>
<h1 id="破解方法"><a href="#破解方法" class="headerlink" title="破解方法"></a>破解方法</h1><p>这种盒子有两种破解模式，一种是解除无法安装软件的限制，另一种是是刷第三方系统。两种方式各有利弊，具体如下：<br>第一种破解模式：</p>
<ul>
<li>优点：步骤简单；</li>
<li>缺点：<ul>
<li>如果按到遥控器上的主页，会跳到订阅关系失效的页面，只能重启，比较麻烦，特别是对于那些不会用机顶盒的老人家来说。</li>
<li>而且原装系统有一堆用不到的应用在后台运行，占用内存，影响运行速度。<br>第二种破解模式：</li>
</ul>
</li>
<li>优点：<ul>
<li>系统精简，第三方系统一般会把那些没用的系统应用去除掉，运行速度会有所提升；</li>
<li>不用担心按到主页需要重启盒子的问题，因为第三方系统一般都会解决该问题；</li>
</ul>
</li>
<li>缺点：刷机步骤稍微复杂。</li>
</ul>
<p>这两种破解模式的简单和复杂都是相对而言的，都需要拆机通过 usb 转 ttl 来刷机，如果你想不拆机刷机，那这篇帖子可能对你没啥参考价值。我在网上找的所有的免拆方式都没有成功，包括使用 ZANTI 中间人攻击替换 apk 来安装当贝桌面的，还有通过遥控按键开启 adb 方式刷机的。<br>接下来具体说下这两种刷机模式的步骤。因为涉及到拆机，我把拆机的方法先提前说下：盒子底部有两个垫子，把垫子撕开就能看到螺丝孔了，取下这两个螺丝，然后就可以用指甲、卡片或者其他东西把盒子拆开。</p>
<h2 id="第一种破解方式"><a href="#第一种破解方式" class="headerlink" title="第一种破解方式"></a>第一种破解方式</h2><ol>
<li>准备工具：</li>
</ol>
<ul>
<li>U 盘 （大小最好为 8G，文件系统格式化为 fat32）；</li>
<li>usb 转 ttl 模块（淘宝有售，我买的型号是 CH340G）；</li>
<li>串口通信工具（windows 上比较知名的有 putty，mac 上有“串口调试助手”，这里以 putty 为例）;</li>
</ul>
<ol start="2">
<li><p>破解步骤：<br>将 usb 转 ttl 模块插入到电脑的 usb 口，然后打开 windows 设备管理器，在端口分类里查看这个模块是在哪个 COM 口，我的设备是在 COM4。</p>
<p>用杜邦线把 CH340G 的 RXD、TXD 和 GND三个引脚接到板子上。板子上的那四个孔第一个孔没用，其他三个孔从左到右分别是 RXD、TXD、GND，分别和 CH340G 的 TXD、RXD、GND 相对应，顺序不能错，如下图所示。有的博主给那三个孔焊上了排插，这样用杜邦线直接插上去就行，如果和我一样，没有其他工具，直接用那三根导线和三个孔保持良好稳定的接触也行。<br><img src="/img/in-post/cm201_crack/board-ttl-connection.png"><br>打开 putty ，如下图所示：<br><img src="/img/in-post/cm201_crack/putty.png"><br>把通信方式改成串口，Serial line 填写为上面查到的那个，我这里是 COM4，Speed 调整为 115200，Connection type 选择 Serial，其他的不用管，然后点击 右下角的 open，此时会出现一个漆黑的窗口，这个窗口就是用来和盒子进行通信的。打开盒子电源，这时应该能看到窗口上有日志输出：<br><img src="/img/in-post/cm201_crack/putty-shell.png"><br>等日志输出差不多完了之后，按下回车键，这时候会显示命令提示符，这样就进入到了设备的 shell 中了（如果没有显示命令提示符，查看那三根线是否接触良好，或者重新配置 putty 并打开窗口）。然后把当贝桌面下载到 U 盘根目录，把 U 盘插入到盒子靠近网口的 usb 口中，按照如下命令进入到 u 盘目录中，执行命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /mnt/sda/sda1</span><br><span class="line">pm install 当贝桌面apk文件名</span><br></pre></td></tr></table></figure>
<p>第一行命令是进入 U 盘，第二行命令是安装 U 盘里的当贝桌面。如图所示：<br><img src="/img/in-post/cm201_crack/install-apk.png"><br>这一步完了之后应该就装好了。你可以通过</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">am start com.dangbei.tvlauncher</span><br></pre></td></tr></table></figure>
<p>命令直接启动当贝桌面或者重启一下盒子，不出意外的话，启动后就进入当贝桌面了，破解完成。当贝桌面里面可以下载当贝应用市场，然后你就可以安装任意 APP 了。</p>
</li>
</ol>
<h2 id="第二种破解方式"><a href="#第二种破解方式" class="headerlink" title="第二种破解方式"></a>第二种破解方式</h2><ol>
<li>准备工具：</li>
</ol>
<ul>
<li>U 盘（大小最好为 8G，文件系统格式化为 fat32）；</li>
<li>usb 转 ttl 模块（淘宝有售，我买的型号是 CH340G）；</li>
<li>串口通信工具（windows 上比较知名的有 putty，mac 上有“串口调试助手”，这里以 putty 为例）；</li>
<li>hitool，网上随便搜下就有：<a href="http://www.winwin7.com/soft/4260.html%E3%80%82">http://www.winwin7.com/soft/4260.html。</a></li>
</ul>
<ol start="2">
<li><p>破解步骤：</p>
<p>这种破解方式是重刷系统，因为刷机风险比较大，因此建议刷机前先备份下系统，不要怕麻烦，万一失败了呢。备份方法如下：<br>前面的步骤和上面一样：用 CH340G 连接好板子，打开 putty，等日志输出完毕之后，按下回车，进入 shell。然后输入以下命令先进入到分区目录：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /dev/block/platform/soc/by-name</span><br></pre></td></tr></table></figure>
<p>接下来使用以下命令对各个分区进行备份（除了 userdata 分区，其他分区都备份一下）。/mnt/sda/sda1 对应的是 U 盘的根目录，system 是根目录下新建的子目录，这个目录应该是需要提前创建的，否则可能会报错。时间可能会有点久，但是多花点时间也值得，万一刷成砖也有挽救的方法，免得到处求别人要原厂镜像。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dd if=baseparam of=/mnt/sda/sda1/system/baseparam.img</span><br><span class="line">dd if=bootargs of=/mnt/sda/sda1/system/bootargs.img</span><br><span class="line">dd if=deviceinfo of=/mnt/sda/sda1/system/deviceinfo.img</span><br><span class="line">dd if=fastboot of=/mnt/sda/sda1/system/fastboot.img</span><br><span class="line">dd if=fastplay of=/mnt/sda/sda1/system/fastplay.img</span><br><span class="line">dd if=kernel of=/mnt/sda/sda1/system/kernel.img</span><br><span class="line">dd if=logo of=/mnt/sda/sda1/system/logo.img</span><br><span class="line">dd if=misc of=/mnt/sda/sda1/system/misc.img</span><br><span class="line">dd if=pqparam of=/mnt/sda/sda1/system/pqparam.img</span><br><span class="line">dd if=private of=/mnt/sda/sda1/system/private.img</span><br><span class="line">dd if=recovery of=/mnt/sda/sda1/system/recovery.img</span><br><span class="line">dd if=securestore of=/mnt/sda/sda1/system/securestore.img</span><br><span class="line">dd if=system of=/mnt/sda/sda1/system/system.img</span><br><span class="line">dd if=trustedcore of=/mnt/sda/sda1/system/trustedcore.img</span><br></pre></td></tr></table></figure>
<p>现在轮到 hitool 上场了，这里使用 hitool 的目的是把官方的 recovery 替换成第三方 recovery，这样就能够刷入第三方系统，否则刷机的时候会校验失败，我相信很多人都遇到这个问题。现在我们看看如何刷第三方 recovery。<br>保持 CH340G 和盒子的连接，关闭 putty（会和 hitool 冲突）。打开 hitool，选择 HiBurn 视图，如下图所示：<br><img src="/img/in-post/cm201_crack/hitool-conf.png"><br>PC 与板端配置如图所示：串口填 CH340G 所在端口，传输方式选串口，其他的不用管。（有的教程使用的是网口方式，速度会快点，但是需要网线连接，还需要配置 ip 地址，简单起见，我直接使用串口，速度慢一点也还好，毕竟 recovery 分区也不是很大）选择 烧写eMMC 页面，需要填写分区表配置，这个配置我已经写好了，大家可以直接拿来用：</p>
<p><a href="https://cloud.189.cn/web/share?code=MVNZJzFn2Eb2">CM201-2-CH4_HUNAN分区表文件.xml</a> （访问码：1ift）</p>
<p>需要注意的是，我这个分区表只适用于这个型号的盒子，其他盒子可能会有一些差异。保险起见大家还是核对一下，万一有不同可以进行修改，具体方法如下：</p>
<p>还记得连接 putty 的时候会有一堆日志输出吗？这里面就有修改分区表所需的信息：<br><img src="/img/in-post/cm201_crack/partition.png"><br>红框中的日志描述了每个分区的大小，大家先导入上面的分区表文件，然后把各个分区的长度修改成日志输出所示，大家直接修改长度那一列就行，开始地址会自动更改。如果输出日志中的分区和我的分区表不一样，可以手动添加或者删除，以你盒子的输出日志为准，注意顺序保持一致。</p>
<p>分区表修改完之后，可以点击保存，这样你就拥有了属于自己盒子的分区表了（备份好这个分区表，以后救砖可能还有用）。接下来就可以导入 recovery 分区，在 recovery 那一行的文件一列，将 recovery 文件导入进去。recovery 我这也准备好了：</p>
<p><a href="https://cloud.189.cn/web/share?code=2EjmYjMJzUJj">Hi3798MV300H芯片强刷引导</a> （访问码：ts2l）</p>
<p>你可能会感到疑惑，我的芯片不是 Hi3789MV300 吗，板子上写的也是这个，为啥这里用的引导是 Hi3789MV300H 的？我最开始用的 recovery 也是 Hi3789MV300 的，但是发现没用，后来才从日志里发现了问题：<br><img src="/img/in-post/cm201_crack/cpu-info.png"><br>这是 HiBurn 烧写时的日志输出（putty 输出的日志里也有，但我之前忘记截图了，所以用了 HiBurn 里的日志），里面写着 CPU 型号是 Hi3789MV300H。不知道为啥会这样，如果你的日志输出的 CPU 型号是 Hi3789MV300，那你应该使用 Hi3789MV300 的引导：</p>
<p><a href="https://cloud.189.cn/web/share?code=RJn6Fnu2auIb">Hi3798MV300芯片强刷引导</a>  （访问码：bo1f）</p>
<p>这个文件夹里有三个文件，实测只需要刷 recovery.img 文件就行了，其他两个分区文件不刷也行，如果你失败了，那就按照同样的方法把另外两个对应的分区也刷一下吧。</p>
<p>recovery 导入完成之后，记得把其他分区取消勾选，只保留 recovery 分区（因为我们只刷 recovery 分区，其他分区暂时不需要，除非你刷成砖了，就需要把之前备份好的分区文件一个一个导进来）。最后点击 烧写，将 recovery 刷到盒子里去：<br><img src="/img/in-post/cm201_crack/pre-flash-recovery.png"><br>如果你的盒子通着电，就会出现上面的提示，我们按照提示重新给盒子通电，不出意外的话，就开始烧写了：<br><img src="/img/in-post/cm201_crack/flashing-recovery.png"><br>左侧输出的是日志，大概等个十几二十分钟就烧好了（如果用网口应该更快）：<br><img src="/img/in-post/cm201_crack/recovery-flashed.png"><br>至此，recovery 的刷写工作就完毕了。现在你就可以选择各种刷机包来进行刷机了。我这里准备了一个基于别人的包制作的精简包，去除了其他 app，把巨丑的当贝影视桌面换成了当贝桌面，并且不会出现某些 rom 按主页时当贝桌面等半天或者无法响应的问题。同时还把开机动画改成了 Google TV，逼格一下子就上来了。</p>
<p><a href="https://cloud.189.cn/web/share?code=M7zm6vn6fuau">自制精简版_当贝桌面_Google_tv_开机动画_文件名改成update.zip</a> （访问码：4qxp）</p>
<p>把文件改成 update.zip 后放到 U 盘根目录中，插入到靠近网口的那个 usb 口。重新启动盒子电源，然后立刻快速交替按遥控器上的菜单键和音量减键，直到进入 recovery 界面（速度一定要快，不行多试几次）：<br><img src="/img/in-post/cm201_crack/recovery.jpg"><br>选择 本地USB升级，不出意外就开始刷机了，不用多久就刷好了，盒子重启，就能看到如下的开机画面：<br><img src="/img/in-post/cm201_crack/google-tv-splash.jpg"><br>欢迎使用 Google TV！</p>
<p>附一张当贝桌面的图：<br><img src="/img/in-post/cm201_crack/home.jpg"><br>注意：刷机后的盒子通过 putty 进入 shell 时需要用户名和密码，用户名和密码分别是：root 、chcmccch。</p>
</li>
</ol>
<p>分享到此结束，祝大家刷机成功！如果有错误的地方，或者有其他更好的方法，欢迎大家留言指出，这样也能帮助其他人。</p>
]]></content>
      <tags>
        <tag>搞机</tag>
      </tags>
  </entry>
  <entry>
    <title>vfork 的诡异输出</title>
    <url>/2023/09/16/2023-09-16-play-with-vfork/</url>
    <content><![CDATA[<p>学习 vfork 的时候，看到<a href="https://blog.csdn.net/kxcfzyk/article/details/41411099">这篇文章</a>中的一个例子，觉得很有趣，就拷贝下来自己跑了一下，其中的例子差不多是这样的：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vfork();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, getpid());</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    _exit(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    fun1();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d goes 1\n&quot;</span>, getpid());</span><br><span class="line"></span><br><span class="line">    fun2();   </span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d goes 2\n&quot;</span>, getpid());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>输出： </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ ./vfork</span><br><span class="line">2846438</span><br><span class="line">2846438 goes 1</span><br><span class="line">28464372</span><br><span class="line">846437 goes 2</span><br></pre></td></tr></table></figure>
<p>结合文章的讲解，我的理解如下：因为 <code>vfork</code> 后，子进程共享父进程的地址空间，父进程会等待子进程先执行，所以，子进程执行完 后 <code>fun2</code> 退出后，父进程的指令依旧停留在 <code>fun1</code> 的 <code>printf</code> 函数处。会执行 <code>fun1</code> 中的 <code>printf</code> 函数。但是为什么父进程没有打印出 goes 1 呢？因为子进程执行完 <code>fun1</code> 的时候，已经把 <code>fun1</code> 的返回地址弹出栈，返回到了 goes 1 处，而执行到 <code>fun2</code> 的时候，并没有返回，而是直接退出了，所以，栈上的返回地址还保留着，而这个返回地址就是输出 goes 2 的那个 <code>printf</code> 语句。因为父子进程共享栈，所以当父进程 <code>fun1</code> 返回时，返回的就是此时栈上的地址，也就是 goes 2 的那个 <code>printf</code> 语句的地址。<br>为了验证自己的理解是否到位，就把例子改成了下面这样，看看结果是否符合预期：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    _exit(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> pid = vfork();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d goes 1\n&quot;</span>, getpid());</span><br><span class="line">        fun();   </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;after fun&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;%d goes 2\n&quot;</span>, getpid());</span><br><span class="line">         <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>按照前面的理解，期望的输出应该是这样的：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ ./vfork             </span><br><span class="line">2846933 goes 1</span><br><span class="line">2846932 goes 2</span><br><span class="line">after fun</span><br></pre></td></tr></table></figure>
<p>我是怎么分析的：首先，<code>vfork</code> 之后，子进程先执行，进入到 <code>if</code> 块中，打印了 goes 1，然后进入到 <code>fun</code> 中 <code>exit</code> 了，这时候栈上 “残留” 着 <code>fun</code> 的返回地址。然后，父进程接着执行，进入到 <code>else</code> 块中， 打印出 goes 2，准备返回的时候发现栈上的地址是 <code>fun</code> 的返回地址，也就是打印 after fun 的那行代码，于是就接着输出 after fun。看起来一切都很合理对吧？但实际的输出却是：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ ./vfork             </span><br><span class="line">2846933 goes 1</span><br><span class="line">2846932 goes 2</span><br></pre></td></tr></table></figure>
<p>after fun 没了！不知道你们想明白没，反正我是绞尽脑汁想了好久才豁然开朗。之前在分析函数返回的时候，分析得比较粗略，我们如果再细致一点，从汇编层面分析一下 <code>return</code> 的细节，真相就呼之欲出了。<code>return</code> 语句其实对应着两个汇编指令的调用，先是 <code>leave</code>，然后才是 <code>return</code>。<code>leave</code> 指令等价于让 <code>rsp</code> 恢复为 <code>rbp</code> 的值，并且 <code>pop</code> 出栈顶的 old rbp 给 <code>rbp</code> 寄存器。所以 <code>leave</code> 指令执行后，<code>rsp</code> 指向的就是栈顶的 <code>rip</code> 了，此时 <code>return</code> 一下，就返回到 <code>rip</code> 对应的地址处了。<br>了解 <code>return</code> 的细节后，我们再来看看子进程将调用 <code>exit</code> 退出时的情况，此时子进程 <code>rbp</code> 指向的是 <code>fun</code> 函数的栈帧底部，也就是 after fun 的 <code>printf</code> 语句处，但随着 <code>exit</code> 的调用，子进程烟消云散。<code>vfork</code> 虽然会让父子进程共享地址空间，但是并不会共享寄存器，子进程 “生前” 对寄存器的改变并不会被父进程看见。子进程结束时虽然它的 <code>rbp</code> 指向的是 <code>fun</code> 的栈底，但父进程恢复执行后，父进程的 <code>rbp</code> 指向的是却依然是 <code>vfork</code> 调用时 <code>main</code> 函数的栈帧底部，所以父进程执行到 <code>return</code> 语句时，在执行了 <code>leave</code> 汇编指令后，栈顶的 <code>rip</code> 就是 <code>main</code> 函数的返回地址（这个地址在 libc 中），这之后再执行 <code>return</code> 指令就直接返回到 libc 里去了。<br>那么问题来了，为什么第一个例子中，父进程从 <code>fun1</code> 返回的却是 <code>fun2</code> 的调用处呢？其实父进程恢复执行时，它的 <code>rbp</code> 确实本应该指向的 <code>fun1</code> 的栈帧底部。但是，子进程执行完 <code>fun1</code> 后，<code>fun1</code> 的栈帧就不在了，子进程执行 <code>fun2</code> 的时候，在原来 <code>fun1</code> 的栈帧所在处，建立了 <code>fun2</code> 的栈帧。导致父进程本来指向 <code>fun1</code> 栈帧底部的 <code>rbp</code> 此时指向的是 <code>fun2</code> 的栈帧底部，然后一 <code>leave</code> ，一 <code>return</code>，自然就返回到 <code>fun2</code> 调用处了。</p>
<p>总结：</p>
<ol>
<li><code>vfork</code> 处的父子进程共享地址空间，但是不会共享寄存器，寄存器在 <code>vfork</code> 那个时刻，是相同的，后面随着子进程的执行开始分化。这期间父进程挂起，等到调度上 cpu 时，会用之前保存的值恢复所有寄存器。</li>
<li><code>return</code> 返回到哪里，关键看 <code>leave</code> 指令执行前的那一刻，<code>rbp</code> 指向的是哪个函数的栈帧底部，如果是 a ，那就返回到 a 的调用处，如果是 b，那就返回到 b 的调用处，至于是从哪个函数进来的，那不重要，只不过通常情况下，进入和返回的都是同一个调用点。</li>
</ol>
<p>当然，如果遵循推荐的 <code>vfork</code> 使用指南，通常我们并不会遇到这种诡异现象。<code>vfork</code> 的推荐玩法是，子进程分裂出来后，赶紧执行 <code>exec</code> 函数和父进程分家，抛弃掉父进程的地址空间 <code>mm_struct</code>（主要就是抛弃掉父进程的页表和 vma），另起炉灶，建立自己的 <code>mm_struct</code>，然后各自安好，互不打扰。在 <code>fork</code> 引入了写时复制技术后，使用 <code>fork</code> + <code>exec</code> 性能其实也还 ok，然而，虽然不用急着拷贝内存了，依然需要立即拷贝 <code>mm_struct</code>。结合网上的一些讨论，我个人认为，究竟使用 <code>fork</code> + <code>exec</code> 还是 <code>vfork</code> + <code>exec</code> 看情况而定，如果 <code>exec</code> 执行前的准备工作比较多，会在各种函数间穿梭，怕影响父进程，那就别想太多，就用 <code>fork</code>；如果立马执行 <code>exec</code>，就使用 <code>vfork</code>，避免对 <code>mm_struct</code> 的无效拷贝。虽然很多声音都说不要用 <code>vfork</code>，已经被时代抛弃了，但我觉得反正就是多加一个字母的事，性能能省就省，苍蝇再小也是肉，而且 Linux 的宿主设备繁多，可能一个不起眼的小设备上，就跑着一个 Linux，你的一个举手之劳，对这个小家伙而言说不定也是莫大的恩赐 :)。</p>
]]></content>
      <tags>
        <tag>linux</tag>
        <tag>unix</tag>
      </tags>
  </entry>
</search>
