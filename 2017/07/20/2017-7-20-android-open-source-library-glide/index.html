<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.1.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.loli.net/css?family=Monda:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic|EB Garamond:300,300italic,400,400italic,700,700italic|Source Code Pro:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"lwenkun.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"disqus","storage":true,"lazyload":false,"nav":{"disqus":{"order":-2}}},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":true,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Glide 源码探究前言Glide 是安卓平台上媒体管理和图片加载框架，它内部封装了媒体解码工具、内存和磁盘缓存以及资源池等，并向用户暴露简单易用的接口。我们可以用它来获取、解码、并展示视频、图片和 GIF 动画。如果大家有用过 Picasso 应该知道，Glide 的使用方式和 Picasso 非常相似，甚至很多 API 的名称都一样。但是相比 Picasso，Glide 的功能更加强大，内部实">
<meta property="og:type" content="article">
<meta property="og:title" content="Glide 源码探究">
<meta property="og:url" content="https://lwenkun.github.io/2017/07/20/2017-7-20-android-open-source-library-glide/index.html">
<meta property="og:site_name" content="李文坤的博客">
<meta property="og:description" content="Glide 源码探究前言Glide 是安卓平台上媒体管理和图片加载框架，它内部封装了媒体解码工具、内存和磁盘缓存以及资源池等，并向用户暴露简单易用的接口。我们可以用它来获取、解码、并展示视频、图片和 GIF 动画。如果大家有用过 Picasso 应该知道，Glide 的使用方式和 Picasso 非常相似，甚至很多 API 的名称都一样。但是相比 Picasso，Glide 的功能更加强大，内部实">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://lwenkun.github.io/img/in-post/post_android_open_source_library_glide/post-1.png">
<meta property="og:image" content="https://lwenkun.github.io/img/in-post/post_android_open_source_library_glide/post-2.png">
<meta property="og:image" content="https://lwenkun.github.io/img/in-post/post_android_open_source_library_glide/post-3.png">
<meta property="og:image" content="https://lwenkun.github.io/img/in-post/post_android_open_source_library_glide/post-4.png">
<meta property="og:image" content="https://lwenkun.github.io/img/in-post/post_android_open_source_library_glide/post-5.png">
<meta property="article:published_time" content="2017-07-20T00:00:00.000Z">
<meta property="article:modified_time" content="2024-03-29T17:38:05.440Z">
<meta property="article:author" content="Chance Li">
<meta property="article:tag" content="Android">
<meta property="article:tag" content="开源库">
<meta property="article:tag" content="Glide">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://lwenkun.github.io/img/in-post/post_android_open_source_library_glide/post-1.png">

<link rel="canonical" href="https://lwenkun.github.io/2017/07/20/2017-7-20-android-open-source-library-glide/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Glide 源码探究 | 李文坤的博客</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-76493784-1"></script>
    <script>
      if (CONFIG.hostname === location.hostname) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'UA-76493784-1');
      }
    </script>


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?4cc1f2d8f3067386cc5cdb626a202900";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">李文坤的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">吾生也有涯</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://lwenkun.github.io/2017/07/20/2017-7-20-android-open-source-library-glide/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://www.gravatar.com/avatar/95a0f14d3e6b40995a92c41673fd09d4?s=640">
      <meta itemprop="name" content="Chance Li">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李文坤的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Glide 源码探究
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-07-20 00:00:00" itemprop="dateCreated datePublished" datetime="2017-07-20T00:00:00+00:00">2017-07-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-03-29 17:38:05" itemprop="dateModified" datetime="2024-03-29T17:38:05+00:00">2024-03-29</time>
              </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>50k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>46 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="Glide-源码探究"><a href="#Glide-源码探究" class="headerlink" title="Glide 源码探究"></a>Glide 源码探究</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Glide 是安卓平台上媒体管理和图片加载框架，它内部封装了媒体解码工具、内存和磁盘缓存以及资源池等，并向用户暴露简单易用的接口。我们可以用它来获取、解码、并展示视频、图片和 GIF 动画。如果大家有用过 Picasso 应该知道，Glide 的使用方式和 Picasso 非常相似，甚至很多 API 的名称都一样。但是相比 Picasso，Glide 的功能更加强大，内部实现也更加复杂。接下来我们就从源码的角度来探究一下 Glide 的内部原理。</p>
<span id="more"></span>

<h2 id="Glide-的简单使用"><a href="#Glide-的简单使用" class="headerlink" title="Glide 的简单使用"></a>Glide 的简单使用</h2><p>在探究 Glide 的原理之前，我们先熟悉一下它的常见 API，这样有助于我们后面的分析。Glide 的 API 使用了流式 API 风格，加载图片一行代码就能搞定：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Glide.with(context).load(url).into(imageView);</span><br></pre></td></tr></table></figure>
<p>当然，以上只是 Glide 最基础、最常见的用法，它的功能远不止于此，基本上关于图片加载的需求它都能满足。上面这行代码调用了三次方法，经历了三个不同的过程：with() 方法用来获取 RequestManager；load() 方法根据传入的 url 返回了一个 RequestBuilder 对象；into() 方法创建了图片加载请求对象 Request 并开启了加载工作。现在，我们就来分析这三个过程。</p>
<h2 id="Glide-原理"><a href="#Glide-原理" class="headerlink" title="Glide 原理"></a>Glide 原理</h2><h3 id="获取-RequestManager"><a href="#获取-RequestManager" class="headerlink" title="获取 RequestManager"></a>获取 RequestManager</h3><p>Glide 的 with(Context) 方法返回的不是 Glide 实例，而是一个 RequestManager 对象，顾名思义，它用来管理图片加载请求。with() 方法有多个重载，除了接受 Context，它还可以接受 Activity，Fragment，View 等对象，这些重载方法如下：</p>
<p>[-&gt;Glide.java]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> RequestManager <span class="title function_">with</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> getRetriever(context).get(context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> RequestManager <span class="title function_">with</span><span class="params">(Activity activity)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> getRetriever(activity).get(activity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> RequestManager <span class="title function_">with</span><span class="params">(android.app.Fragment fragment)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> getRetriever(fragment.getActivity()).get(fragment);   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> RequestManager <span class="title function_">with</span><span class="params">(View view)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> getRetriever(view.getContext()).get(view);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这几个重载方法长得都差不多，结果都是返回一个 RequestManager 对象。这个过程分为两步：先通过 getRetriver() 获取一个 RequestManagerRetriever 对象，再通过这个对象的 get() 方法来获取 RequestManager。先看下 getRetriver() 方法：</p>
<p>[-&gt;Glide.java]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> RequestManagerRetriever <span class="title function_">getRetriever</span><span class="params">(<span class="meta">@Nullable</span> Context context)</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> Glide.get(context).getRequestManagerRetriever();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>静态方法 Glide#get() 创建了 Glide 单例，然后通过它的 getRequestManagerRetriever() 返回一个 RequesetManagerRetriever 对象。RequestManagerRetriever 顾名思义，是用来获取 ReqeustManager 的，那么它是怎样得到 RequestManager 对象的呢？我们先来分析下它的一个参数类型为 Context 的 get() 重载方法 ：</p>
<p>[-&gt;RequestManagerRetriever.java]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> RequestManager <span class="title function_">get</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (context == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;You cannot start a load on a null Context&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Util.isOnMainThread() &amp;&amp; !(context <span class="keyword">instanceof</span> Application)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (context <span class="keyword">instanceof</span> FragmentActivity) &#123;</span><br><span class="line">      <span class="keyword">return</span> get((FragmentActivity) context);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (context <span class="keyword">instanceof</span> Activity) &#123;</span><br><span class="line">      <span class="keyword">return</span> get((Activity) context);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (context <span class="keyword">instanceof</span> ContextWrapper) &#123;</span><br><span class="line">      <span class="keyword">return</span> get(((ContextWrapper) context).getBaseContext());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> getApplicationManager(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法最终会转调两类方法：一是 get() 重载方法，二是 getApplicationManager()。调用 get() 方法的时机是：当前线程在主线程，并且 Context 的实际类型为 FragmentActivity，Activity 和 ContextWrapper 其中之一。其他情况下都会调用 getApplicationManager()。我们看看 get(Activity)：</p>
<p>[-&gt;RequestManagerRetriever.java]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> RequestManager <span class="title function_">get</span><span class="params">(Activity activity)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (Util.isOnBackgroundThread()) &#123;</span><br><span class="line">    <span class="keyword">return</span> get(activity.getApplicationContext());</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    assertNotDestroyed(activity);</span><br><span class="line">    android.app.<span class="type">FragmentManager</span> <span class="variable">fm</span> <span class="operator">=</span> activity.getFragmentManager();</span><br><span class="line">    <span class="keyword">return</span> fragmentGet(activity, fm, <span class="literal">null</span> <span class="comment">/*parentHint*/</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果当前线程是后台线程，会再次调用 get(Context) 方法，因为传入的 Context 是 ApplicationContext，因此这个方法最终会调用 getApplicationManager(Context)；如果不是后台线程，在 Activity 还没销毁的前提下，会调用 fragmentGet()。get(FragmentActivity) 的逻辑和 get(Activity) 类似，这里就不赘述了，有兴趣可以自行查看源码。</p>
<p>假设加载动作发生在主线程，fragmentGet() 会得到调用，其源码如下：</p>
<p>[-&gt;RequestManagerRetriever.java]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> RequestManager <span class="title function_">fragmentGet</span><span class="params">(Context context, android.app.FragmentManager fm,</span></span><br><span class="line"><span class="params">    android.app.Fragment parentHint)</span> &#123;</span><br><span class="line">  <span class="type">RequestManagerFragment</span> <span class="variable">current</span> <span class="operator">=</span> getRequestManagerFragment(fm, parentHint);</span><br><span class="line">  <span class="type">RequestManager</span> <span class="variable">requestManager</span> <span class="operator">=</span> current.getRequestManager();</span><br><span class="line">  <span class="keyword">if</span> (requestManager == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="type">Glide</span> <span class="variable">glide</span> <span class="operator">=</span> Glide.get(context);</span><br><span class="line">    requestManager =</span><br><span class="line">        factory.build(glide, current.getGlideLifecycle(), current.getRequestManagerTreeNode());</span><br><span class="line">    current.setRequestManager(requestManager);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> requestManager;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前 FragmentManager 中的 RequestManagerFragment</span></span><br><span class="line">RequestManagerFragment <span class="title function_">getRequestManagerFragment</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="keyword">final</span> android.app.FragmentManager fm, android.app.Fragment parentHint)</span> &#123;</span><br><span class="line">  <span class="comment">// 根据 TAG 查找</span></span><br><span class="line">  <span class="type">RequestManagerFragment</span> <span class="variable">current</span> <span class="operator">=</span> (RequestManagerFragment) fm.findFragmentByTag(FRAGMENT_TAG);</span><br><span class="line">  <span class="keyword">if</span> (current == <span class="literal">null</span>) &#123;</span><br><span class="line">    current = pendingRequestManagerFragments.get(fm);</span><br><span class="line">    <span class="keyword">if</span> (current == <span class="literal">null</span>) &#123;</span><br><span class="line">      current = <span class="keyword">new</span> <span class="title class_">RequestManagerFragment</span>();</span><br><span class="line">      current.setParentFragmentHint(parentHint);</span><br><span class="line">      pendingRequestManagerFragments.put(fm, current);</span><br><span class="line">      <span class="comment">// 将创建的 RequestManagerFragment 添加到 FragmentManager 中</span></span><br><span class="line">      fm.beginTransaction().add(current, FRAGMENT_TAG).commitAllowingStateLoss();</span><br><span class="line">      handler.obtainMessage(ID_REMOVE_FRAGMENT_MANAGER, fm).sendToTarget();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> current;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上面的代码可以知道，get(Activity) 方法的逻辑是从当前 Activity 中找 RequestManagerFragment，有则从其中取出 RequestManager，无则创建一个ReqeustManagerFragment 和 RequestManager，将 RequestManagerFragment 和 RequestManager 关联之后把 RequestManager 对象返回。这里有一个比较奇怪的地方：为什么要创建 RequestManagerFragment？我们看下 RequestManagerFragment 的文档说明：</p>
<blockquote>
<p>A view-less {@link android.app.Fragment} used to safely store an {@link<br> com.bumptech.glide.RequestManager} that can be used to start, stop and manage Glide requests<br> started for targets the fragment or activity this fragment is a child of.</p>
</blockquote>
<p>通过文档可知，其实 Glide 在这里使用了 “奇技淫巧”，它借助 RequestManagerFragment 来跟踪 Activity 或者 Fragment 的生命周期。为什么要这么做呢？这要从图片加载的场景来理解。本着减少网络请求及各种资源消耗的目的，通常我们会希望如果当前界面被覆盖或者被销毁，图片是不进行加载的。而图片加载库如何能感知界面被覆盖和被销毁呢？我们知道 Activity 或者 Fragment 的生命周期其实和交互界面的变化是相关联的，因此可以利用 Activity 或者 Fragment 的生命周期来驱动图片的加载过程，比如可以在 onStart() 方法中开始图片加载，在 onStop() 方法中暂停图片的加载。然而，如果要在客户端代码中的每一个 Activity 或者 Fragment 中加入这些逻辑，首先代码显得混乱、冗余；其次将图片的加载管理交给开发者实现，增加了开发者的工作，开发者必须实现一套行之有效的图片加载管理方案，这显然不是一个优秀的图片加载库应该做的事。那怎么办呢？这时候 RequestManagerFragment 就派上用场了，如果将 RequestManagerFragment 动态添加入当前的 Activity 或者 Fragment 中，那么 RequestManagerFragment 也将获得生命周期，就可以用 RequestManagerFragment 生命周期来驱动 Glide 的加载。RequestManagerRetriever 的所有 get() 方法，其实都在做同一件事情：根据传入的参数找到当前加载环境关联的 Activity 或者 Fragment，然后设法将 RequesManagerFragment 嵌入其中，最后返回具备生命周期的 RequestManager。我们可以通过 get(View) 来进一步验证：</p>
<p>[-&gt;RequestManagerRetriever.java]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> RequestManager <span class="title function_">get</span><span class="params">(<span class="meta">@NonNull</span> View view)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (Util.isOnBackgroundThread()) &#123;</span><br><span class="line">    <span class="comment">// 最终会调用 get(Context)，最终调用 getApplicationManager()</span></span><br><span class="line">    <span class="keyword">return</span> get(view.getContext().getApplicationContext());</span><br><span class="line">  &#125;</span><br><span class="line">  Preconditions.checkNotNull(view);</span><br><span class="line">  Preconditions.checkNotNull(view.getContext(),</span><br><span class="line">      <span class="string">&quot;Unable to obtain a request manager for a view without a Context&quot;</span>);</span><br><span class="line">  <span class="type">Activity</span> <span class="variable">activity</span> <span class="operator">=</span> findActivity(view.getContext());</span><br><span class="line">  <span class="comment">// The view might be somewhere else, like a service.</span></span><br><span class="line">  <span class="keyword">if</span> (activity == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> get(view.getContext().getApplicationContext());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (activity <span class="keyword">instanceof</span> FragmentActivity) &#123;</span><br><span class="line">    <span class="type">Fragment</span> <span class="variable">fragment</span> <span class="operator">=</span> findSupportFragment(view, (FragmentActivity) activity);</span><br><span class="line">    <span class="keyword">return</span> fragment != <span class="literal">null</span> ? get(fragment) : get(activity);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Standard Fragments.</span></span><br><span class="line">  android.app.<span class="type">Fragment</span> <span class="variable">fragment</span> <span class="operator">=</span> findFragment(view, activity);</span><br><span class="line">  <span class="keyword">if</span> (fragment == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> get(activity);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> get(fragment);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>get(View) 会取出 View 中的 Context 进行判断，如果 Context 没有关联到 Activity 或 Fragment 或者图片加载动作发生在后台，那么会调用 get(Context)，因为传入的是 Context 是 ApplicationContext，因此最终会调用 getApplicationManager()。如果 View 直接关联到 Activity，那么会调用 get(Activity) 或者 get(FragmentActivity) ，如果是直接关联到 Fragment 便会调用 get(Fragment)。</p>
<p>这样看来，每个 Activity 和 Fragment 都会有一个 RequestManagerFragment（前提是有图片加载动作），而每一个 RequestManagerFragment 都关联着一个 RequestManager。也就是说，每一个 Activity 或者 Fragment 都对应着一个 RequestManager。那么 RequestManager 是如何获取生命周期的呢？上面的 fragmentGet() 中有这样一行代码：</p>
<p>[-&gt;RequestManagerRetriever.java]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">requestManager =</span><br><span class="line">        factory.build(glide, current.getGlideLifecycle(), current.getRequestManagerTreeNode());</span><br></pre></td></tr></table></figure>

<p>这行代码是赋予 RequestManager 生命周期的核心方法。factory 的实际类型是 GeneratedRequestManagerFactory，current 是 RequestManagerFragment 对象，getGlideLifecycle() 方法返回的是 ActivityFragmentLifecycle 对象，它实现了 Lifecycle 接口。</p>
<p>[-&gt;RequestManagerFragment.java]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">ActivityFragmentLifecycle <span class="title function_">getGlideLifecycle</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> lifecycle;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ActivityFragmentLifecycle</span> <span class="keyword">implements</span> <span class="title class_">Lifecycle</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;LifecycleListener&gt; lifecycleListeners =</span><br><span class="line">      Collections.newSetFromMap(<span class="keyword">new</span> <span class="title class_">WeakHashMap</span>&lt;LifecycleListener, Boolean&gt;());</span><br><span class="line">  <span class="keyword">private</span> <span class="type">boolean</span> isStarted;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">boolean</span> isDestroyed;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addListener</span><span class="params">(LifecycleListener listener)</span> &#123;</span><br><span class="line">    lifecycleListeners.add(listener);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isDestroyed) &#123;</span><br><span class="line">      listener.onDestroy();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isStarted) &#123;</span><br><span class="line">      listener.onStart();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      listener.onStop();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeListener</span><span class="params">(LifecycleListener listener)</span> &#123;</span><br><span class="line">    lifecycleListeners.remove(listener);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">onStart</span><span class="params">()</span> &#123;</span><br><span class="line">    isStarted = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (LifecycleListener lifecycleListener : Util.getSnapshot(lifecycleListeners)) &#123;</span><br><span class="line">      lifecycleListener.onStart();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">onStop</span><span class="params">()</span> &#123;</span><br><span class="line">    isStarted = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (LifecycleListener lifecycleListener : Util.getSnapshot(lifecycleListeners)) &#123;</span><br><span class="line">      lifecycleListener.onStop();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">onDestroy</span><span class="params">()</span> &#123;</span><br><span class="line">    isDestroyed = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (LifecycleListener lifecycleListener : Util.getSnapshot(lifecycleListeners)) &#123;</span><br><span class="line">      lifecycleListener.onDestroy();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Lifecycle 是一个管理生命周期监听器的接口。ActivityFragmentLifecycle 在实现接口的基础上增加了三个生命周期方法，它们会遍历所有的 LifecycleListener，调用其相应的生命周期方法。这三个方法主要是用来和 RequestManagerFragment 的生命周期对接：</p>
<p>[-&gt;RequestManagerFragment.java]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onStart</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="built_in">super</span>.onStart();</span><br><span class="line">  lifecycle.onStart();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onStop</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="built_in">super</span>.onStop();</span><br><span class="line">  lifecycle.onStop();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onDestroy</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="built_in">super</span>.onDestroy();</span><br><span class="line">  lifecycle.onDestroy();</span><br><span class="line">  unregisterFragmentWithRoot();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此，任何实现 LifecycleListener 的类可通过 addListener() 添加到 ActivityFragmentLifecycle 中从而获得生命周期。那么我们可以猜测 RequestManager 一定实现了 LifecycleListener 接口，事实也的确如此。那么 RequestManager 是如何添加进 ActivityFragmentLifecycle 中的呢？ 答案就在 RequestManager 的构造方法中：</p>
<p>[-&gt;RequestManager.java]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">RequestManager(</span><br><span class="line">    Glide glide,</span><br><span class="line">    Lifecycle lifecycle,</span><br><span class="line">    RequestManagerTreeNode treeNode,</span><br><span class="line">    RequestTracker requestTracker,</span><br><span class="line">    ConnectivityMonitorFactory factory,</span><br><span class="line">    Context context) &#123;</span><br><span class="line">  <span class="built_in">this</span>.glide = glide;</span><br><span class="line">  <span class="built_in">this</span>.lifecycle = lifecycle;</span><br><span class="line">  <span class="built_in">this</span>.treeNode = treeNode;</span><br><span class="line">  <span class="built_in">this</span>.requestTracker = requestTracker;</span><br><span class="line">  <span class="built_in">this</span>.context = context;</span><br><span class="line">  connectivityMonitor =</span><br><span class="line">      factory.build(</span><br><span class="line">          context.getApplicationContext(),</span><br><span class="line">          <span class="keyword">new</span> <span class="title class_">RequestManagerConnectivityListener</span>(requestTracker));</span><br><span class="line">  <span class="comment">// If we&#x27;re the application level request manager, we may be created on a background thread.</span></span><br><span class="line">  <span class="comment">// In that case we cannot risk synchronously pausing or resuming requests, so we hack around the</span></span><br><span class="line">  <span class="comment">// issue by delaying adding ourselves as a lifecycle listener by posting to the main thread.</span></span><br><span class="line">  <span class="comment">// This should be entirely safe.</span></span><br><span class="line">  <span class="keyword">if</span> (Util.isOnBackgroundThread()) &#123;</span><br><span class="line">    mainHandler.post(addSelfToLifecycle);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    lifecycle.addListener(<span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  lifecycle.addListener(connectivityMonitor);</span><br><span class="line">  setRequestOptions(glide.getGlideContext().getDefaultRequestOptions());</span><br><span class="line">  glide.registerRequestManager(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里根据当前线程决定如何将 RequestManager 添加至 Lifecycle 中。如果子线程，通过 post 添加；如果 UI 线程，就直接添加。原因注释里说的很清楚了，如果是 Application 级别的 RequestManager，也就是通过 getApplicationManager() 得到的那个 RequestMangaer，它可能创建于子线程中，那么就有可能冒同步停止和继续请求的风险。其实这段话我也没理解：），等以后上网查资料解决吧。</p>
<p>get() 方法之间的调用关系可能有点复杂，贴上一张图便于理解：</p>
<p><img src="/img/in-post/post_android_open_source_library_glide/post-1.png" alt="get 调用关系"></p>
<p>从上图可以看出几乎在所有的 get() 重载方法中，都会根据特殊情况直接或间接调用 getApplicationManager() 方法，这种特殊情况就是加载动作发生在后台线程或者无法找到关联的 Activity 或者 Fragment，此方法返回的 RequestManager 是没有生命周期的。这样做的目的是什么呢？我们知道生命周期是在 UI 线程接受回调的，让子线程也接受生命周期回调也不是不可以，但是子线程在加载，UI 线程通过生命周期也介入加载过程，相当于两个线程同时操作数据，这会带来线程安全问题，如果做同步，需要同步的地方很多，那么会带来严重的性能问题；而如果没有关联到 Activity 或者 Fragment，无法接受生命周期回调。对于这两种情况，Glide 没有办法，只能任其加载而不受生命周期控制，算是一种折中了吧。getApplicationManager() 的定义如下： </p>
<p>[-&gt;RequestManagerRetriever.java]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> RequestManager <span class="title function_">getApplicationManager</span><span class="params">(<span class="meta">@NonNull</span> Context context)</span> &#123;</span><br><span class="line">  <span class="comment">// Either an application context or we&#x27;re on a background thread.</span></span><br><span class="line">  <span class="keyword">if</span> (applicationManager == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (applicationManager == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Normally pause/resume is taken care of by the fragment we add to the fragment or</span></span><br><span class="line">        <span class="comment">// activity. However, in this case since the manager attached to the application will not</span></span><br><span class="line">        <span class="comment">// receive lifecycle events, we must force the manager to start resumed using</span></span><br><span class="line">        <span class="comment">// ApplicationLifecycle.</span></span><br><span class="line">        <span class="comment">// TODO(b/27524013): Factor out this Glide.get() call.</span></span><br><span class="line">        <span class="type">Glide</span> <span class="variable">glide</span> <span class="operator">=</span> Glide.get(context.getApplicationContext());</span><br><span class="line">        applicationManager = factory.build(glide, <span class="keyword">new</span> <span class="title class_">ApplicationLifecycle</span>(),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">EmptyRequestManagerTreeNode</span>(),</span><br><span class="line">                context.getApplicationContext());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> applicationManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法也有这样一行代码：</p>
<p>[-&gt;RequestManagerRetriever.java]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">applicationManager = factory.build(glide, <span class="keyword">new</span> <span class="title class_">ApplicationLifecycle</span>(),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">EmptyRequestManagerTreeNode</span>(),</span><br><span class="line">                context.getApplicationContext());</span><br></pre></td></tr></table></figure>

<p>applicationManager 也是通过 GeneratedRequestManagerFactory#build() 来创建的，但第二个参数和之前的有所不同，这里直接 new 了一个 ApplicationLifecycle() 传进去。ApplicationLifecycle 的定义如下：</p>
<p>[-&gt; ApplicationLifecycle.java]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ApplicationLifecycle</span> <span class="keyword">implements</span> <span class="title class_">Lifecycle</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addListener</span><span class="params">(LifecycleListener listener)</span> &#123;</span><br><span class="line">    listener.onStart();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeListener</span><span class="params">(LifecycleListener listener)</span> &#123;</span><br><span class="line">    <span class="comment">// Do nothing.</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，这个 ApplicationLifecycle 其实是个假 Lifecycle，因为他根本没有将 LifecycleListener 添加进去，仅仅是立马调用了其 onStart() 方法。由此可见，getApplicationManager() 获取的是没有生命周期的 RequestManager。最后用一张图来总结 RequestManager 的获取过程：</p>
<p><img src="/img/in-post/post_android_open_source_library_glide/post-2.png" alt="RequestManager 的获取过程"></p>
<h3 id="创建-RequestBuilder"><a href="#创建-RequestBuilder" class="headerlink" title="创建 RequestBuilder"></a>创建 RequestBuilder</h3><p>前面我们分析了 Request 的获取过程，既然请求管理器建好了，那么下一步肯定是构建请求了。Glide 使用建造者模式来构建 Request，这个构建者就是 RequestBuilder。建造者模式通常是这样的，通过构建器收集参数，最后调用其 build() 或 create() 方法构建目标对象。那么 RequestBuilder 为了构造一个 Request 会收集哪些参数呢？我们看看它的声明的字段：  </p>
<p>[-&gt;RequestBuilder.java]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Context context;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> RequestManager requestManager; <span class="comment">// 关联的 RequestManager</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Class&lt;TranscodeType&gt; transcodeClass; <span class="comment">// 图片资源最终要转换成的对象类型</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> RequestOptions defaultRequestOptions; <span class="comment">// 默认的请求选项</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Glide glide;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> GlideContext glideContext; <span class="comment">// Glide 上下文，精简版的 Glide</span></span><br><span class="line"><span class="meta">@NonNull</span> <span class="keyword">protected</span> RequestOptions requestOptions; <span class="comment">// 请求选项</span></span><br><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">private</span> TransitionOptions&lt;?, ? <span class="built_in">super</span> TranscodeType&gt; transitionOptions; <span class="comment">// 渐变动画选项</span></span><br><span class="line"><span class="meta">@Nullable</span> <span class="keyword">private</span> Object model;</span><br><span class="line"><span class="comment">// model may occasionally be null, so to enforce that load() was called, put a boolean rather</span></span><br><span class="line"><span class="comment">// than relying on model not to be null.</span></span><br><span class="line"><span class="meta">@Nullable</span> <span class="keyword">private</span> RequestListener&lt;TranscodeType&gt; requestListener; <span class="comment">// 请求监听器</span></span><br><span class="line"><span class="meta">@Nullable</span> <span class="keyword">private</span> RequestBuilder&lt;TranscodeType&gt; thumbnailBuilder; <span class="comment">// 缩略图</span></span><br><span class="line"><span class="meta">@Nullable</span> <span class="keyword">private</span> RequestBuilder&lt;TranscodeType&gt; errorBuilder; <span class="comment">// 错误图</span></span><br><span class="line"><span class="meta">@Nullable</span> <span class="keyword">private</span> Float thumbSizeMultiplier;<span class="comment">// 缩略图的缩放因子</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">isDefaultTransitionOptionsSet</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> isModelSet;</span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> isThumbnailBuilt;</span><br></pre></td></tr></table></figure>
<p>我们看下 RequestOptions 这个类，它是请求的附加选项，在发起一个图片请求时，我们可能对它会有一些特殊的要求，此时就可以通过 RequestOptions 来添加这些要求，ReqeustOptions 的定义：</p>
<p>[-&gt;RequestOptions.java]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestOptions</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">UNSET</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SIZE_MULTIPLIER</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DISK_CACHE_STRATEGY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PRIORITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">ERROR_PLACEHOLDER</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">ERROR_ID</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PLACEHOLDER</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">6</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PLACEHOLDER_ID</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">7</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">IS_CACHEABLE</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">8</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">OVERRIDE</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">9</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SIGNATURE</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TRANSFORMATION</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">11</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">RESOURCE_CLASS</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">12</span>;</span><br><span class="line">  ......</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> fields;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">float</span> <span class="variable">sizeMultiplier</span> <span class="operator">=</span> <span class="number">1f</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">DiskCacheStrategy</span> <span class="variable">diskCacheStrategy</span> <span class="operator">=</span> DiskCacheStrategy.AUTOMATIC;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">Priority</span> <span class="variable">priority</span> <span class="operator">=</span> Priority.NORMAL;</span><br><span class="line">  <span class="keyword">private</span> Drawable errorPlaceholder;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> errorId;</span><br><span class="line">  <span class="keyword">private</span> Drawable placeholderDrawable;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> placeholderId;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">isCacheable</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> <span class="variable">overrideHeight</span> <span class="operator">=</span> RequestOptions.UNSET;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> <span class="variable">overrideWidth</span> <span class="operator">=</span> RequestOptions.UNSET;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">Key</span> <span class="variable">signature</span> <span class="operator">=</span> EmptySignature.obtain();</span><br><span class="line">  <span class="keyword">private</span> <span class="type">boolean</span> isTransformationRequired;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">isTransformationAllowed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">private</span> Drawable fallbackDrawable;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> fallbackId;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">Options</span> <span class="variable">options</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Options</span>();</span><br><span class="line">  <span class="keyword">private</span> Map&lt;Class&lt;?&gt;, Transformation&lt;?&gt;&gt; transformations = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">  <span class="keyword">private</span> Class&lt;?&gt; resourceClass = Object.class;</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，请求的附加选项包括底盘缓存策略，请求优先级，占位图，兜底图等常见选项，这些选项全部通过标志位来标识是否设立新值，为什么通过标志位来表示？因为很多选项都有默认值，通过判空来判断它们是否设定了新值是行不通的。RequestOptions 是可以合并的，两个 RequestOptions 可以合并成一个 RequestOptions，这个功能由 RequestOptions#apply(RequestOptions) 来实现。例如 A 想合并 B，可以这样： C &#x3D; A.apply(B) ，结果是 B 中的新值会覆盖 A 中的值，B 中的默认值不会覆盖 A 中的值。</p>
<p>现在我们回头再看看 RequestManager 的 load() 方法：</p>
<p>[-&gt;RequestManager.java]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> RequestBuilder&lt;Drawable&gt; <span class="title function_">load</span><span class="params">(<span class="meta">@Nullable</span> Drawable drawable)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> asDrawable().load(drawable);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> RequestBuilder&lt;Drawable&gt; <span class="title function_">load</span><span class="params">(<span class="meta">@Nullable</span> Bitmap bitmap)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> asDrawable().load(bitmap);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> RequestBuilder&lt;Drawable&gt; <span class="title function_">load</span><span class="params">(<span class="meta">@Nullable</span> Object model)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> asDrawable().load(model);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> RequestBuilder&lt;Drawable&gt; <span class="title function_">asDrawable</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> as(Drawable.class).transition(<span class="keyword">new</span> <span class="title class_">DrawableTransitionOptions</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;ResourceType&gt; RequestBuilder&lt;ResourceType&gt; <span class="title function_">as</span><span class="params">(Class&lt;ResourceType&gt; resourceClass)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RequestBuilder</span>&lt;&gt;(glide, <span class="built_in">this</span>, resourceClass, context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>as() 方法构建了一个 RequestBuilder 并指明了 resourceClass，这个 resourceClass 就是 RequestBuilder 中的  transcodeClass，表明图片资源最终转换成的对象。 asDrawable() 方法创建了一个 transcodeClass 为 Drawable 的 RequestBuilder，并且指定了 transitionOptions 的值。而 load() 方法最为最外层的方法，首先调用了 asDrawable()，然后调用 RequestBuilder#load() 将 model 传进去。</p>
<p>[-&gt;ReuqestBuilder.java]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> RequestBuilder&lt;TranscodeType&gt; <span class="title function_">load</span><span class="params">(<span class="meta">@Nullable</span> Uri uri)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> loadGeneric(uri);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> RequestBuilder&lt;TranscodeType&gt; <span class="title function_">load</span><span class="params">(<span class="meta">@Nullable</span> File file)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> loadGeneric(file);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> RequestBuilder&lt;TranscodeType&gt; <span class="title function_">load</span><span class="params">(<span class="meta">@Nullable</span> Drawable drawable)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> loadGeneric(drawable)</span><br><span class="line">      .apply(diskCacheStrategyOf(DiskCacheStrategy.NONE));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> RequestBuilder&lt;TranscodeType&gt; <span class="title function_">apply</span><span class="params">(<span class="meta">@NonNull</span> RequestOptions requestOptions)</span> &#123;</span><br><span class="line">  Preconditions.checkNotNull(requestOptions);</span><br><span class="line">  <span class="built_in">this</span>.requestOptions = getMutableOptions().apply(requestOptions);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> RequestBuilder&lt;TranscodeType&gt; <span class="title function_">loadGeneric</span><span class="params">(<span class="meta">@Nullable</span> Object model)</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.model = model;</span><br><span class="line">  isModelSet = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>[-&gt;RequestOptions.java]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> RequestOptions <span class="title function_">diskCacheStrategyOf</span><span class="params">(<span class="meta">@NonNull</span> DiskCacheStrategy diskCacheStrategy)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RequestOptions</span>().diskCacheStrategy(diskCacheStrategy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>RequestBuilder 中有很多 load() 方法，上面只列举了一部分。以上三个 load() 方法都会转调 loadGeneric() 方法，第三个 load() 还会合并一个指定了磁盘缓存策略的 RequestOptions。loadGeneric() 做的事很简单，就是给 model 赋值。由此我们可以看出，model 的实际类型有很多种，可以是 Uri，也可以是 Bitmap，还可以是 File 等。</p>
<p>RequestBuilder 的参数收集过程讲完了，下一步就是 Request 的构建过程了。从上面的分析可知，RequestManager#load() 方法返回的既然是 RequestBuilder，那 Request 的构建和执行一定都是在 into() 的调用栈中进行的。</p>
<h3 id="Request-的构建和执行"><a href="#Request-的构建和执行" class="headerlink" title="Request 的构建和执行"></a>Request 的构建和执行</h3><p>万事俱备，只欠东风。现在我们以 into() 为切入点，看看 Request 是如何构建和执行的。into() 定义在 RequestBuilder 中：</p>
<p>[-&gt;RequestBuilder.java]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;Y <span class="keyword">extends</span> <span class="title class_">Target</span>&lt;TranscodeType&gt;&gt; Y <span class="title function_">into</span><span class="params">(<span class="meta">@NonNull</span> Y target)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> into(target, <span class="comment">/*targetListener=*/</span> <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Synthetic</span> &lt;Y <span class="keyword">extends</span> <span class="title class_">Target</span>&lt;TranscodeType&gt;&gt; Y <span class="title function_">into</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="meta">@NonNull</span> Y target,</span></span><br><span class="line"><span class="params">    <span class="meta">@Nullable</span> RequestListener&lt;TranscodeType&gt; targetListener)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> into(target, targetListener, getMutableOptions());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Target&lt;TranscodeType&gt; <span class="title function_">into</span><span class="params">(ImageView view)</span> &#123;</span><br><span class="line">  ......</span><br><span class="line">  <span class="keyword">return</span> into(context.buildImageViewTarget(view, transcodeClass), <span class="literal">null</span>,</span><br><span class="line">        requestOptions);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>into() 有多个重载，但是最终都会调用一个含三个参数的重载方法。第三个 into() 我们很熟悉，我们经常使用它来将加载好的图片资源设置给 ImageView，这个 ImageView 在方法中会被包装成一个 Target 对象，然后传入含三个参数的 into() 重载方法中。Glide 把所有图片资源的目的用途抽象成 Target，这一点很巧妙，因为图片加载库的使用场景有很多，除了可以将它设置给 ImageView，还可以存入磁盘文件，内存，或者其他用途。我们可以看看 Target 的定义：</p>
<p>[-&gt;Target.java]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Target</span>&lt;R&gt; <span class="keyword">extends</span> <span class="title class_">LifecycleListener</span> &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">onLoadStarted</span><span class="params">(<span class="meta">@Nullable</span> Drawable placeholder)</span>;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">onLoadFailed</span><span class="params">(<span class="meta">@Nullable</span> Drawable errorDrawable)</span>;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">onResourceReady</span><span class="params">(<span class="meta">@NonNull</span> R resource, <span class="meta">@Nullable</span> Transition&lt;? <span class="built_in">super</span> R&gt; transition)</span>;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">getSize</span><span class="params">(<span class="meta">@NonNull</span> SizeReadyCallback cb)</span>;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">removeCallback</span><span class="params">(<span class="meta">@NonNull</span> SizeReadyCallback cb)</span>;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">setRequest</span><span class="params">(<span class="meta">@Nullable</span> Request request)</span>;</span><br><span class="line">  <span class="meta">@Nullable</span></span><br><span class="line">  Request <span class="title function_">getRequest</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以根据自己的需要实现 Target 接口，从而自定义图片资源的用途。buildImageViewTarget() 返回的是一个 ImageViewTarget 对象，它是一个抽象类，继承自 ViewTarget，有两个子类 BitmapImageViewTarget 和 DrawableImageViewTarget，前者的接收的图片资源类型是 Bitmap，后者是 Drawable。</p>
<p>[-&gt;ImageViewTarget.java]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onLoadStarted</span><span class="params">(<span class="meta">@Nullable</span> Drawable placeholder)</span> &#123;</span><br><span class="line">  <span class="built_in">super</span>.onLoadStarted(placeholder);</span><br><span class="line">  setResourceInternal(<span class="literal">null</span>);</span><br><span class="line">  setDrawable(placeholder);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onLoadFailed</span><span class="params">(<span class="meta">@Nullable</span> Drawable errorDrawable)</span> &#123;</span><br><span class="line">  <span class="built_in">super</span>.onLoadFailed(errorDrawable);</span><br><span class="line">  setResourceInternal(<span class="literal">null</span>);</span><br><span class="line">  setDrawable(errorDrawable);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onLoadCleared</span><span class="params">(<span class="meta">@Nullable</span> Drawable placeholder)</span> &#123;</span><br><span class="line">  <span class="built_in">super</span>.onLoadCleared(placeholder);</span><br><span class="line">  <span class="keyword">if</span> (animatable != <span class="literal">null</span>) &#123;</span><br><span class="line">    animatable.stop();</span><br><span class="line">  &#125;</span><br><span class="line">  setResourceInternal(<span class="literal">null</span>);</span><br><span class="line">  setDrawable(placeholder);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onResourceReady</span><span class="params">(<span class="meta">@NonNull</span> Z resource, <span class="meta">@Nullable</span> Transition&lt;? <span class="built_in">super</span> Z&gt; transition)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (transition == <span class="literal">null</span> || !transition.transition(resource, <span class="built_in">this</span>)) &#123;</span><br><span class="line">    setResourceInternal(resource);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    maybeUpdateAnimatable(resource);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setResourceInternal</span><span class="params">(<span class="meta">@Nullable</span> Z resource)</span> &#123;</span><br><span class="line">  setResource(resource);</span><br><span class="line">  maybeUpdateAnimatable(resource);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 因为 ImageView 可接受 Bitmap 和 Drawable 这两种图片资源类型，因此抽象出这个方法供子类实现</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">setResource</span><span class="params">(<span class="meta">@Nullable</span> Z resource)</span>;</span><br></pre></td></tr></table></figure>

<p>现在看下 RequestBuilder 含三个参数的 into() 方法：</p>
<p>[-&gt;RequestBuilder.java]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;Y <span class="keyword">extends</span> <span class="title class_">Target</span>&lt;TranscodeType&gt;&gt; Y <span class="title function_">into</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="meta">@NonNull</span> Y target,</span></span><br><span class="line"><span class="params">    <span class="meta">@Nullable</span> RequestListener&lt;TranscodeType&gt; targetListener,</span></span><br><span class="line"><span class="params">    <span class="meta">@NonNull</span> RequestOptions options)</span> &#123;</span><br><span class="line">  Util.assertMainThread();</span><br><span class="line">  Preconditions.checkNotNull(target);</span><br><span class="line">  <span class="keyword">if</span> (!isModelSet) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;You must call #load() before calling #into()&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  options = options.autoClone();</span><br><span class="line">  <span class="type">Request</span> <span class="variable">request</span> <span class="operator">=</span> buildRequest(target, targetListener, options);</span><br><span class="line">  <span class="type">Request</span> <span class="variable">previous</span> <span class="operator">=</span> target.getRequest();</span><br><span class="line">  <span class="keyword">if</span> (request.isEquivalentTo(previous)</span><br><span class="line">      &amp;&amp; !isSkipMemoryCacheWithCompletePreviousRequest(options, previous)) &#123;</span><br><span class="line">    request.recycle();</span><br><span class="line">    <span class="comment">// If the request is completed, beginning again will ensure the result is re-delivered,</span></span><br><span class="line">    <span class="comment">// triggering RequestListeners and Targets. If the request is failed, beginning again will</span></span><br><span class="line">    <span class="comment">// restart the request, giving it another chance to complete. If the request is already</span></span><br><span class="line">    <span class="comment">// running, we can let it continue running without interruption.</span></span><br><span class="line">    <span class="keyword">if</span> (!Preconditions.checkNotNull(previous).isRunning()) &#123;</span><br><span class="line">      <span class="comment">// Use the previous request rather than the new one to allow for optimizations like skipping</span></span><br><span class="line">      <span class="comment">// setting placeholders, tracking and un-tracking Targets, and obtaining View dimensions</span></span><br><span class="line">      <span class="comment">// that are done in the individual Request.</span></span><br><span class="line">      previous.begin();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br><span class="line">  requestManager.clear(target);</span><br><span class="line">  target.setRequest(request); <span class="comment">// 将 target 和 request 关联起来</span></span><br><span class="line">  requestManager.track(target, request); <span class="comment">// 将 target 和 request 添加进 requestManager 进行管理</span></span><br><span class="line">  <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>buildRequest() 创建了一个 Request，之后会判断这个 target 当前关联的 Request 是不是和这个新的 Request 是不是等效的，如果是，并且 isSkipMemoryCacheWithCompletePreviousRequest() 返回 false，便将这个新的 Request 回收掉，避免一个目标上有多个请求。然后判断之前的那个 Request 是不是还在跑，如果没有，那么就启动它，为什么这样做？注释里已经说的很清楚了，就是为了将当前绑定在 target 上的请求再执行一遍，这样请求完成后会将结果重新传递一遍；如果正在跑，没必要重启这个请求，因为请求完成之后会将结果传递回去。对于 isSkipMemoryCacheWithCompletePreviousRequest() 这个方法，其实有必要分析一下，为什么它返回 false 的时候才能将新的 Request 取消，不过目前为止我还没有完全理解，但还是先贴上这个方法供大家自行理解：</p>
<p>[-&gt;RequestBuilder.java]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// If the caller is using skipMemoryCache and the previous request is finished, calling begin on</span></span><br><span class="line"><span class="comment">// the previous request will complete from memory because it will just use the resource that had</span></span><br><span class="line"><span class="comment">// already been loaded. If the previous request isn&#x27;t complete, we can wait for it to finish</span></span><br><span class="line"><span class="comment">// because the previous request must also be using skipMemoryCache for the requests to be</span></span><br><span class="line"><span class="comment">// equivalent. See #2663 for additional context.</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isSkipMemoryCacheWithCompletePreviousRequest</span><span class="params">(</span></span><br><span class="line"><span class="params">    RequestOptions options, Request previous)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> !options.isMemoryCacheable() &amp;&amp; previous.isComplete();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>回到 into() 方法，真正处理加载请求的方法是 RequestManager#track() 方法：</p>
<p>[-&gt;RequestManager.java]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">track</span><span class="params">(Target&lt;?&gt; target, Request request)</span> &#123;</span><br><span class="line">  targetTracker.track(target);</span><br><span class="line">  requestTracker.runRequest(request);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>RequestManager 中有两个 “追踪器”，一个是 TargetTracker，另一个是 RequestTracker，前者用来管理 target，后者管理 request。由于 TargetTracker 和 Target 都实现了 LifecycleListener 接口，这样生命周期就能从 RequestManager 传到 Target。真正启动请求的方法是 RequestTracker#runRequest() ：</p>
<p>[-&gt;RequestTracker.java]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">runRequest</span><span class="params">(Request request)</span> &#123;</span><br><span class="line">  requests.add(request);</span><br><span class="line">  <span class="keyword">if</span> (!isPaused) &#123;</span><br><span class="line">    request.begin(); <span class="comment">// 执行请求</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    pendingRequests.add(request);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>RequestTracker 首先将 request 加入请求列表 requests 中，这个列表保存的是所有请求；然后判断是否需要暂停加载（受生命周期的控制），如果是，则开始请求，否则将这个请求放入待处理队列 pendingRequests 中。为什么要用一个 pendingRequest 来管理这些待处理请求呢？其实并不是为了将他们储存起来待以后执行，而仅仅是为了让他们不被回收。requests 持有的是 Request 的弱引用，如果请求没有马上执行，这些 Request 仅仅被弱引用持有，那么就有被回收的可能，将他们放入 pendingRequests 中就是为了让他们被强引用持有防止被回收。更详细的解释可以看看这个 <a target="_blank" rel="noopener" href="https://github.com/bumptech/glide/issues/346">issue</a>。</p>
<p>Request 是一个接口，它包含多了很多控制方法和状态查询方法。Request 在当前 Glide 版本中只有一个实现者：SingleRequest。SingleRequest 的 begin() 方法如下：</p>
<p>[-&gt;SingleRequest.java]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">begin</span><span class="params">()</span> &#123;</span><br><span class="line">  ......</span><br><span class="line">  <span class="keyword">if</span> (Util.isValidDimensions(overrideWidth, overrideHeight)) &#123;</span><br><span class="line">    onSizeReady(overrideWidth, overrideHeight);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    target.getSize(<span class="built_in">this</span>); </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ((status == Status.RUNNING || status == Status.WAITING_FOR_SIZE)</span><br><span class="line">      &amp;&amp; canNotifyStatusChanged()) &#123;</span><br><span class="line">    target.onLoadStarted(getPlaceholderDrawable());</span><br><span class="line">  &#125;</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>begin() 是 Request 的入口方法，它开启了图片请求的处理流程，而整个流程的第一步就是获取期望的图片宽高。第一个 if 语句块，它会判断用户是否显式要求了图片宽高，如果指明了，那么立马执行 onSizeReady()，否则执行 Target#getSize()。onSizeReady() 是 SingleRequest 实现的 SizeReadyCallback 接口中的方法。 </p>
<p>[-&gt;Target.java]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">getSize</span><span class="params">(<span class="meta">@NonNull</span> SizeReadyCallback cb)</span>;</span><br></pre></td></tr></table></figure>

<p>getSize() 的作用就是用来获取图片的宽高，获取成功之后就通过 SizeReadyCallback#onSizeRady() 将结果返回。Target 是目标用途的抽象，所以图片的宽高理应由它来指定。比如，对于 ViewTarget 来说，它的 getSize() 返回的就是 View 的宽高。这里我们可能就有疑问了，为什么 getSize() 要设计成异步的？其实答案很简单，对于 View 来说，它的宽高只有在 Activity#onResume() 之后才能获取到，严格来说是 View#layout() 之后才能获取到。请求发起时可能 View 的宽高还获取不到，因此将 getSize() 设计成异步的是理所应当的。现在重点是 onSizeReady() ：</p>
<p>[-&gt;SingleRequest.java]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">loadStatus = engine.load(</span><br><span class="line">    glideContext,</span><br><span class="line">    model,</span><br><span class="line">    requestOptions.getSignature(),</span><br><span class="line">    <span class="built_in">this</span>.width,</span><br><span class="line">    <span class="built_in">this</span>.height,</span><br><span class="line">    requestOptions.getResourceClass(),</span><br><span class="line">    transcodeClass,</span><br><span class="line">    priority,</span><br><span class="line">    requestOptions.getDiskCacheStrategy(),</span><br><span class="line">    requestOptions.getTransformations(),</span><br><span class="line">    requestOptions.isTransformationRequired(),</span><br><span class="line">    requestOptions.isScaleOnlyOrNoTransform(),</span><br><span class="line">    requestOptions.getOptions(),</span><br><span class="line">    requestOptions.isMemoryCacheable(),</span><br><span class="line">    requestOptions.getUseUnlimitedSourceGeneratorsPool(),</span><br><span class="line">    requestOptions.getUseAnimationPool(),</span><br><span class="line">    requestOptions.getOnlyRetrieveFromCache(),</span><br><span class="line">    <span class="built_in">this</span>);</span><br></pre></td></tr></table></figure>
<p>上面这段代码是 onSizeReady() 的主要逻辑，它调用了 Engine#load()，传入了一些和请求相关的各种参数，这个方法返回的是一个 LoadStatus 对象，关于它我们待会儿再分析。</p>
<p>[-&gt;Engine.java]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">EngineKey</span> <span class="variable">key</span> <span class="operator">=</span> keyFactory.buildKey(model, signature, width, height, transformations,</span><br><span class="line">    resourceClass, transcodeClass, options);</span><br><span class="line">EngineResource&lt;?&gt; active = loadFromActiveResources(key, isMemoryCacheable);</span><br><span class="line"><span class="keyword">if</span> (active != <span class="literal">null</span>) &#123;</span><br><span class="line">  cb.onResourceReady(active, DataSource.MEMORY_CACHE);</span><br><span class="line">  ......</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">EngineResource&lt;?&gt; cached = loadFromCache(key, isMemoryCacheable);</span><br><span class="line"><span class="keyword">if</span> (cached != <span class="literal">null</span>) &#123;</span><br><span class="line">  cb.onResourceReady(cached, DataSource.MEMORY_CACHE);</span><br><span class="line">  ......</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">EngineJob&lt;?&gt; current = jobs.get(key, onlyRetrieveFromCache);</span><br><span class="line"><span class="keyword">if</span> (current != <span class="literal">null</span>) &#123;</span><br><span class="line">  current.addCallback(cb);</span><br><span class="line">  ......</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LoadStatus</span>(cb, current);</span><br><span class="line">&#125;</span><br><span class="line">EngineJob&lt;R&gt; engineJob = engineJobFactory.build(key, isMemoryCacheable,</span><br><span class="line">        useUnlimitedSourceExecutorPool, useAnimationPool, onlyRetrieveFromCache);</span><br><span class="line">DecodeJob&lt;R&gt; decodeJob = decodeJobFactory.build(glideContext, model, key,</span><br><span class="line">        signature, width, height, resourceClass, transcodeClass, priority,</span><br><span class="line">        diskCacheStrategy, transformations, isTransformationRequired,</span><br><span class="line">        isScaleOnlyOrNoTransform, onlyRetrieveFromCache, options, engineJob);</span><br><span class="line">jobs.put(key, engineJob);</span><br><span class="line">engineJob.addCallback(cb);</span><br><span class="line">engineJob.start(decodeJob);</span><br><span class="line">......</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LoadStatus</span>(cb, engineJob);</span><br></pre></td></tr></table></figure>

<p>Engine#load() 方法的逻辑是：</p>
<ul>
<li>首先构建出标识这个请求的 Key，这个 Key 用来标识一个请求，Key 相同的 Request 是等效的。可以看出这个 Key 有多个参数组成，只要其中一个参数不同，Key 就不同，那么这个 Request 也就是与众不同的；</li>
<li>然后根据 Key 从 activy resource 中取出 EngineResource，EngineResource 是图片资源在内存中对应的对象，如果能找到，就调用 ResourceCallback#onResourceReady() 将获取的资源传回给 SingleRequest；</li>
<li>如果上个步骤获取的 EngineResource 为 null，那么就从根据 Key 从 cache 中获取，如果能获取到，同样将结果回传；</li>
<li>如果上个步骤获取的还是 null，那么在 jobs 中根据 Key 查找对应的 EngineJob。EngineJob 的作用文档中是这样说的：通过添加和移除回调、在加载任务完成时通知回调来管理一次加载。简单点说就是一次加载任务的回调管理器。如果能找到，便将 ResourceCallback 添加进去，然后返回一个 LoadStatus。这样做的目的就是避免重复请求，因为如果多个请求如果是等效的，没有必要为它们去加载多次，而只需要加载结果到来时逐个通知它们一遍就好。</li>
<li>如果找不到对应的 EngineJob，没办法，只能开个的 EngineJob 了。通过 EngineJobFactory#build() 新建一个 EngineJob 紧接着又通过 DecodeJobFactory#build() 新建了一个 DecodeJob 并将 EngineJob 传进去。DecodeJob 对应的是一个加载任务，当完成加载后会通过 EngineJob 这个回调管理器将结果送回到 SingleRequest 中。</li>
</ul>
<p>DecodeJob 承包了真正的加载任务，现在我们就从 Engine#start() 开始来分析一下 DecodeJob：</p>
<p>[-&gt;EngineJob.java]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">(DecodeJob&lt;R&gt; decodeJob)</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.decodeJob = decodeJob;</span><br><span class="line">  <span class="type">GlideExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> decodeJob.willDecodeFromCache()</span><br><span class="line">      ? diskCacheExecutor</span><br><span class="line">      : getActiveSourceExecutor();</span><br><span class="line">  executor.execute(decodeJob);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据需不需要从磁盘中获取资源，选择不同的线程池来执行资源加载任务。从这里可以看出 DecodeJob 实现了 Runnable 接口，因此资源加载逻辑应该全部在它的 run() 方法中：</p>
<p>[-&gt;DecodeJob.java]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">  ......</span><br><span class="line">  DataFetcher&lt;?&gt; localFetcher = currentFetcher;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isCancelled) &#123;</span><br><span class="line">      notifyFailed();</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    runWrapped();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// When we&#x27;re encoding we&#x27;ve already notified our callback and it isn&#x27;t safe to do so again.</span></span><br><span class="line">    <span class="keyword">if</span> (stage != Stage.ENCODE) &#123;</span><br><span class="line">      throwables.add(t);</span><br><span class="line">      notifyFailed();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!isCancelled) &#123;</span><br><span class="line">      <span class="keyword">throw</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// Keeping track of the fetcher here and calling cleanup is excessively paranoid, we call</span></span><br><span class="line">    <span class="comment">// close in all cases anyway.</span></span><br><span class="line">    <span class="keyword">if</span> (localFetcher != <span class="literal">null</span>) &#123;</span><br><span class="line">      localFetcher.cleanup();</span><br><span class="line">    &#125;</span><br><span class="line">    TraceCompat.endSection();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>其执行逻辑是：如果状态为 cancelled，或者任务执行时出现异常，那么就发出任务失败的通知；否则执行 runWrapper() 方法。</p>
<p>[-&gt;DecodeJob.java]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">runWrapped</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="keyword">switch</span> (runReason) &#123;</span><br><span class="line">    <span class="keyword">case</span> INITIALIZE:</span><br><span class="line">      stage = getNextStage(Stage.INITIALIZE);</span><br><span class="line">      currentGenerator = getNextGenerator();</span><br><span class="line">      runGenerators();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SWITCH_TO_SOURCE_SERVICE:</span><br><span class="line">      runGenerators();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> DECODE_DATA:</span><br><span class="line">      decodeFromRetrievedData();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Unrecognized run reason: &quot;</span> + runReason);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>runWrapper() 方法会根据 runReason 的值执行不同的分支。runReason 的初始值是 INITIALIZE，INITIALIZE 这条分支做的事是：</p>
<ul>
<li>通过 getNextStage() 获取下一个 Stage，Stage 用来表明当前的工作阶段；</li>
<li>通过 getNextGenerator() 获取下一个 DataFetcherGenerator，DataFetcherGenerator 顾名思义使用来产生 DataFethcer 的，关于 DataFetcher 及其作用之后会详细分析；</li>
<li>执行 runGenerators()。</li>
</ul>
<p>getNextStage() 的定义如下：</p>
<p>[-&gt;DecodeJob.java]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Stage <span class="title function_">getNextStage</span><span class="params">(Stage current)</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (current) &#123;</span><br><span class="line">    <span class="keyword">case</span> INITIALIZE:</span><br><span class="line">      <span class="keyword">return</span> diskCacheStrategy.decodeCachedResource()</span><br><span class="line">          ? Stage.RESOURCE_CACHE : getNextStage(Stage.RESOURCE_CACHE);</span><br><span class="line">    <span class="keyword">case</span> RESOURCE_CACHE:</span><br><span class="line">      <span class="keyword">return</span> diskCacheStrategy.decodeCachedData()</span><br><span class="line">          ? Stage.DATA_CACHE : getNextStage(Stage.DATA_CACHE);</span><br><span class="line">    <span class="keyword">case</span> DATA_CACHE:</span><br><span class="line">      <span class="comment">// Skip loading from source if the user opted to only retrieve the resource from cache.</span></span><br><span class="line">      <span class="keyword">return</span> onlyRetrieveFromCache ? Stage.FINISHED : Stage.SOURCE;</span><br><span class="line">    <span class="keyword">case</span> SOURCE:</span><br><span class="line">    <span class="keyword">case</span> FINISHED:</span><br><span class="line">      <span class="keyword">return</span> Stage.FINISHED;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Unrecognized stage: &quot;</span> + current);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法根据当前的 Stage 返回下一个 Stage，它的状态变迁可以用下图来表示:</p>
<p><img src="/img/in-post/post_android_open_source_library_glide/post-3.png" alt="Stage 状态变迁图"></p>
<p>getNextGenerator() 的定义如下：</p>
<p>[-&gt;DecodeJob.java]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> DataFetcherGenerator <span class="title function_">getNextGenerator</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (stage) &#123;</span><br><span class="line">    <span class="keyword">case</span> RESOURCE_CACHE:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ResourceCacheGenerator</span>(decodeHelper, <span class="built_in">this</span>);</span><br><span class="line">    <span class="keyword">case</span> DATA_CACHE:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataCacheGenerator</span>(decodeHelper, <span class="built_in">this</span>);</span><br><span class="line">    <span class="keyword">case</span> SOURCE:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SourceGenerator</span>(decodeHelper, <span class="built_in">this</span>);</span><br><span class="line">    <span class="keyword">case</span> FINISHED:</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Unrecognized stage: &quot;</span> + stage);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法根据当期的 Stage 返回不同的 DataFetcherGenerator，DataFetcherGenerator 的作用是用注册的 ModelLoader 和 Model 产生 DataFetcher 来加载数据。读到这里大家可能有点难理解，因此，在继续深入下去之前，我们有必要了解下 DecodeJob 加载图片资源的整个过程以及 Model，ModelLoader，DataFetcher 等类的的角色和作用，这样有助于后面的分析和理解。</p>
<p>首先我们了解一下 DecodeJob 加载资源的流程，DecodeJob 加载资源的过程中资源类型的变化可以这样来表示：</p>
<p><strong>Model</strong> &#x3D;&gt; <strong>Data</strong> &#x3D;&gt; <strong>Decoded Resource</strong> &#x3D;&gt; <strong>Transcoded Resource</strong>。 </p>
<ul>
<li>Model 一开始是通过 RequestManager#load() 穿过来的，它的类型可以有很多种，它可以是 String，Uri，Drawable，Bitmap，byte[]等。我们可以把它理解成图片加载过程的初始对象；</li>
<li>Data 是原始的数据流，它一般以二进制的形式存在，例如 InputStream，ByteBuffer，byte[]。但也不绝对是二进制流，它也可以是 Bitmap，Drawble 等资源对象，这样看 Model 传入的初始对象是什么；</li>
<li>Decode Resource 是解码好的图片对象，例如 Bitmap，GitDrawable 等；</li>
<li>Transcoded Resource 是最终期望的图片资源类型，它的类型和 RequestBuilder#as() 接受的类型以及 Target 可接受的类型是保持一致的，也就是说这个类型就是“目标类型”，它的类型可以有很多，比如 Bitmap，Drawable，byte[] 等。</li>
</ul>
<p>如果我们传入的 model 为一个 Uri，而我们的目标类型为 Bitmap 时，Glide 是如何处理的呢？首先，Glide 会将 String（Model） 转换成 InputStream（Data)，再将 InputStream（Data）转换成 Bitmap（Decoded Resource），最后再由 Bitmap（Decoded Resource）到 Bitmap（Transcoded Resource）。其实 Decode Resource 到 Transcoded Resource 资源的类型是一样的，因此 Glide 其实不会做任何事。</p>
<p>同理，如果我们传入的 model 是一个 Bitmap，目标类型也是 Bitmap 类型时，由于资源类型至始至终都没有发生变化，那么 Data，Decoded Resource，Transocded Resource 的类型都是 Bitmap。你会说这有什么意义呢？我们知道整个加载流程发生变化的不仅仅是资源类型，还有资源的尺寸等。我们的确可以直接通过 ImageView#setImageBitmap() 方法将一张 Bitmap 设置给 ImageView，但是忽略 ImageView 的大小而将 Bitmap 以原始尺寸显示是很浪费内存的。通常我们会对 Bitmap 进行压缩，必要的话还需要将压缩后的图片进行缓存，如果不利用 Glide，这将是一件很麻烦的是事，而 Glide 使得这个过程的工作量大大减少。</p>
<p>在加载过程中，资源的类型的变化是由 Glide 中特定的对象来完成的，例如 Model 到 Data 的转化就是 ModelLoader 来完成的，Data 到 Decoded Resource 的转换是由 ResourceDecoder 完成的，Decoded Resource 到 Transcoded Resource 的过程是由 ResourceTranscoder 来完成的。以上三者都只是接口，它们在 Glide 由许许多多的实现类，每个实现类都完成特定的两种资源类型的转换，比如 HttpUrlLoader 是一个 ModelLoader，它完成 Uri（Model） 到 InputStream（Data） 的转换过程。</p>
<p>现在我们来看下 ModelLoader 的定义吧：</p>
<p>[-&gt;ModelLoader.java]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ModelLoader</span>&lt;Model, Data&gt; &#123;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">LoadData</span>&lt;Data&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Key sourceKey;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> List&lt;Key&gt; alternateKeys;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> DataFetcher&lt;Data&gt; fetcher;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LoadData</span><span class="params">(<span class="meta">@NonNull</span> Key sourceKey, <span class="meta">@NonNull</span> DataFetcher&lt;Data&gt; fetcher)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>(sourceKey, Collections.&lt;Key&gt;emptyList(), fetcher);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LoadData</span><span class="params">(<span class="meta">@NonNull</span> Key sourceKey, <span class="meta">@NonNull</span> List&lt;Key&gt; alternateKeys,</span></span><br><span class="line"><span class="params">        <span class="meta">@NonNull</span> DataFetcher&lt;Data&gt; fetcher)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.sourceKey = Preconditions.checkNotNull(sourceKey);</span><br><span class="line">      <span class="built_in">this</span>.alternateKeys = Preconditions.checkNotNull(alternateKeys);</span><br><span class="line">      <span class="built_in">this</span>.fetcher = Preconditions.checkNotNull(fetcher);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 构造一个 LoadData 对象</span></span><br><span class="line">  <span class="meta">@Nullable</span></span><br><span class="line">  LoadData&lt;Data&gt; <span class="title function_">buildLoadData</span><span class="params">(<span class="meta">@NonNull</span> Model model, <span class="type">int</span> width, <span class="type">int</span> height,</span></span><br><span class="line"><span class="params">      <span class="meta">@NonNull</span> Options options)</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 该 ModelLoader 能否处理此 model</span></span><br><span class="line">  <span class="type">boolean</span> <span class="title function_">handles</span><span class="params">(<span class="meta">@NonNull</span> Model model)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ModelLoader 有两个方法，它们的作用在代码中已经说明了。LoadData 是 ModelLaoder 的内部类，它的内部有一个 DataFetcher 对象，从名字就能知道它的作用是数据的携带者，它用来对数据实行懒加载。我们看下 DataFetcher 的定义：</p>
<p>[-&gt;DataFetcher.java]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DataFetcher</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">interface</span> <span class="title class_">DataCallback</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onDataReady</span><span class="params">(<span class="meta">@Nullable</span> T data)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onLoadFailed</span><span class="params">(<span class="meta">@NonNull</span> Exception e)</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">loadData</span><span class="params">(<span class="meta">@NonNull</span> Priority priority, <span class="meta">@NonNull</span> DataCallback&lt;? <span class="built_in">super</span> T&gt; callback)</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">cleanup</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">cancel</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@NonNull</span></span><br><span class="line">  Class&lt;T&gt; <span class="title function_">getDataClass</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@NonNull</span></span><br><span class="line">  DataSource <span class="title function_">getDataSource</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>容易知道，它的 loadData() 方法就是用来加载数据的，当数据加载完成后它通过 DataCallback 将结果返回给调用者。现在我们可以理解为什么它对数据的加载被称为懒加载了，因为 ModelLoader 构建出 LoadData 这个过程根本没有发生数据的加载，数据的真正加载是调用 DataFetcher#load() 实现的。</p>
<p>现在我们回到 DecodeJob 中，我们接着分析它的 runGenerators() 方法：</p>
<p>[-&gt;DecodeJob.java]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">runGenerators</span><span class="params">()</span> &#123;</span><br><span class="line">  currentThread = Thread.currentThread();</span><br><span class="line">  startFetchTime = LogTime.getLogTime();</span><br><span class="line">  <span class="type">boolean</span> <span class="variable">isStarted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">while</span> (!isCancelled &amp;&amp; currentGenerator != <span class="literal">null</span></span><br><span class="line">      &amp;&amp; !(isStarted = currentGenerator.startNext())) &#123;</span><br><span class="line">    stage = getNextStage(stage);</span><br><span class="line">    currentGenerator = getNextGenerator();</span><br><span class="line">    <span class="keyword">if</span> (stage == Stage.SOURCE) &#123;</span><br><span class="line">      reschedule();</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// We&#x27;ve run out of stages and generators, give up.</span></span><br><span class="line">  <span class="keyword">if</span> ((stage == Stage.FINISHED || isCancelled) &amp;&amp; !isStarted) &#123;</span><br><span class="line">    notifyFailed();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Otherwise a generator started a new load and we expect to be called back in</span></span><br><span class="line">  <span class="comment">// onDataFetcherReady.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法的核心逻辑是取出一个 Stage，根据该 Stage 返回相应的 DataFetcherGenerator 并执行其 startNext() 方法，然后再取出下一个 Stage……如此循环。</p>
<p>其中 ResourceCacheGenerator 和 DataCacheGenerator 的资源获取方式都是从磁盘缓存中获取，不同的是，前者是从压缩和变换后的图片缓存中获取，后者是从原始图片数据缓存中获取。而 SourceGenerator 获取资源的方式则是从资源的原始位置获取，比如网络。这三者的工作原理大同小异，这里我们只分析 SourceGenerator#startNext() 方法：</p>
<p>[-&gt;SourceGenerator.java]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">startNext</span><span class="params">()</span> &#123;</span><br><span class="line">  ......</span><br><span class="line">  loadData = <span class="literal">null</span>;</span><br><span class="line">  <span class="type">boolean</span> <span class="variable">started</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">while</span> (!started &amp;&amp; hasNextModelLoader()) &#123;</span><br><span class="line">    loadData = helper.getLoadData().get(loadDataListIndex++);</span><br><span class="line">    <span class="keyword">if</span> (loadData != <span class="literal">null</span></span><br><span class="line">        &amp;&amp; (helper.getDiskCacheStrategy().isDataCacheable(loadData.fetcher.getDataSource())</span><br><span class="line">        || helper.hasLoadPath(loadData.fetcher.getDataClass()))) &#123;</span><br><span class="line">      started = <span class="literal">true</span>;</span><br><span class="line">      loadData.fetcher.loadData(helper.getPriority(), <span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> started;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>helper 是 DecodeHelper 对象，DecodeHelper 是一个帮助类，其实就是把原本属于 DecodeJob 的某些属性和方法抽离出去得到的类，估计是作者重构时新添的类，用来减轻 DecodeJob 的工作。它的 getLoadData() 是什么意思呢？我们根据代码来分析下：</p>
<p>[-&gt;DecodeHelper.java]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">List&lt;LoadData&lt;?&gt;&gt; getLoadData() &#123;</span><br><span class="line">  <span class="keyword">if</span> (!isLoadDataSet) &#123;</span><br><span class="line">    isLoadDataSet = <span class="literal">true</span>;</span><br><span class="line">    loadData.clear();</span><br><span class="line">    List&lt;ModelLoader&lt;Object, ?&gt;&gt; modelLoaders = glideContext.getRegistry().getModelLoaders(model);</span><br><span class="line">    <span class="comment">//noinspection ForLoopReplaceableByForEach to improve perf</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, size = modelLoaders.size(); i &lt; size; i++) &#123;</span><br><span class="line">      ModelLoader&lt;Object, ?&gt; modelLoader = modelLoaders.get(i);</span><br><span class="line">      LoadData&lt;?&gt; current =</span><br><span class="line">          modelLoader.buildLoadData(model, width, height, options);</span><br><span class="line">      <span class="keyword">if</span> (current != <span class="literal">null</span>) &#123;</span><br><span class="line">        loadData.add(current);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> loadData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法返回的是一个 LoadData 集合，这个集合是如何得到的呢？在 for 循环中，遍历上一步得到的 ModelLoader 列表，逐个调用其 buildLoadData() 方法，将得到的 LoadData 添加到结果中。这些 ModelLoader 是通过 Register#getModelLoader() 得到的，这个方法的内部实现虽然繁琐但是很简单：从 Register 中筛选所有能够处理该 Model 的 ModelLoader。筛选的依据就是 ModelLoader#handles() 的返回值，这点之前已经讲过了。Register 是一个注册中心，它会将所有的 ModelLoader，ResourceDecoder 和 ResourceTranscoder 在 Glide 初始化时注册进去。我们摘取部分代码来看：</p>
<p>[-&gt;Glide.java]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">registry</span><br><span class="line">        .append(ByteBuffer.class, <span class="keyword">new</span> <span class="title class_">ByteBufferEncoder</span>())</span><br><span class="line">        .append(InputStream.class, <span class="keyword">new</span> <span class="title class_">StreamEncoder</span>(arrayPool))</span><br><span class="line">        <span class="comment">/* Bitmaps */</span></span><br><span class="line">        .append(Registry.BUCKET_BITMAP, InputStream.class, Bitmap.class, streamBitmapDecoder)</span><br><span class="line">        .append(Bitmap.class, Bitmap.class, UnitModelLoader.Factory.&lt;Bitmap&gt;getInstance())</span><br><span class="line">        .append(</span><br><span class="line">            Registry.BUCKET_BITMAP, Bitmap.class, Bitmap.class, <span class="keyword">new</span> <span class="title class_">UnitBitmapDecoder</span>())</span><br><span class="line">        <span class="comment">/* BitmapDrawables */</span></span><br><span class="line">        .append(</span><br><span class="line">            Registry.BUCKET_BITMAP_DRAWABLE,</span><br><span class="line">            ByteBuffer.class,</span><br><span class="line">            BitmapDrawable.class,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">BitmapDrawableDecoder</span>&lt;&gt;(resources, byteBufferBitmapDecoder))</span><br><span class="line">        .append(BitmapDrawable.class, <span class="keyword">new</span> <span class="title class_">BitmapDrawableEncoder</span>(bitmapPool, bitmapEncoder))</span><br><span class="line">        <span class="comment">/* GIFs */</span></span><br><span class="line">        .append(</span><br><span class="line">            Registry.BUCKET_GIF,</span><br><span class="line">            InputStream.class,</span><br><span class="line">            GifDrawable.class,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">StreamGifDecoder</span>(registry.getImageHeaderParsers(), byteBufferGifDecoder, arrayPool))</span><br><span class="line">        <span class="comment">/* GIF Frames */</span></span><br><span class="line">        .append(</span><br><span class="line">            GifDecoder.class, GifDecoder.class, UnitModelLoader.Factory.&lt;GifDecoder&gt;getInstance())</span><br><span class="line">        <span class="comment">/* Drawables */</span></span><br><span class="line">        .append(Uri.class, Drawable.class, resourceDrawableDecoder)</span><br><span class="line">        .append(</span><br><span class="line">            Uri.class, Bitmap.class, <span class="keyword">new</span> <span class="title class_">ResourceBitmapDecoder</span>(resourceDrawableDecoder, bitmapPool))</span><br><span class="line">        <span class="comment">/* Files */</span></span><br><span class="line">        .append(File.class, InputStream.class, <span class="keyword">new</span> <span class="title class_">FileLoader</span>.StreamFactory())</span><br><span class="line">        .append(File.class, File.class, <span class="keyword">new</span> <span class="title class_">FileDecoder</span>())</span><br><span class="line">        .append(File.class, File.class, UnitModelLoader.Factory.&lt;File&gt;getInstance())</span><br><span class="line">        <span class="comment">/* Models */</span></span><br><span class="line">        .register(<span class="keyword">new</span> <span class="title class_">InputStreamRewinder</span>.Factory(arrayPool))</span><br><span class="line">        .append(<span class="type">int</span>.class, InputStream.class, resourceLoaderStreamFactory)</span><br><span class="line">        .append(<span class="type">int</span>.class, Uri.class, resourceLoaderUriFactory)</span><br><span class="line">        .append(String.class, InputStream.class, <span class="keyword">new</span> <span class="title class_">StringLoader</span>.StreamFactory())</span><br><span class="line">        .append(Uri.class, InputStream.class, <span class="keyword">new</span> <span class="title class_">HttpUriLoader</span>.Factory())</span><br><span class="line">        .append(Uri.class, File.class, <span class="keyword">new</span> <span class="title class_">MediaStoreFileLoader</span>.Factory(context))</span><br><span class="line">        .append(<span class="type">byte</span>[].class, ByteBuffer.class, <span class="keyword">new</span> <span class="title class_">ByteArrayLoader</span>.ByteBufferFactory())</span><br><span class="line">        .append(<span class="type">byte</span>[].class, InputStream.class, <span class="keyword">new</span> <span class="title class_">ByteArrayLoader</span>.StreamFactory())</span><br><span class="line">        .append(Uri.class, Uri.class, UnitModelLoader.Factory.&lt;Uri&gt;getInstance())</span><br><span class="line">        .append(Drawable.class, Drawable.class, UnitModelLoader.Factory.&lt;Drawable&gt;getInstance())</span><br><span class="line">        .append(Drawable.class, Drawable.class, <span class="keyword">new</span> <span class="title class_">UnitDrawableDecoder</span>())</span><br><span class="line">        <span class="comment">/* Transcoders */</span></span><br><span class="line">        .register(</span><br><span class="line">            Bitmap.class,</span><br><span class="line">            BitmapDrawable.class,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">BitmapDrawableTranscoder</span>(resources))</span><br><span class="line">        .register(Bitmap.class, <span class="type">byte</span>[].class, bitmapBytesTranscoder)</span><br><span class="line">        .register(</span><br><span class="line">            Drawable.class,</span><br><span class="line">            <span class="type">byte</span>[].class,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">DrawableBytesTranscoder</span>(</span><br><span class="line">                bitmapPool, bitmapBytesTranscoder, gifDrawableBytesTranscoder))</span><br><span class="line">        .register(GifDrawable.class, <span class="type">byte</span>[].class, gifDrawableBytesTranscoder);</span><br></pre></td></tr></table></figure>

<p>由于代码太长，我只贴了部分注册内容。上面这些代码应该很容易看懂，几乎每个注册方法都会接受两个 Class 类型的对象和一个 ModelLoader 或者 ResourceDecoder 或者 ResourceTranscoder 对象，表示该 ModelLoader 或者 ResourceDecoder 或者 ResourceTranscoder 对象能够实现哪两种资源类型的转换。可以用下图来表示资源的类型变化过程：</p>
<p><img src="/img/in-post/post_android_open_source_library_glide/post-4.png" alt="资源的类型变化过程"></p>
<p>由上图可知，如果无法找到一组 (ModelLoader, ResourceDecoder, ResourceTranscoder)，使得资源类型由 Model 转换到 Transcoded Resource，那么加载便会失败。反之，可能有多组 (ModelLoader, ResourceDecoder, ResourceTranscoder) 能够实现 Model 到 Transcoded Resource 的转换。</p>
<p>现在回到 SourceGenerator#startNext()：</p>
<p>[-&gt;SourceGenerator.java]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">startNext</span><span class="params">()</span> &#123;</span><br><span class="line">  ......</span><br><span class="line">  loadData = <span class="literal">null</span>;</span><br><span class="line">  <span class="type">boolean</span> <span class="variable">started</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">while</span> (!started &amp;&amp; hasNextModelLoader()) &#123;</span><br><span class="line">    loadData = helper.getLoadData().get(loadDataListIndex++);</span><br><span class="line">    <span class="keyword">if</span> (loadData != <span class="literal">null</span></span><br><span class="line">        &amp;&amp; (helper.getDiskCacheStrategy().isDataCacheable(loadData.fetcher.getDataSource())</span><br><span class="line">        || helper.hasLoadPath(loadData.fetcher.getDataClass()))) &#123;</span><br><span class="line">      started = <span class="literal">true</span>;</span><br><span class="line">      loadData.fetcher.loadData(helper.getPriority(), <span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> started;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过前面的分析我们知道，DecodeHelper#getLoadData() 返回的是所有能够处理 Model 对象的 ModelLoader 构建出的 LoadData 的集合。循环体中做的事就是选择第一个满足条件的 LoadData，用它内部的 DataFetcher 对象来加载出 Data。之前在分析 DataFetcher 的时候讲过，它的 loadData() 方法会通过 DataCallback 将 Data 传回调用者。在这里调用者就是 SourceGenerator，它实现了 DataCallback 中的方法：</p>
<p>[-&gt;SourceGenerator.java]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onDataReady</span><span class="params">(Object data)</span> &#123;</span><br><span class="line">  <span class="type">DiskCacheStrategy</span> <span class="variable">diskCacheStrategy</span> <span class="operator">=</span> helper.getDiskCacheStrategy();</span><br><span class="line">  <span class="keyword">if</span> (data != <span class="literal">null</span> &amp;&amp; diskCacheStrategy.isDataCacheable(loadData.fetcher.getDataSource())) &#123;</span><br><span class="line">    dataToCache = data;</span><br><span class="line">    <span class="comment">// We might be being called back on someone else&#x27;s thread. Before doing anything, we should</span></span><br><span class="line">    <span class="comment">// reschedule to get back onto Glide&#x27;s thread.</span></span><br><span class="line">    cb.reschedule();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    cb.onDataFetcherReady(loadData.sourceKey, data, loadData.fetcher,</span><br><span class="line">        loadData.fetcher.getDataSource(), originalKey);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onLoadFailed</span><span class="params">(<span class="meta">@NonNull</span> Exception e)</span> &#123;</span><br><span class="line">  cb.onDataFetcherFailed(originalKey, e, loadData.fetcher, loadData.fetcher.getDataSource());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们重点分析 onDataReady() 方法，这个方法会根据回调所在的线程选择不同的执行路径，这里我们假设走到了 else 块中，那么 FetcherReadyCallback#onDataFetcherReady() 会得到调用。FetcherReadyCallback 也是一个回调接口，它的是实现者是 DecodeJob。这样一来，Data 便从 SourceGenerator 传到了 DecodeJob 中，我们现在看看 DecodeJob#onDataFethcerReady()：</p>
<p>[-&gt;DecodeJob.java]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onDataFetcherReady</span><span class="params">(Key sourceKey, Object data, DataFetcher&lt;?&gt; fetcher,</span></span><br><span class="line"><span class="params">    DataSource dataSource, Key attemptedKey)</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.currentSourceKey = sourceKey;</span><br><span class="line">  <span class="built_in">this</span>.currentData = data;</span><br><span class="line">  <span class="built_in">this</span>.currentFetcher = fetcher;</span><br><span class="line">  <span class="built_in">this</span>.currentDataSource = dataSource;</span><br><span class="line">  <span class="built_in">this</span>.currentAttemptingKey = attemptedKey;</span><br><span class="line">  <span class="keyword">if</span> (Thread.currentThread() != currentThread) &#123;</span><br><span class="line">    runReason = RunReason.DECODE_DATA;</span><br><span class="line">    callback.reschedule(<span class="built_in">this</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    TraceCompat.beginSection(<span class="string">&quot;DecodeJob.decodeFromRetrievedData&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      decodeFromRetrievedData();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      TraceCompat.endSection();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里同样会根据回调所在线程的不同执行不同的操作，但是最终都会调用到 decodeFromRetrievedData 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">decodeFromRetrievedData</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class="line">    logWithTimeAndKey(<span class="string">&quot;Retrieved data&quot;</span>, startFetchTime,</span><br><span class="line">        <span class="string">&quot;data: &quot;</span> + currentData</span><br><span class="line">        + <span class="string">&quot;, cache key: &quot;</span> + currentSourceKey</span><br><span class="line">        + <span class="string">&quot;, fetcher: &quot;</span> + currentFetcher);</span><br><span class="line">  &#125;</span><br><span class="line">  Resource&lt;R&gt; resource = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    resource = decodeFromData(currentFetcher, currentData, currentDataSource);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (GlideException e) &#123;</span><br><span class="line">    e.setLoggingDetails(currentAttemptingKey, currentDataSource);</span><br><span class="line">    throwables.add(e);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (resource != <span class="literal">null</span>) &#123;</span><br><span class="line">    notifyEncodeAndRelease(resource, currentDataSource);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    runGenerators();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>decodeFromData() 返回了 Transcoded Resource 类型的的图片资源。这个方法的内部细节即使不去分析我们也能略知一二，无非就是对 Data 使用合适的 ResourceDocoder 和 ResourceTranscoder 进行解码和转码。这个方法的最后调用了 notifyEncodeAndRelease()，这个方法最终会调用 DecodeJob.Callback#onResourceReady() 将最终的资源回传。EncodeJob 实现了该接口并且在构造 DecodeJob 时曾将自身作为参数传入，因此资源会被传入 EncodeJob#onResourceReady() 中。类似的 EncodeJob 又会通过回调将资源进一步传给 SingleRequest 中，SingleRequest 最后通过 Target#onResourceReady() 结果传给了 Target。</p>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>前面我们仅仅是沿着加载这条主线讲解了 Glide 内部原理，为了不使逻辑混乱，很多细节我们都带过了。为了加深对 Glide 的理解，我觉得有些问题还是有必要分析一下。</p>
<h3 id="Glide-是如何暂停加载任务的"><a href="#Glide-是如何暂停加载任务的" class="headerlink" title="Glide 是如何暂停加载任务的"></a>Glide 是如何暂停加载任务的</h3><p>我们知道 Glide 会借助 Activity 或者 Fragment 的生命周期来管理加载，那么具体它是如何再暂停和继续一个正在线程池中运行的加载任务呢？之前在分析 Engine#load() 的时候，对于它的返回值我暂时没讲，现在我们回到 Engine#load() 方法：</p>
<p>[-&gt;Engine.java]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">EngineKey</span> <span class="variable">key</span> <span class="operator">=</span> keyFactory.buildKey(model, signature, width, height, transformations,</span><br><span class="line">    resourceClass, transcodeClass, options);</span><br><span class="line">EngineResource&lt;?&gt; active = loadFromActiveResources(key, isMemoryCacheable);</span><br><span class="line"><span class="keyword">if</span> (active != <span class="literal">null</span>) &#123;</span><br><span class="line">  cb.onResourceReady(active, DataSource.MEMORY_CACHE);</span><br><span class="line">  ......</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">EngineResource&lt;?&gt; cached = loadFromCache(key, isMemoryCacheable);</span><br><span class="line"><span class="keyword">if</span> (cached != <span class="literal">null</span>) &#123;</span><br><span class="line">  cb.onResourceReady(cached, DataSource.MEMORY_CACHE);</span><br><span class="line">  ......</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">EngineJob&lt;?&gt; current = jobs.get(key, onlyRetrieveFromCache);</span><br><span class="line"><span class="keyword">if</span> (current != <span class="literal">null</span>) &#123;</span><br><span class="line">  current.addCallback(cb);</span><br><span class="line">  ......</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LoadStatus</span>(cb, current);</span><br><span class="line">&#125;</span><br><span class="line">EngineJob&lt;R&gt; engineJob = engineJobFactory.build(key, isMemoryCacheable,</span><br><span class="line">        useUnlimitedSourceExecutorPool, useAnimationPool, onlyRetrieveFromCache);</span><br><span class="line">DecodeJob&lt;R&gt; decodeJob = decodeJobFactory.build(glideContext, model, key,</span><br><span class="line">        signature, width, height, resourceClass, transcodeClass, priority,</span><br><span class="line">        diskCacheStrategy, transformations, isTransformationRequired,</span><br><span class="line">        isScaleOnlyOrNoTransform, onlyRetrieveFromCache, options, engineJob);</span><br><span class="line">jobs.put(key, engineJob);</span><br><span class="line">engineJob.addCallback(cb);</span><br><span class="line">engineJob.start(decodeJob);</span><br><span class="line">......</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LoadStatus</span>(cb, engineJob);</span><br></pre></td></tr></table></figure>
<p>我们知道它的返回值是 LoadStatus 对象，这个类的定义如下：</p>
<p>[-&gt;Engine.java]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">LoadStatus</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> EngineJob&lt;?&gt; engineJob;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ResourceCallback cb;</span><br><span class="line">  LoadStatus(ResourceCallback cb, EngineJob&lt;?&gt; engineJob) &#123;</span><br><span class="line">    <span class="built_in">this</span>.cb = cb;</span><br><span class="line">    <span class="built_in">this</span>.engineJob = engineJob;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cancel</span><span class="params">()</span> &#123;</span><br><span class="line">    engineJob.removeCallback(cb);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很简单，仅仅是封装了 EngineJob 和 ResourceCallback 两个对象。注意到他还有一个 cancel() 方法，这个方法的作用我想大家猜也能猜到，它是用来取消加载的。那么这个方法什么时候会调用呢？我们得回到 SingleRequest 中去寻找答案，因为 Engine#load() 是在 SingleRequest 中调用的，LoadStatus 对象肯定是要返回给 SingleRequest 的。</p>
<p>[-&gt;SingleRequest.java]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loadStatus = engine.load(...);</span><br></pre></td></tr></table></figure>

<p>SingleRequest 将返回的 LoadStatus 保存在了 loadStatus 中，现在我们看看 SingleRequest 的 pause() 方法，这个方法会在 RequestTracker#pauseRequests() 中调用，而 RequestTracker#pauseRequests() 会被 RequestManager#onStop() 触发：</p>
<p>[-&gt;SingleRequest.java]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pause</span><span class="params">()</span> &#123;</span><br><span class="line">  clear();</span><br><span class="line">  status = Status.PAUSED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">  ......</span><br><span class="line">  <span class="keyword">if</span> (status == Status.CLEARED) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  cancel();</span><br><span class="line">  ......</span><br><span class="line">  status = Status.CLEARED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">cancel</span><span class="params">()</span> &#123;</span><br><span class="line">  assertNotCallingCallbacks();</span><br><span class="line">  stateVerifier.throwIfRecycled();</span><br><span class="line">  target.removeCallback(<span class="built_in">this</span>);</span><br><span class="line">  status = Status.CANCELLED;</span><br><span class="line">  <span class="keyword">if</span> (loadStatus != <span class="literal">null</span>) &#123;</span><br><span class="line">    loadStatus.cancel();</span><br><span class="line">    loadStatus = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>pause() 方法最后会导致 loadStatus 的 cancel() 方法被调用，现在我们从 LoadStatus#cancel() 方法往下看，为什么 cancel() 就能将一个正在运行的加载任务给取消掉呢？LoadStatus#cancel() 只是简单调用了 EngineJob#removeCallback()：</p>
<p>[-&gt;EngineJob.java]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">removeCallback</span><span class="params">(ResourceCallback cb)</span> &#123;</span><br><span class="line">  Util.assertMainThread();</span><br><span class="line">  stateVerifier.throwIfRecycled();</span><br><span class="line">  <span class="keyword">if</span> (hasResource || hasLoadFailed) &#123;</span><br><span class="line">    addIgnoredCallback(cb);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    cbs.remove(cb);</span><br><span class="line">    <span class="keyword">if</span> (cbs.isEmpty()) &#123;</span><br><span class="line">      cancel();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法的意图很明了，假设加载还未完成的时候取消了加载，那么便会执行 else 中的代码块，从回调列表中删除该 ResourceCallback，但是移除还不够，因为移除回调仅仅是让 SingleRequest 接收不到最终的结果，我们还必须停止加载任务以节省资源。接下来会继续判断回调列表是否为空，如果为空就调用 cancel() 方法，这个方法就是用来取消加载任务的。这样看来，单单取消一个加载请求并不一定会导致这个加载任务的取消，这很容易理解，因为可能还有其他的请求依赖这个任务的执行。现在看看 EngineJob#cancel() 方法：</p>
<p>[-&gt;Engine.java]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">cancel</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (hasLoadFailed || hasResource || isCancelled) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  isCancelled = <span class="literal">true</span>;</span><br><span class="line">  decodeJob.cancel();</span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> Consider trying to remove jobs that have never been run before from executor queues.</span></span><br><span class="line">  <span class="comment">// Removing jobs that have run before can break things. See #1996.</span></span><br><span class="line">  listener.onEngineJobCancelled(<span class="built_in">this</span>, key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cancel</span><span class="params">()</span> &#123;</span><br><span class="line">  isCancelled = <span class="literal">true</span>;</span><br><span class="line">  <span class="type">DataFetcherGenerator</span> <span class="variable">local</span> <span class="operator">=</span> currentGenerator;</span><br><span class="line">  <span class="keyword">if</span> (local != <span class="literal">null</span>) &#123;</span><br><span class="line">    local.cancel();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法调用了 DecodeJob#cancel()，DecodeJob#cancel() 做了两件事，一是设置 isCancelled 为 true，二是停止当前 DataFetcherGenerator 中的任务。isCancelled 是一个标志，那么它对加载任务有什么影响呢？影响主要有两处，一个 DecodeJob#run()，另一个是 DecodeJob#runGenerators()。isCancelled&#x3D;&#x3D;true 会导致前者发出加载失败的通知，导致后者停止运行后续的 DataFetcherGenerator 并发出加载失败的通知。加载失败的通知最终会传到 EngineJob 中，使得 EngineJob 执行资源的释放工作。</p>
<p>有一个细节不知大家发现没有，DecodeJob 是被投入线程中运行的，也就是说 SingleRequest 和 DecodeJob 是在不同的线程中运行的。isCancelled 的改变是在 SingleRequest 的线程中进行的，而 DecodeJob 读取 isCancelled 的值是在 DecodeJob 的线程中发生的。那么这很容易发生一个问题，就是线程感知问题。那么 Glide 是如何解决这一问题的呢？我们看看 isCancelled 在 DecodeJob 中的定义：</p>
<p>[-&gt;DecodeJob.java]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> isCancelled;</span><br></pre></td></tr></table></figure>
<p>Glide 给 isCancelled 加了 volatile 关键字，这样保证了，SingleRequest 线程对 isCancelled 的改变能够及时被 DecodeJob 线程感知。同样的，currentGenerator 在定义时也使用了这个关键字，目的都是一样的。如果大家对于 volatile 关键字还不理解，可以到网上查阅相关资料，因为一时半会儿是解释不清的，我当初为了理解这个关键字花了不少时间。</p>
<h3 id="ModelLoader-的内部细节"><a href="#ModelLoader-的内部细节" class="headerlink" title="ModelLoader 的内部细节"></a>ModelLoader 的内部细节</h3><p>ModelLoader 的子类有很多，Glide 会根据 model 的类型决定使用哪种 ModelLoader。现假设 model 为 http 协议的 url 的话，Glide 最终就会用到 HttpGlideUrlLoader 实现 Model 到 Data 的转换。</p>
<p>[-&gt;HttpGlideUrlLoader]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HttpGlideUrlLoader</span> <span class="keyword">implements</span> <span class="title class_">ModelLoader</span>&lt;GlideUrl, InputStream&gt; &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Option&lt;Integer&gt; TIMEOUT = Option.memory(</span><br><span class="line">      <span class="string">&quot;com.bumptech.glide.load.model.stream.HttpGlideUrlLoader.Timeout&quot;</span>, <span class="number">2500</span>);</span><br><span class="line">  <span class="meta">@Nullable</span> <span class="keyword">private</span> <span class="keyword">final</span> ModelCache&lt;GlideUrl, GlideUrl&gt; modelCache;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">HttpGlideUrlLoader</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(<span class="literal">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">HttpGlideUrlLoader</span><span class="params">(<span class="meta">@Nullable</span> ModelCache&lt;GlideUrl, GlideUrl&gt; modelCache)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.modelCache = modelCache;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> LoadData&lt;InputStream&gt; <span class="title function_">buildLoadData</span><span class="params">(<span class="meta">@NonNull</span> GlideUrl model, <span class="type">int</span> width, <span class="type">int</span> height,</span></span><br><span class="line"><span class="params">      <span class="meta">@NonNull</span> Options options)</span> &#123;</span><br><span class="line">    <span class="type">GlideUrl</span> <span class="variable">url</span> <span class="operator">=</span> model;</span><br><span class="line">    <span class="keyword">if</span> (modelCache != <span class="literal">null</span>) &#123;</span><br><span class="line">      url = modelCache.get(model, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">      <span class="keyword">if</span> (url == <span class="literal">null</span>) &#123;</span><br><span class="line">        modelCache.put(model, <span class="number">0</span>, <span class="number">0</span>, model);</span><br><span class="line">        url = model;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">timeout</span> <span class="operator">=</span> options.get(TIMEOUT);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LoadData</span>&lt;&gt;(url, <span class="keyword">new</span> <span class="title class_">HttpUrlFetcher</span>(url, timeout));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">handles</span><span class="params">(<span class="meta">@NonNull</span> GlideUrl model)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Factory</span> <span class="keyword">implements</span> <span class="title class_">ModelLoaderFactory</span>&lt;GlideUrl, InputStream&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ModelCache&lt;GlideUrl, GlideUrl&gt; modelCache = <span class="keyword">new</span> <span class="title class_">ModelCache</span>&lt;&gt;(<span class="number">500</span>);</span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ModelLoader&lt;GlideUrl, InputStream&gt; <span class="title function_">build</span><span class="params">(MultiModelLoaderFactory multiFactory)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HttpGlideUrlLoader</span>(modelCache);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">teardown</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="comment">// Do nothing.</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重点是 HttpUrlFethcer，它的 loadData() 方法会调用 loadDataWithRedirects()：</p>
<p>[-&gt;HttpUrlFetcher.java]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> InputStream <span class="title function_">loadDataWithRedirects</span><span class="params">(URL url, <span class="type">int</span> redirects, URL lastUrl,</span></span><br><span class="line"><span class="params">    Map&lt;String, String&gt; headers)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">  .....</span><br><span class="line">  urlConnection = connectionFactory.build(url);</span><br><span class="line">  <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; headerEntry : headers.entrySet()) &#123;</span><br><span class="line">    urlConnection.addRequestProperty(headerEntry.getKey(), headerEntry.getValue());</span><br><span class="line">  &#125;</span><br><span class="line">  urlConnection.setConnectTimeout(timeout);</span><br><span class="line">  urlConnection.setReadTimeout(timeout);</span><br><span class="line">  urlConnection.setUseCaches(<span class="literal">false</span>);</span><br><span class="line">  urlConnection.setDoInput(<span class="literal">true</span>);</span><br><span class="line">  ......</span><br><span class="line">  urlConnection.setInstanceFollowRedirects(<span class="literal">false</span>);</span><br><span class="line">  <span class="comment">// Connect explicitly to avoid errors in decoders if connection fails.</span></span><br><span class="line">  urlConnection.connect();</span><br><span class="line">  <span class="keyword">if</span> (isCancelled) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">final</span> <span class="type">int</span> <span class="variable">statusCode</span> <span class="operator">=</span> urlConnection.getResponseCode();</span><br><span class="line">  <span class="keyword">if</span> (statusCode / <span class="number">100</span> == <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> getStreamForSuccessfulRequest(urlConnection);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (statusCode / <span class="number">100</span> == <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">redirectUrlString</span> <span class="operator">=</span> urlConnection.getHeaderField(<span class="string">&quot;Location&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (TextUtils.isEmpty(redirectUrlString)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">HttpException</span>(<span class="string">&quot;Received empty or null redirect url&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">URL</span> <span class="variable">redirectUrl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(url, redirectUrlString);</span><br><span class="line">    <span class="keyword">return</span> loadDataWithRedirects(redirectUrl, redirects + <span class="number">1</span>, url, headers);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (statusCode == -<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">HttpException</span>(statusCode);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">HttpException</span>(urlConnection.getResponseMessage(), statusCode);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里就是 Glide 和网络交互的地方，Glide 通过 HttpUrlConnection 进行网络连接，并且对可能存在的重定向情况进行了处理，HttpUrlFetcher 最终会将获取到的 InputStream 作为 Data 返回。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上便是 Glide 的加载流程，它内部的运作实在是太复杂了，但正是这种复杂的内部实现使得 Glide 的可扩展型得到增强。比如我们可以自定义磁盘缓存策略，自定义 ModelLoader 以实现 Model 到 Data 的转换，也可以自定义 ResourceDecoder 和 ResourceTranscoder 来实现资源的解码和转码。最后，我们用一张图来总结整个加载过程：</p>
<p><img src="/img/in-post/post_android_open_source_library_glide/post-5.png" alt="Glide 数据转换流程图"></p>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>lwenkun
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://lwenkun.github.io/2017/07/20/2017-7-20-android-open-source-library-glide/" title="Glide 源码探究">https://lwenkun.github.io/2017/07/20/2017-7-20-android-open-source-library-glide/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Android/" rel="tag"># Android</a>
              <a href="/tags/%E5%BC%80%E6%BA%90%E5%BA%93/" rel="tag"># 开源库</a>
              <a href="/tags/Glide/" rel="tag"># Glide</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2017/05/30/2017-05-30-operating-system-conclusion/" rel="prev" title="操作系统原理总结">
      <i class="fa fa-chevron-left"></i> 操作系统原理总结
    </a></div>
      <div class="post-nav-item">
    <a href="/2017/08/29/2017-08-29-java-annotation/" rel="next" title="Java 注解学习总结">
      Java 注解学习总结 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <script src="https://utteranc.es/client.js"                                     repo="Lwenkun/lwenkun.github.io"                                     issue-term="pathname"                                     theme="github-dark"                                     crossorigin="anonymous"                                     async>                                 </script>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Glide-%E6%BA%90%E7%A0%81%E6%8E%A2%E7%A9%B6"><span class="nav-number">1.</span> <span class="nav-text">Glide 源码探究</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-number">1.1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Glide-%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8"><span class="nav-number">1.2.</span> <span class="nav-text">Glide 的简单使用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Glide-%E5%8E%9F%E7%90%86"><span class="nav-number">1.3.</span> <span class="nav-text">Glide 原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96-RequestManager"><span class="nav-number">1.3.1.</span> <span class="nav-text">获取 RequestManager</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA-RequestBuilder"><span class="nav-number">1.3.2.</span> <span class="nav-text">创建 RequestBuilder</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Request-%E7%9A%84%E6%9E%84%E5%BB%BA%E5%92%8C%E6%89%A7%E8%A1%8C"><span class="nav-number">1.3.3.</span> <span class="nav-text">Request 的构建和执行</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A1%A5%E5%85%85"><span class="nav-number">1.4.</span> <span class="nav-text">补充</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Glide-%E6%98%AF%E5%A6%82%E4%BD%95%E6%9A%82%E5%81%9C%E5%8A%A0%E8%BD%BD%E4%BB%BB%E5%8A%A1%E7%9A%84"><span class="nav-number">1.4.1.</span> <span class="nav-text">Glide 是如何暂停加载任务的</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ModelLoader-%E7%9A%84%E5%86%85%E9%83%A8%E7%BB%86%E8%8A%82"><span class="nav-number">1.4.2.</span> <span class="nav-text">ModelLoader 的内部细节</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">1.5.</span> <span class="nav-text">总结</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Chance Li"
      src="https://www.gravatar.com/avatar/95a0f14d3e6b40995a92c41673fd09d4?s=640">
  <p class="site-author-name" itemprop="name">Chance Li</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">25</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">23</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Lwenkun" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Lwenkun" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:lwenkun666@gmail.com" title="E-Mail → mailto:lwenkun666@gmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/u/5261683001" title="微博 → https:&#x2F;&#x2F;weibo.com&#x2F;u&#x2F;5261683001" rel="noopener" target="_blank"><i class="fa fa-fw fa-weibo"></i>微博</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.zhihu.com/people/li-wen-kun-40" title="知乎 → https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;li-wen-kun-40" rel="noopener" target="_blank"><i class="fa fa-fw fa-zhihu"></i>知乎</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title">
      <i class="fa fa-fw fa-link"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="http://ylqhust.github.io/" title="http:&#x2F;&#x2F;ylqhust.github.io" rel="noopener" target="_blank">ylqhust的博客</a>
        </li>
    </ul>
  </div>

      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Chance Li</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">227k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">3:26</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
